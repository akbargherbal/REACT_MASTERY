<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>22_Advanced_TypeScript_Patterns_in_React</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <style>
        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --secondary: #8b5cf6;
            --bg-main: #0f172a;
            --bg-card: #1e293b;
            --bg-code: #0f172a;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --border: #334155;
            --accent: #06b6d4;
            --success: #10b981;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            line-height: 1.7; 
            color: var(--text-primary); 
            background: var(--bg-main);
        }
        
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            padding: 20px; 
        }
        
        .home-btn { 
            position: fixed; 
            top: 20px; 
            right: 20px; 
            background: var(--accent);
            color: white; 
            width: 50px;
            height: 50px;
            border-radius: 50%;
            text-decoration: none; 
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(6, 182, 212, 0.4);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .home-btn:hover { 
            background: #0891b2;
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(6, 182, 212, 0.5);
        }
        
        .breadcrumb { 
            background: var(--bg-card);
            padding: 12px 0; 
            margin-bottom: 24px; 
            font-size: 14px;
            border-radius: 8px;
            border: 1px solid var(--border);
        }
        
        .breadcrumb a { 
            color: var(--accent);
            text-decoration: none;
            transition: color 0.2s;
        }
        
        .breadcrumb a:hover { 
            color: var(--primary);
            text-decoration: underline;
        }
        
        .content { 
            background: var(--bg-card);
            padding: 3rem; 
            border-radius: 16px; 
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border);
        }
        
        .file-list { 
            display: grid; 
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); 
            gap: 1.5rem; 
            margin: 2rem 0; 
        }
        
        .file-item { 
            padding: 1.5rem; 
            border: 1px solid var(--border);
            border-radius: 12px; 
            background: var(--bg-main);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .file-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .file-item:hover { 
            transform: translateY(-4px); 
            box-shadow: 0 8px 30px rgba(99, 102, 241, 0.3);
            border-color: var(--primary);
        }
        
        .file-item:hover::before {
            opacity: 1;
        }
        
        .file-item a { 
            color: var(--text-primary);
            text-decoration: none; 
            font-weight: 600; 
            display: block;
            font-size: 1.1rem;
        }
        
        .file-item a:hover { 
            color: var(--primary);
        }
        
        .file-type { 
            font-size: 13px; 
            color: var(--text-secondary);
            margin-top: 8px; 
            font-weight: 500;
        }
        
        /* Code Blocks */
        pre { 
            background: var(--bg-code);
            padding: 1.5rem; 
            border-radius: 12px; 
            overflow-x: auto;
            border: 1px solid var(--border);
            margin: 1.5rem 0;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            position: relative;
        }
        
        pre code { 
            background: none;
            padding: 0;
            font-family: 'Fira Code', 'Consolas', monospace;
            font-size: 0.9em;
            line-height: 1.6;
        }
        
        /* Copy Button */
        .copy-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: var(--primary);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
            opacity: 0.7;
            z-index: 10;
        }
        
        .copy-btn:hover {
            opacity: 1;
            background: var(--primary-dark);
            transform: translateY(-1px);
        }
        
        .copy-btn.copied {
            background: var(--success);
        }
        
        pre:hover .copy-btn {
            opacity: 1;
        }
        
        /* Inline Code */
        code { 
            background: var(--bg-code);
            color: #8b5cf6;
            padding: 3px 8px; 
            border-radius: 6px; 
            font-size: 1.1em;
            font-family: 'Fira Code', 'Consolas', monospace;
            border: 1px solid var(--border);
        }
        
        /* Headings */
        h1, h2, h3, h4, h5, h6 { 
            color: var(--text-primary);
            margin: 2rem 0 1rem 0;
            font-weight: 700;
            letter-spacing: -0.5px;
        }
        
        h1 { 
            font-size: 2.5rem;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            border-bottom: 3px solid var(--primary);
            padding-bottom: 12px;
            margin-bottom: 1.5rem;
        }
        
        h2 { 
            font-size: 2rem;
            color: var(--primary);
            border-bottom: 2px solid var(--border);
            padding-bottom: 8px;
        }
        
        h3 { 
            font-size: 1.5rem;
            color: var(--accent);
        }
        
        /* Links */
        a { 
            color: var(--accent);
            transition: color 0.2s;
        }
        
        a:hover { 
            color: var(--primary);
        }
        
        /* Paragraphs */
        p {
            margin: 1rem 0;
            color: var(--text-secondary);
        }
        
        /* Lists */
        ul, ol {
            margin: 1rem 0;
            padding-left: 2rem;
            color: var(--text-secondary);
        }
        
        li {
            margin: 0.5rem 0;
        }
        
        /* Tables */
        table { 
            border-collapse: collapse;
            width: 100%;
            margin: 1.5rem 0;
            background: var(--bg-main);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        
        th, td { 
            border: 1px solid var(--border);
            padding: 12px 16px;
            text-align: left;
        }
        
        th { 
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            font-weight: 600;
        }
        
        tr:hover {
            background: var(--bg-card);
        }
        
        /* Blockquotes */
        blockquote {
            border-left: 4px solid var(--primary);
            padding: 1rem 1.5rem;
            margin: 1.5rem 0;
            background: var(--bg-main);
            border-radius: 0 8px 8px 0;
            color: var(--text-secondary);
            font-style: italic;
        }
        
        /* Horizontal Rule */
        hr {
            border: none;
            border-top: 2px solid var(--border);
            margin: 2rem 0;
        }
        
        .footer { 
            text-align: center; 
            padding: 2rem; 
            color: var(--text-secondary);
            border-top: 1px solid var(--border);
            margin-top: 3rem; 
            font-size: 14px;
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--bg-main);
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 6px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary);
        }
        
        @media (max-width: 768px) {
            .container { padding: 10px; }
            .file-list { grid-template-columns: 1fr; }
            .content { padding: 1.5rem; }
            h1 { font-size: 2rem; }
            h2 { font-size: 1.5rem; }
        }
    </style>
</head>
<body>
    <a href="../index.html" class="home-btn">üè†</a>
    <div class="container">
        <div class="breadcrumb">
            <div style="padding: 0 20px;">
                <a href="../index.html">üè† Home</a> <span style="color: #64748b;">/</span> <a href="index.html">04_TypeScript_Integration</a>
            </div>
        </div>
        <div class="content">
            <h1 id="chapter-22-advanced-typescript-patterns-in-react">Chapter 22: Advanced TypeScript Patterns in React</h1>
<h2 id="discriminated-unions-for-props">Discriminated Unions for Props</h2>
<h2 id="learning-objective">Learning Objective</h2>
<p>Use discriminated unions to create components that accept different, mutually exclusive sets of props based on the value of a single "discriminant" prop.</p>
<h2 id="why-this-matters">Why This Matters</h2>
<p>Components often have multiple "modes" or "variants." A naive approach might use a series of optional props, but this can lead to impossible or invalid combinations. A discriminated union creates a type-safe contract that ensures only valid prop combinations are possible, catching bugs at compile time and making the component's API much clearer.</p>
<h2 id="discovery-phase">Discovery Phase</h2>
<p>Let's build a <code>StatusDisplay</code> component. It needs to show one of three states: loading, success, or error. Each state requires different data.</p>
<p>A naive approach might look like this:</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// The flawed, non-discriminated approach</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">StatusDisplayProps_Flawed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">status</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;loading&#39;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s1">&#39;success&#39;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s1">&#39;error&#39;</span><span class="p">;</span>
<span class="w">  </span><span class="nx">data</span><span class="o">?:</span><span class="w"> </span><span class="nx">string</span><span class="p">;</span><span class="w"> </span><span class="c1">// Only for success</span>
<span class="w">  </span><span class="nx">errorMessage</span><span class="o">?:</span><span class="w"> </span><span class="nx">string</span><span class="p">;</span><span class="w"> </span><span class="c1">// Only for error</span>
<span class="p">};</span>

<span class="c1">// What if someone passes `data` when status is &#39;error&#39;?</span>
<span class="c1">// &lt;StatusDisplay status=&quot;error&quot; data=&quot;some data&quot; /&gt; // This is allowed, but nonsensical.</span>
</code></pre></div>

<p>This is risky because nothing prevents a developer from passing contradictory props. A discriminated union solves this by tying the other props' existence to the value of the <code>status</code> prop.</p>
<div class="codehilite"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;react&#39;</span><span class="p">;</span>

<span class="c1">// Step 1: Define the individual types for each state.</span>
<span class="c1">// The `status` property is the &quot;discriminant&quot;.</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">LoadingState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">status</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;loading&#39;</span><span class="w"> </span><span class="p">};</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">SuccessState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">status</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;success&#39;</span><span class="p">;</span><span class="w"> </span><span class="nx">data</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="w"> </span><span class="p">};</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">ErrorState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">status</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;error&#39;</span><span class="p">;</span><span class="w"> </span><span class="nx">errorMessage</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="w"> </span><span class="p">};</span>

<span class="c1">// Step 2: Create a union of the state types.</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">StatusDisplayProps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">LoadingState</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">SuccessState</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">ErrorState</span><span class="p">;</span>

<span class="c1">// Step 3: Use the union type in the component.</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">StatusDisplay</span><span class="p">(</span><span class="nx">props</span><span class="o">:</span><span class="w"> </span><span class="nx">StatusDisplayProps</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// TypeScript&#39;s control flow analysis (narrowing) is key here.</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="nx">props</span><span class="p">.</span><span class="nx">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="s1">&#39;loading&#39;</span><span class="o">:</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span><span class="nx">Loading</span><span class="p">...&lt;/</span><span class="nt">div</span><span class="p">&gt;;</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="s1">&#39;success&#39;</span><span class="o">:</span>
<span class="w">      </span><span class="c1">// Inside this block, TS knows `props` is of type `SuccessState`.</span>
<span class="w">      </span><span class="c1">// Accessing `props.data` is safe.</span>
<span class="w">      </span><span class="c1">// Accessing `props.errorMessage` would be a compile-time error.</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span><span class="nx">Success</span><span class="o">!</span><span class="w"> </span><span class="nx">Data</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="nx">props</span><span class="p">.</span><span class="nx">data</span><span class="p">}&lt;/</span><span class="nt">div</span><span class="p">&gt;;</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="s1">&#39;error&#39;</span><span class="o">:</span>
<span class="w">      </span><span class="c1">// Inside this block, TS knows `props` is of type `ErrorState`.</span>
<span class="w">      </span><span class="c1">// Accessing `props.errorMessage` is safe.</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span><span class="ne">Error</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="nx">props</span><span class="p">.</span><span class="nx">errorMessage</span><span class="p">}&lt;/</span><span class="nt">div</span><span class="p">&gt;;</span>
<span class="w">    </span><span class="k">default</span><span class="o">:</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">export</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">App</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">StatusDisplay</span><span class="w"> </span><span class="na">status</span><span class="o">=</span><span class="s">&quot;loading&quot;</span><span class="w"> </span><span class="p">/&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">StatusDisplay</span><span class="w"> </span><span class="na">status</span><span class="o">=</span><span class="s">&quot;success&quot;</span><span class="w"> </span><span class="na">data</span><span class="o">=</span><span class="s">&quot;User data loaded!&quot;</span><span class="w"> </span><span class="p">/&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">StatusDisplay</span><span class="w"> </span><span class="na">status</span><span class="o">=</span><span class="s">&quot;error&quot;</span><span class="w"> </span><span class="na">errorMessage</span><span class="o">=</span><span class="s">&quot;Failed to fetch.&quot;</span><span class="w"> </span><span class="p">/&gt;</span>
<span class="w">      </span><span class="p">{</span><span class="cm">/* &lt;StatusDisplay status=&quot;success&quot; errorMessage=&quot;This is an error!&quot; /&gt; */</span><span class="p">}</span>
<span class="w">      </span><span class="p">{</span><span class="cm">/* The line above causes a TypeScript error because `errorMessage`</span>
<span class="cm">          is not a valid prop when `status` is &#39;success&#39;. */</span><span class="p">}</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>Rendered Output</strong>:</p>
<div class="codehilite"><pre><span></span><code><span class="n">Loading</span><span class="o">...</span>
<span class="n">Success</span><span class="o">!</span><span class="w"> </span><span class="n">Data</span><span class="p">:</span><span class="w"> </span><span class="n">User</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">loaded</span><span class="o">!</span>
<span class="n">Error</span><span class="p">:</span><span class="w"> </span><span class="n">Failed</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">fetch</span><span class="o">.</span>
</code></pre></div>

<p>By checking the <code>status</code> prop, TypeScript is smart enough to "narrow" the type of <code>props</code> within each <code>case</code> block. This makes it impossible to access a prop that doesn't belong to the current state, providing perfect type safety.</p>
<h2 id="deep-dive">Deep Dive</h2>
<h3 id="the-three-elements-of-a-discriminated-union">The Three Elements of a Discriminated Union</h3>
<p>For this pattern to work, you need three things:</p>
<ol>
<li><strong>A Discriminant Property</strong>: A property that is present on every type in the union, which has a literal type (e.g., <code>'loading'</code>, <code>'success'</code>). <code>status</code> is our discriminant.</li>
<li><strong>A Union of Types</strong>: An outer type that is a union of all the possible state shapes (<code>StatusDisplayProps</code>).</li>
<li><strong>Type Narrowing</strong>: Code that checks the discriminant property (like a <code>switch</code> statement or <code>if/else</code> chain), which allows TypeScript to infer the specific type within that block.</li>
</ol>
<h3 id="example-polymorphic-button">Example: Polymorphic Button</h3>
<p>This pattern is extremely powerful for creating components with distinct behaviors. Consider a <code>Button</code> that can either be a standard button with an <code>onClick</code> handler, or a link with an <code>href</code>. It should never be both.</p>
<div class="codehilite"><pre><span></span><code><span class="nx">type</span><span class="w"> </span><span class="nx">ButtonAsButton</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kr">as</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;button&#39;</span><span class="p">;</span>
<span class="w">  </span><span class="nx">onClick</span><span class="o">:</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ow">void</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// `href` is not allowed here</span>
<span class="p">};</span>

<span class="nx">type</span><span class="w"> </span><span class="nx">ButtonAsLink</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kr">as</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;a&#39;</span><span class="p">;</span>
<span class="w">  </span><span class="nx">href</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// `onClick` is not allowed here</span>
<span class="p">};</span>

<span class="nx">type</span><span class="w"> </span><span class="nx">ButtonProps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">ButtonAsButton</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">ButtonAsLink</span><span class="p">;</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">Button</span><span class="p">(</span><span class="nx">props</span><span class="o">:</span><span class="w"> </span><span class="nx">ButtonProps</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">props</span><span class="p">.</span><span class="kr">as</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;a&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// TS knows `props` is `ButtonAsLink`, so `props.href` is safe.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">a</span><span class="w"> </span><span class="na">href</span><span class="o">=</span><span class="p">{</span><span class="nx">props</span><span class="p">.</span><span class="nx">href</span><span class="p">}&gt;...&lt;/</span><span class="nt">a</span><span class="p">&gt;;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// TS knows `props` must be `ButtonAsButton`.</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">button</span><span class="w"> </span><span class="na">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">props</span><span class="p">.</span><span class="nx">onClick</span><span class="p">}&gt;...&lt;/</span><span class="nt">button</span><span class="p">&gt;;</span>
<span class="p">}</span>
</code></pre></div>

<p>Here, the <code>as</code> prop is the discriminant, ensuring that you provide either <code>href</code> or <code>onClick</code>, but never a mix of the two.</p>
<h3 id="common-confusion-why-not-just-check-for-the-props-existence">Common Confusion: "Why not just check for the prop's existence?"</h3>
<p><strong>You might think</strong>: "Instead of a <code>status</code> prop, I could just check <code>if (props.data)</code> to know it's a success state."</p>
<p><strong>Actually</strong>: This is less reliable and less explicit. What if the success data is <code>0</code> or an empty string <code>''</code>? These are "falsy" values, and <code>if (props.data)</code> would fail, leading to bugs. The discriminant provides a clear, unambiguous signal of the component's intended state.</p>
<p><strong>Why the confusion happens</strong>: Checking for truthiness is a common JavaScript idiom.</p>
<p><strong>How to remember</strong>: A discriminated union creates a <em>contract</em>. The discriminant prop is the explicit term of that contract that tells the component which mode it's in. Relying on the presence of other data props is implicit and brittle.</p>
<h3 id="production-perspective">Production Perspective</h3>
<ul>
<li><strong>API Clarity</strong>: This pattern makes your component's API self-documenting. It's immediately clear to consumers that the component has different, mutually exclusive modes of operation.</li>
<li><strong>State Machine Modeling</strong>: Discriminated unions are the perfect way to model state machines in TypeScript. The <code>status</code> prop represents the current state, and the union defines all possible states and their associated data.</li>
<li><strong>Reducing Complexity</strong>: By preventing impossible prop combinations, you reduce the number of edge cases you need to handle inside your component, making the implementation simpler and more robust.</li>
</ul>
<h2 id="polymorphic-components">Polymorphic Components</h2>
<h2 id="learning-objective_1">Learning Objective</h2>
<p>Understand the concept of polymorphic components‚Äîcomponents that can render as different underlying HTML elements or other React components.</p>
<h2 id="why-this-matters_1">Why This Matters</h2>
<p>In a mature design system, you want foundational components like <code>Box</code>, <code>Text</code>, or <code>Button</code> to be flexible. A <code>Text</code> component shouldn't be hardcoded to always render a <code>&lt;p&gt;</code> tag. You might need it to be an <code>&lt;h1&gt;</code>, a <code>&lt;span&gt;</code>, or a <code>&lt;strong&gt;</code>. Polymorphism allows you to build these flexible components while preserving the type safety of the underlying element's props.</p>
<h2 id="discovery-phase_1">Discovery Phase</h2>
<p>Let's start with a basic, non-polymorphic <code>Text</code> component.</p>
<div class="codehilite"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;react&#39;</span><span class="p">;</span>

<span class="nx">type</span><span class="w"> </span><span class="nx">TextProps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">children</span><span class="o">:</span><span class="w"> </span><span class="nx">React</span><span class="p">.</span><span class="nx">ReactNode</span><span class="p">;</span>
<span class="w">  </span><span class="nx">color</span><span class="o">?:</span><span class="w"> </span><span class="s1">&#39;primary&#39;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s1">&#39;secondary&#39;</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// This component is not polymorphic. It ALWAYS renders a `&lt;p&gt;` tag.</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">Text</span><span class="p">({</span><span class="w"> </span><span class="nx">children</span><span class="p">,</span><span class="w"> </span><span class="nx">color</span><span class="w"> </span><span class="p">}</span><span class="o">:</span><span class="w"> </span><span class="nx">TextProps</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">style</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">color</span><span class="o">:</span><span class="w"> </span><span class="nx">color</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;primary&#39;</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s1">&#39;blue&#39;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;black&#39;</span><span class="p">,</span>
<span class="w">  </span><span class="p">};</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">p</span><span class="w"> </span><span class="na">style</span><span class="o">=</span><span class="p">{</span><span class="nx">style</span><span class="p">}&gt;{</span><span class="nx">children</span><span class="p">}&lt;/</span><span class="nt">p</span><span class="p">&gt;;</span>
<span class="p">}</span>

<span class="c1">// What if we want this to be a heading? We can&#39;t.</span>
<span class="c1">// What if we want to pass a `className`? We&#39;d have to add it to `TextProps`.</span>
</code></pre></div>

<p>This is rigid. To make it polymorphic, we need to allow the consumer to specify what element it should render as. This introduces two challenges:</p>
<ol>
<li>How do we tell the component which element to render? (The "as prop" pattern, which we'll cover next).</li>
<li>How do we make TypeScript understand that if it renders as an <code>&lt;a&gt;</code> tag, it should accept an <code>href</code> prop, and if it renders as a <code>&lt;button&gt;</code>, it should accept a <code>disabled</code> prop?</li>
</ol>
<p>The answer to the second question lies in generics and a special type from React: <code>React.ElementType</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;react&#39;</span><span class="p">;</span>

<span class="c1">// `React.ElementType` represents any valid thing that can be a component&#39;s type:</span>
<span class="c1">// - A string like &#39;div&#39;, &#39;p&#39;, &#39;a&#39;</span>
<span class="c1">// - A React component function or class</span>

<span class="c1">// Let&#39;s define the props for a generic, polymorphic component.</span>
<span class="c1">// We introduce a generic type `C` that must be a valid element type.</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">PolymorphicProps</span><span class="o">&lt;</span><span class="nx">C</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nx">React</span><span class="p">.</span><span class="nx">ElementType</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kr">as</span><span class="o">?:</span><span class="w"> </span><span class="nx">C</span><span class="p">;</span><span class="w"> </span><span class="c1">// The component to render as.</span>
<span class="w">  </span><span class="nx">children</span><span class="o">:</span><span class="w"> </span><span class="nx">React</span><span class="p">.</span><span class="nx">ReactNode</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// We&#39;ll add more props in the next section...</span>
<span class="p">};</span>

<span class="c1">// The component function itself is also generic.</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">PolymorphicComponent</span><span class="o">&lt;</span><span class="nx">C</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nx">React</span><span class="p">.</span><span class="nx">ElementType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;span&#39;</span><span class="o">&gt;</span><span class="p">({</span>
<span class="w">  </span><span class="kr">as</span><span class="p">,</span>
<span class="w">  </span><span class="nx">children</span><span class="p">,</span>
<span class="w">  </span><span class="p">...</span><span class="nx">restProps</span>
<span class="p">}</span><span class="o">:</span><span class="w"> </span><span class="nx">PolymorphicProps</span><span class="o">&lt;</span><span class="nx">C</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// If an `as` prop is provided, we use it. Otherwise, we default to &#39;span&#39;.</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">Component</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="s1">&#39;span&#39;</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// We can render the `Component` and spread the rest of the props onto it.</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="o">&lt;</span><span class="nx">Component</span><span class="w"> </span><span class="p">{...</span><span class="nx">restProps</span><span class="p">}</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">children</span><span class="p">}</span><span class="o">&lt;</span><span class="err">/Component&gt;;</span>
<span class="p">}</span>
</code></pre></div>

<p>This is the conceptual foundation. We've created a component that can accept an <code>as</code> prop and will render that element. The generic <code>C extends React.ElementType</code> is the key piece of TypeScript magic that makes this possible.</p>
<p>However, we're still missing a crucial part: how do we type <code>...restProps</code> so that it correctly represents the props of the <code>Component</code> we're rendering? That's what we'll solve in the next section.</p>
<h2 id="deep-dive_1">Deep Dive</h2>
<h3 id="the-building-blocks-of-polymorphism">The Building Blocks of Polymorphism</h3>
<p>To create a fully-typed polymorphic component, we need to combine our own custom props with the props of the element being rendered. The full type is a bit complex, so let's build it up.</p>
<ol>
<li><strong>Our Component's Props</strong>: These are the props specific to our component, like <code>color</code> in our <code>Text</code> example.</li>
<li><strong>The <code>as</code> Prop</strong>: The prop that determines the rendered element, typed as <code>C extends React.ElementType</code>.</li>
<li><strong>The Underlying Element's Props</strong>: We need to get all the valid props for the element <code>C</code>. React and TypeScript give us a utility for this: <code>React.ComponentPropsWithoutRef&lt;C&gt;</code>. This utility type takes a component or tag name <code>C</code> and returns a type representing all of its props, excluding the <code>ref</code> prop (which is handled specially).</li>
</ol>
<p>The final props type will be an intersection of our props and the underlying element's props, while making sure we don't have collisions.</p>
<h3 id="common-confusion-whats-the-difference-between-reactelementtype-and-reactreactnode">Common Confusion: "What's the difference between <code>React.ElementType</code> and <code>React.ReactNode</code>?"</h3>
<p><strong>You might think</strong>: "They both seem to be about 'React things'."</p>
<p><strong>Actually</strong>: They represent very different concepts.</p>
<ul>
<li><code>React.ReactNode</code>: Represents something that can be <strong>rendered</strong>. It's the <em>output</em> of a component. It's what goes inside JSX, like <code>&lt;p&gt;Hello&lt;/p&gt;</code> or a string. This is what you use for the <code>children</code> prop.</li>
<li><code>React.ElementType</code>: Represents the <strong>type</strong> of a component. It's the <em>thing you render</em>. It's what goes in the tag position, like <code>p</code> in <code>&lt;p /&gt;</code> or <code>MyComponent</code> in <code>&lt;MyComponent /&gt;</code>. This is what you use for the <code>as</code> prop.</li>
</ul>
<p><strong>Why the confusion happens</strong>: The names are abstract and sound similar.</p>
<p><strong>How to remember</strong>: <code>Node</code> is a piece of the rendered output tree. <code>Type</code> is the type of element you are creating.</p>
<h3 id="production-perspective_1">Production Perspective</h3>
<ul>
<li><strong>Design System Primitives</strong>: Polymorphism is the cornerstone of modern design system libraries (like Chakra UI, Radix, Material UI). It's used to create highly reusable primitive components like <code>Box</code>, <code>Flex</code>, <code>Grid</code>, and <code>Text</code> that provide a consistent API for layout and styling, regardless of the underlying semantic element.</li>
<li><strong>Avoiding Prop Bloat</strong>: Without polymorphism, you'd have to add every possible HTML attribute (<code>className</code>, <code>id</code>, <code>aria-label</code>, etc.) to every component's props. Polymorphism automatically makes all the standard attributes of the rendered element available in a type-safe way.</li>
</ul>
<h2 id="as-prop-pattern">As Prop Pattern</h2>
<h2 id="learning-objective_2">Learning Objective</h2>
<p>Implement the "as prop" pattern to build fully-typed, reusable polymorphic components.</p>
<h2 id="why-this-matters_2">Why This Matters</h2>
<p>The "as prop" is the standard, community-accepted convention for implementing polymorphic components. Mastering this pattern allows you to build flexible, professional-grade components that are a joy to use, as they provide full type safety and autocompletion for the underlying element's props.</p>
<h2 id="discovery-phase_2">Discovery Phase</h2>
<p>Let's build a fully-typed <code>Heading</code> component that can render as any heading level (<code>h1</code> through <code>h6</code>) using the <code>as</code> prop.</p>
<div class="codehilite"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;react&#39;</span><span class="p">;</span>

<span class="c1">// Step 1: Define the component&#39;s own specific props.</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">HeadingOwnProps</span><span class="p">&lt;</span><span class="nt">C</span><span class="w"> </span><span class="na">extends</span><span class="w"> </span><span class="na">React.ElementType</span><span class="p">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kr">as</span><span class="o">?:</span><span class="w"> </span><span class="nx">C</span><span class="p">;</span>
<span class="w">  </span><span class="nx">children</span><span class="o">:</span><span class="w"> </span><span class="nx">React</span><span class="p">.</span><span class="nx">ReactNode</span><span class="p">;</span>
<span class="w">  </span><span class="nx">color</span><span class="o">?:</span><span class="w"> </span><span class="s1">&#39;primary&#39;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s1">&#39;secondary&#39;</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Step 2: Create the final, combined props type.</span>
<span class="c1">// This is the core of the pattern.</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">HeadingProps</span><span class="p">&lt;</span><span class="nt">C</span><span class="w"> </span><span class="na">extends</span><span class="w"> </span><span class="na">React.ElementType</span><span class="p">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">HeadingOwnProps</span><span class="p">&lt;</span><span class="nt">C</span><span class="p">&gt;</span><span class="w"> </span><span class="o">&amp;</span>
<span class="w">  </span><span class="c1">// Omit our own props from the underlying element&#39;s props to avoid collisions.</span>
<span class="w">  </span><span class="nx">Omit</span><span class="p">&lt;</span><span class="nt">React</span><span class="p">.</span><span class="na">ComponentPropsWithoutRef</span><span class="err">&lt;</span><span class="na">C</span><span class="p">&gt;,</span><span class="w"> </span><span class="nx">keyof</span><span class="w"> </span><span class="nx">HeadingOwnProps</span><span class="p">&lt;</span><span class="nt">C</span><span class="p">&gt;</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">// Step 3: Create the generic component.</span>
<span class="c1">// We can set a default element type, e.g., &#39;h2&#39;.</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">Heading</span><span class="p">&lt;</span><span class="nt">C</span><span class="w"> </span><span class="na">extends</span><span class="w"> </span><span class="na">React.ElementType</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">&#39;</span><span class="na">h2</span><span class="err">&#39;</span><span class="p">&gt;({</span>
<span class="w">  </span><span class="kr">as</span><span class="p">,</span>
<span class="w">  </span><span class="nx">children</span><span class="p">,</span>
<span class="w">  </span><span class="nx">color</span><span class="p">,</span>
<span class="w">  </span><span class="p">...</span><span class="nx">restProps</span>
<span class="p">}</span><span class="o">:</span><span class="w"> </span><span class="nx">HeadingProps</span><span class="p">&lt;</span><span class="nt">C</span><span class="p">&gt;)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">Component</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="s1">&#39;h2&#39;</span><span class="p">;</span>

<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">style</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">color</span><span class="o">:</span><span class="w"> </span><span class="nx">color</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;primary&#39;</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s1">&#39;purple&#39;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;inherit&#39;</span><span class="p">,</span>
<span class="w">  </span><span class="p">};</span>

<span class="w">  </span><span class="c1">// `restProps` is now correctly typed with the props of `Component`.</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">Component</span><span class="w"> </span><span class="na">style</span><span class="o">=</span><span class="p">{</span><span class="nx">style</span><span class="p">}</span><span class="w"> </span><span class="p">{</span><span class="na">...restProps</span><span class="p">}&gt;</span>
<span class="w">      </span><span class="p">{</span><span class="nx">children</span><span class="p">}</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">Component</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// --- USAGE ---</span>
<span class="k">export</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">App</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">{</span><span class="cm">/* Renders an &lt;h2&gt; by default */</span><span class="p">}</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">Heading</span><span class="w"> </span><span class="na">color</span><span class="o">=</span><span class="s">&quot;primary&quot;</span><span class="p">&gt;</span><span class="nx">Default</span><span class="w"> </span><span class="nx">Heading</span><span class="w"> </span><span class="p">(</span><span class="nx">h2</span><span class="p">)&lt;/</span><span class="nt">Heading</span><span class="p">&gt;</span>

<span class="w">      </span><span class="p">{</span><span class="cm">/* Renders an &lt;h1&gt; */</span><span class="p">}</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">Heading</span><span class="w"> </span><span class="na">as</span><span class="o">=</span><span class="s">&quot;h1&quot;</span><span class="p">&gt;</span><span class="nx">Main</span><span class="w"> </span><span class="nx">Heading</span><span class="w"> </span><span class="p">(</span><span class="nx">h1</span><span class="p">)&lt;/</span><span class="nt">Heading</span><span class="p">&gt;</span>

<span class="w">      </span><span class="p">{</span><span class="cm">/* Renders as an anchor tag `&lt;a&gt;` and accepts `href`! */</span><span class="p">}</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">Heading</span><span class="w"> </span><span class="na">as</span><span class="o">=</span><span class="s">&quot;a&quot;</span><span class="w"> </span><span class="na">href</span><span class="o">=</span><span class="s">&quot;https://react.dev&quot;</span><span class="p">&gt;</span>
<span class="w">        </span><span class="nx">Link</span><span class="w"> </span><span class="nx">Heading</span><span class="w"> </span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
<span class="w">      </span><span class="p">&lt;/</span><span class="nt">Heading</span><span class="p">&gt;</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>Rendered Output</strong>:</p>
<div class="codehilite"><pre><span></span><code><span class="p">&lt;</span><span class="nt">h2</span> <span class="na">style</span><span class="o">=</span><span class="s">&quot;color: purple;&quot;</span><span class="p">&gt;</span>Default Heading (h2)<span class="p">&lt;/</span><span class="nt">h2</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">h1</span> <span class="na">style</span><span class="o">=</span><span class="s">&quot;color: inherit;&quot;</span><span class="p">&gt;</span>Main Heading (h1)<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&quot;https://react.dev&quot;</span> <span class="na">style</span><span class="o">=</span><span class="s">&quot;color: inherit;&quot;</span><span class="p">&gt;</span>Link Heading (a)<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
</code></pre></div>

<p>When you use this component in a TypeScript environment, you'll see that when you type <code>&lt;Heading as="a" ...</code>, your editor will autocomplete the <code>href</code> prop. If you use <code>&lt;Heading as="h1" ...</code>, it won't. This is the pattern in action!</p>
<h2 id="deep-dive_2">Deep Dive</h2>
<h3 id="deconstructing-the-headingprops-type">Deconstructing the <code>HeadingProps</code> Type</h3>
<p>The props type is the most complex part. Let's break it down.
<code>type HeadingProps&lt;C extends React.ElementType&gt; = HeadingOwnProps&lt;C&gt; &amp; Omit&lt;React.ComponentPropsWithoutRef&lt;C&gt;, keyof HeadingOwnProps&lt;C&gt;&gt;</code></p>
<ul>
<li><strong><code>HeadingOwnProps&lt;C&gt;</code></strong>: These are our custom props (<code>as</code>, <code>children</code>, <code>color</code>). We make this generic so it can include the <code>as?: C</code> prop.</li>
<li><strong><code>&amp;</code></strong>: This is an intersection. We are combining our own props with the props of the underlying element.</li>
<li><strong><code>React.ComponentPropsWithoutRef&lt;C&gt;</code></strong>: This gets all the props for the element <code>C</code> (e.g., all props for <code>HTMLAnchorElement</code> if <code>C</code> is <code>'a'</code>).</li>
<li><strong><code>Omit&lt;..., keyof HeadingOwnProps&lt;C&gt;&gt;</code></strong>: This is a crucial step. It removes any of our custom prop names from the underlying element's props. This prevents conflicts. For example, if we had a prop named <code>style</code> and the underlying element also has a <code>style</code> prop, this <code>Omit</code> ensures our version takes precedence.</li>
</ul>
<h3 id="the-component-signature">The Component Signature</h3>
<p><code>function Heading&lt;C extends React.ElementType = 'h2'&gt;({ ... }: HeadingProps&lt;C&gt;)</code></p>
<ul>
<li><strong><code>&lt;C extends React.ElementType = 'h2'&gt;</code></strong>: This makes the component function itself generic. We also provide a default type for <code>C</code>. If the consumer doesn't provide an <code>as</code> prop, <code>C</code> will be <code>'h2'</code>, and the component will render an <code>h2</code> by default.</li>
</ul>
<h3 id="production-perspective_2">Production Perspective</h3>
<ul>
<li><strong>Design System Foundation</strong>: This pattern is the workhorse of modern component libraries. Use it for any component that acts as a foundational building block for your UI, especially layout and typography primitives.</li>
<li><strong>Accessibility</strong>: Polymorphism is a powerful accessibility tool. It allows you to build a component with consistent styling (e.g., a <code>Button</code>) but render it as the most semantically appropriate element for the context (e.g., an <code>&lt;a&gt;</code> if it navigates, or a <code>&lt;button&gt;</code> if it performs an action).</li>
<li><strong>Complexity Trade-off</strong>: This pattern is powerful but adds complexity to your type definitions. For a simple, one-off component that will only ever be a <code>div</code>, it's overkill. Reserve it for components that are intended to be highly reusable and flexible.</li>
</ul>
<h2 id="conditional-types-in-components">Conditional Types in Components</h2>
<h2 id="learning-objective_3">Learning Objective</h2>
<p>Use conditional types (<code>T extends U ? X : Y</code>) to create component props where the type of one prop depends on the value of another.</p>
<h2 id="why-this-matters_3">Why This Matters</h2>
<p>Sometimes, a component's behavior changes so dramatically based on a prop that other props need to change their types as well. Conditional types allow you to model these complex relationships, creating "smart" components that guide the developer toward correct usage and prevent logical errors.</p>
<h2 id="discovery-phase_3">Discovery Phase</h2>
<p>Let's build an <code>Input</code> component. If we pass <code>type="checkbox"</code>, the <code>value</code> should be a <code>boolean</code>. But if we pass <code>type="text"</code>, the <code>value</code> should be a <code>string</code>. A simple props definition can't handle this.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// Flawed approach - `value` is a loose union type</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">InputProps_Flawed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">type</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;text&#39;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s1">&#39;checkbox&#39;</span><span class="p">;</span>
<span class="w">  </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kr">boolean</span><span class="p">;</span><span class="w"> </span><span class="c1">// How do we know which it is?</span>
<span class="w">  </span><span class="nx">onChange</span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kr">boolean</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ow">void</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// This allows invalid combinations:</span>
<span class="c1">// &lt;Input type=&quot;text&quot; value={true} ... /&gt;</span>
</code></pre></div>

<p>This is unsafe. We can use a conditional type to link the <code>value</code> type to the <code>type</code> prop's value.</p>
<div class="codehilite"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;react&#39;</span><span class="p">;</span>

<span class="c1">// Step 1: Use a generic `T` for the `type` prop.</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">InputProps</span><span class="p">&lt;</span><span class="nt">T</span><span class="w"> </span><span class="na">extends</span><span class="w"> </span><span class="err">&#39;</span><span class="na">text</span><span class="err">&#39;</span><span class="w"> </span><span class="err">|</span><span class="w"> </span><span class="err">&#39;</span><span class="na">checkbox</span><span class="err">&#39;</span><span class="p">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">type</span><span class="o">:</span><span class="w"> </span><span class="nx">T</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// Step 2: Define `value` using a conditional type.</span>
<span class="w">  </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="nx">T</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="s1">&#39;checkbox&#39;</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="kr">boolean</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// Step 3: Do the same for the `onChange` callback.</span>
<span class="w">  </span><span class="nx">onChange</span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="nx">T</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="s1">&#39;checkbox&#39;</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="kr">boolean</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ow">void</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// The component itself is generic.</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">Input</span><span class="p">&lt;</span><span class="nt">T</span><span class="w"> </span><span class="na">extends</span><span class="w"> </span><span class="err">&#39;</span><span class="na">text</span><span class="err">&#39;</span><span class="w"> </span><span class="err">|</span><span class="w"> </span><span class="err">&#39;</span><span class="na">checkbox</span><span class="err">&#39;</span><span class="p">&gt;(</span><span class="nx">props</span><span class="o">:</span><span class="w"> </span><span class="nx">InputProps</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">type</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="p">,</span><span class="w"> </span><span class="nx">onChange</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">props</span><span class="p">;</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">type</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;checkbox&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Because of the conditional type, TS knows `value` is a boolean here</span>
<span class="w">    </span><span class="c1">// and `onChange` expects a boolean.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">input</span>
<span class="w">        </span><span class="na">type</span><span class="o">=</span><span class="s">&quot;checkbox&quot;</span>
<span class="w">        </span><span class="na">checked</span><span class="o">=</span><span class="p">{</span><span class="nx">value</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="kr">boolean</span><span class="p">}</span>
<span class="w">        </span><span class="na">onChange</span><span class="o">=</span><span class="p">{(</span><span class="nx">e</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">onChange</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">checked</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="nx">InputProps</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;[</span><span class="s1">&#39;value&#39;</span><span class="p">])}</span>
<span class="w">      </span><span class="p">/&gt;</span>
<span class="w">    </span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Here, TS knows `value` is a string and `onChange` expects a string.</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">input</span>
<span class="w">      </span><span class="na">type</span><span class="o">=</span><span class="s">&quot;text&quot;</span>
<span class="w">      </span><span class="na">value</span><span class="o">=</span><span class="p">{</span><span class="nx">value</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="nx">string</span><span class="p">}</span>
<span class="w">      </span><span class="na">onChange</span><span class="o">=</span><span class="p">{(</span><span class="nx">e</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">onChange</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="nx">InputProps</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;[</span><span class="s1">&#39;value&#39;</span><span class="p">])}</span>
<span class="w">    </span><span class="p">/&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// --- USAGE ---</span>
<span class="k">export</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">App</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">text</span><span class="p">,</span><span class="w"> </span><span class="nx">setText</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">React</span><span class="p">.</span><span class="nx">useState</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">);</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">checked</span><span class="p">,</span><span class="w"> </span><span class="nx">setChecked</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">React</span><span class="p">.</span><span class="nx">useState</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">Input</span><span class="w"> </span><span class="na">type</span><span class="o">=</span><span class="s">&quot;text&quot;</span><span class="w"> </span><span class="na">value</span><span class="o">=</span><span class="p">{</span><span class="nx">text</span><span class="p">}</span><span class="w"> </span><span class="na">onChange</span><span class="o">=</span><span class="p">{</span><span class="nx">setText</span><span class="p">}</span><span class="w"> </span><span class="p">/&gt;</span>
<span class="w">      </span><span class="p">{</span><span class="cm">/* `onChange` correctly expects a string. Passing `setChecked` would be an error. */</span><span class="p">}</span>

<span class="w">      </span><span class="p">&lt;</span><span class="nt">Input</span><span class="w"> </span><span class="na">type</span><span class="o">=</span><span class="s">&quot;checkbox&quot;</span><span class="w"> </span><span class="na">value</span><span class="o">=</span><span class="p">{</span><span class="nx">checked</span><span class="p">}</span><span class="w"> </span><span class="na">onChange</span><span class="o">=</span><span class="p">{</span><span class="nx">setChecked</span><span class="p">}</span><span class="w"> </span><span class="p">/&gt;</span>
<span class="w">      </span><span class="p">{</span><span class="cm">/* `onChange` correctly expects a boolean. Passing `setText` would be an error. */</span><span class="p">}</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>Interactive Behavior</strong>:
A text input pre-filled with "hello" and a checked checkbox are displayed. They are both fully functional and type-safe.</p>
<p>The core of this pattern is the conditional type:
<code>T extends 'checkbox' ? boolean : string</code></p>
<p>This reads as: "If the generic type <code>T</code> is <code>'checkbox'</code>, then this type is <code>boolean</code>. Otherwise, it is <code>string</code>." By making our <code>InputProps</code> and <code>Input</code> component generic over <code>T</code>, we link the types of <code>value</code> and <code>onChange</code> directly to the literal value passed to the <code>type</code> prop.</p>
<h2 id="deep-dive_3">Deep Dive</h2>
<h3 id="combining-with-discriminated-unions">Combining with Discriminated Unions</h3>
<p>For more complex cases, you can combine conditional types with discriminated unions for maximum clarity and safety. This often leads to more readable code than a complex generic type.</p>
<div class="codehilite"><pre><span></span><code><span class="nx">type</span><span class="w"> </span><span class="nx">TextInputProps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">type</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;text&#39;</span><span class="p">;</span>
<span class="w">  </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">;</span>
<span class="w">  </span><span class="nx">onChange</span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ow">void</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">type</span><span class="w"> </span><span class="nx">CheckboxInputProps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">type</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;checkbox&#39;</span><span class="p">;</span>
<span class="w">  </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="kr">boolean</span><span class="p">;</span>
<span class="w">  </span><span class="nx">onChange</span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="kr">boolean</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ow">void</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">type</span><span class="w"> </span><span class="nx">BetterInputProps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">TextInputProps</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">CheckboxInputProps</span><span class="p">;</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">BetterInput</span><span class="p">(</span><span class="nx">props</span><span class="o">:</span><span class="w"> </span><span class="nx">BetterInputProps</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">props</span><span class="p">.</span><span class="nx">type</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;checkbox&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// TS narrows `props` to `CheckboxInputProps`.</span>
<span class="w">    </span><span class="c1">// `props.value` is a boolean.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">&lt;</span><span class="nx">input</span><span class="w"> </span><span class="nx">type</span><span class="o">=</span><span class="s2">&quot;checkbox&quot;</span><span class="w"> </span><span class="nx">checked</span><span class="o">=</span><span class="p">{</span><span class="nx">props</span><span class="p">.</span><span class="nx">value</span><span class="p">}</span><span class="w"> </span><span class="nx">onChange</span><span class="o">=</span><span class="p">{</span><span class="nx">e</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">props</span><span class="p">.</span><span class="nx">onChange</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">checked</span><span class="p">)}</span><span class="w"> </span><span class="o">/&gt;</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// TS narrows `props` to `TextInputProps`.</span>
<span class="w">  </span><span class="c1">// `props.value` is a string.</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="o">&lt;</span><span class="nx">input</span><span class="w"> </span><span class="nx">type</span><span class="o">=</span><span class="s2">&quot;text&quot;</span><span class="w"> </span><span class="nx">value</span><span class="o">=</span><span class="p">{</span><span class="nx">props</span><span class="p">.</span><span class="nx">value</span><span class="p">}</span><span class="w"> </span><span class="nx">onChange</span><span class="o">=</span><span class="p">{</span><span class="nx">e</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">props</span><span class="p">.</span><span class="nx">onChange</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span><span class="p">)}</span><span class="w"> </span><span class="o">/&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>This discriminated union approach achieves the same type safety as the conditional type example but can be easier to read and extend. The choice between them is often a matter of style and complexity. Conditional types shine when the relationship is more complex or involves many properties.</p>
<h3 id="production-perspective_3">Production Perspective</h3>
<ul>
<li><strong>Highly Dynamic Components</strong>: Use conditional types for components where the fundamental data type it operates on changes based on a prop. This is common in form libraries, data visualization components, or any component that wraps native HTML elements with varied behaviors.</li>
<li><strong>Improving Developer Experience (DX)</strong>: The main benefit is for the consumer of your component. They get immediate feedback if they provide an invalid combination of props. For example, <code>&lt;Input type="text" value={true} ... /&gt;</code> would be an instant error.</li>
<li><strong>Readability vs. Power</strong>: Conditional types are an advanced feature. While powerful, they can make your type definitions harder to understand at a glance. Always consider if a simpler pattern, like a discriminated union, can achieve the same goal with more readable code.</li>
</ul>
<h2 id="template-literal-types">Template Literal Types</h2>
<h2 id="learning-objective_4">Learning Objective</h2>
<p>Use template literal types to create precise and expressive string literal types, often for styling and layout props in a design system.</p>
<h2 id="why-this-matters_4">Why This Matters</h2>
<p>In a design system, you want to enforce consistency. Instead of allowing any string for a <code>margin</code> prop, you can use template literal types to restrict it to a combination of a direction, a size from your theme, and a unit. This provides powerful autocompletion and prevents developers from using "magic numbers" or inconsistent values.</p>
<h2 id="discovery-phase_4">Discovery Phase</h2>
<p>Let's build a <code>Box</code> component that should accept spacing props based on a predefined theme. We want props like <code>padding="md"</code> or <code>margin-top="lg"</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// Our design system&#39;s theme</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">theme</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">spacing</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">sm</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;0.5rem&#39;</span><span class="p">,</span>
<span class="w">    </span><span class="nx">md</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;1rem&#39;</span><span class="p">,</span>
<span class="w">    </span><span class="nx">lg</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;2rem&#39;</span><span class="p">,</span>
<span class="w">  </span><span class="p">},</span>
<span class="p">};</span>

<span class="c1">// Define types based on the theme</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">Space</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">keyof</span><span class="w"> </span><span class="ow">typeof</span><span class="w"> </span><span class="nx">theme</span><span class="p">.</span><span class="nx">spacing</span><span class="p">;</span><span class="w"> </span><span class="c1">// &#39;sm&#39; | &#39;md&#39; | &#39;lg&#39;</span>

<span class="c1">// Now, let&#39;s define our prop types using template literals</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">MarginProperty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;margin&#39;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s1">&#39;margin-top&#39;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s1">&#39;margin-bottom&#39;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s1">&#39;margin-left&#39;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s1">&#39;margin-right&#39;</span><span class="p">;</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">PaddingProperty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;padding&#39;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s1">&#39;padding-top&#39;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s1">&#39;padding-bottom&#39;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s1">&#39;padding-left&#39;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s1">&#39;padding-right&#39;</span><span class="p">;</span>

<span class="c1">// Example of a template literal type</span>
<span class="c1">// This creates a union of strings like &quot;margin-sm&quot;, &quot;margin-top-lg&quot;, etc.</span>
<span class="c1">// This is not what we want for props, but shows the concept.</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">SpacingClass</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sb">`</span><span class="si">${</span><span class="nx">MarginProperty</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">PaddingProperty</span><span class="si">}</span><span class="sb">-</span><span class="si">${</span><span class="nx">Space</span><span class="si">}</span><span class="sb">`</span><span class="p">;</span>

<span class="c1">// A better way for props is to use mapped types, which we&#39;ll see next.</span>
<span class="c1">// For now, let&#39;s create a simpler version for a single prop.</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">BoxProps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">children</span><span class="o">:</span><span class="w"> </span><span class="nx">React</span><span class="p">.</span><span class="nx">ReactNode</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// A prop that accepts a size from our theme</span>
<span class="w">    </span><span class="nx">padding</span><span class="o">?:</span><span class="w"> </span><span class="nx">Space</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>This is a good start, but template literals truly shine when combined with other types to generate a large set of possibilities. Let's define types for CSS properties that can take our themed spacing.</p>
<div class="codehilite"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;react&#39;</span><span class="p">;</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">theme</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">spacing</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">sm</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;0.5rem&#39;</span><span class="p">,</span>
<span class="w">    </span><span class="nx">md</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;1rem&#39;</span><span class="p">,</span>
<span class="w">    </span><span class="nx">lg</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;2rem&#39;</span><span class="p">,</span>
<span class="w">  </span><span class="p">},</span>
<span class="p">};</span>

<span class="nx">type</span><span class="w"> </span><span class="nx">Space</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">keyof</span><span class="w"> </span><span class="ow">typeof</span><span class="w"> </span><span class="nx">theme</span><span class="p">.</span><span class="nx">spacing</span><span class="p">;</span><span class="w"> </span><span class="c1">// &#39;sm&#39; | &#39;md&#39; | &#39;lg&#39;</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">Direction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;top&#39;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s1">&#39;bottom&#39;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s1">&#39;left&#39;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s1">&#39;right&#39;</span><span class="p">;</span>

<span class="c1">// Template literal type to generate margin property names</span>
<span class="c1">// Creates: &#39;marginTop&#39; | &#39;marginBottom&#39; | &#39;marginLeft&#39; | &#39;marginRight&#39;</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">MarginDirectional</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sb">`margin</span><span class="si">${</span><span class="nx">Capitalize</span><span class="p">&lt;</span><span class="nt">Direction</span><span class="p">&gt;</span><span class="si">}</span><span class="sb">`</span><span class="p">;</span>

<span class="c1">// Use a Mapped Type (see next section) to create the props</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">BoxProps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">children</span><span class="o">:</span><span class="w"> </span><span class="nx">React</span><span class="p">.</span><span class="nx">ReactNode</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// For each property like &#39;marginTop&#39;, its value can be one of our space keys</span>
<span class="w">  </span><span class="p">[</span><span class="nx">Property</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nx">MarginDirectional</span><span class="p">]</span><span class="o">?:</span><span class="w"> </span><span class="nx">Space</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">Box</span><span class="p">({</span><span class="w"> </span><span class="nx">children</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="nx">styleProps</span><span class="w"> </span><span class="p">}</span><span class="o">:</span><span class="w"> </span><span class="nx">BoxProps</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">style</span><span class="o">:</span><span class="w"> </span><span class="nx">React</span><span class="p">.</span><span class="nx">CSSProperties</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>

<span class="w">  </span><span class="c1">// A simple loop to transform our props into CSS</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">key</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="p">]</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">styleProps</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">key</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nx">styleMappings</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kd">const</span><span class="w"> </span><span class="nx">cssProperty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">styleMappings</span><span class="p">[</span><span class="nx">key</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="nx">keyof</span><span class="w"> </span><span class="ow">typeof</span><span class="w"> </span><span class="nx">styleMappings</span><span class="p">];</span>
<span class="w">      </span><span class="nx">style</span><span class="p">[</span><span class="nx">cssProperty</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">theme</span><span class="p">.</span><span class="nx">spacing</span><span class="p">[</span><span class="nx">value</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="nx">Space</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">div</span><span class="w"> </span><span class="na">style</span><span class="o">=</span><span class="p">{</span><span class="nx">style</span><span class="p">}&gt;{</span><span class="nx">children</span><span class="p">}&lt;/</span><span class="nt">div</span><span class="p">&gt;;</span>
<span class="p">}</span>

<span class="c1">// Helper to map prop names to CSS property names</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">styleMappings</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">marginTop</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;marginTop&#39;</span><span class="p">,</span>
<span class="w">  </span><span class="nx">marginBottom</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;marginBottom&#39;</span><span class="p">,</span>
<span class="w">  </span><span class="nx">marginLeft</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;marginLeft&#39;</span><span class="p">,</span>
<span class="w">  </span><span class="nx">marginRight</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;marginRight&#39;</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// --- USAGE ---</span>
<span class="k">export</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">App</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">Box</span><span class="w"> </span><span class="na">marginTop</span><span class="o">=</span><span class="s">&quot;lg&quot;</span><span class="w"> </span><span class="na">marginLeft</span><span class="o">=</span><span class="s">&quot;sm&quot;</span><span class="p">&gt;</span>
<span class="w">      </span><span class="nx">I</span><span class="w"> </span><span class="nx">am</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="nx">box</span><span class="w"> </span><span class="kd">with</span><span class="w"> </span><span class="nx">themed</span><span class="w"> </span><span class="nx">spacing</span><span class="o">!</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">Box</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>Rendered Output</strong>:</p>
<div class="codehilite"><pre><span></span><code><span class="p">&lt;</span><span class="nt">div</span> <span class="na">style</span><span class="o">=</span><span class="s">&quot;margin-top: 2rem; margin-left: 0.5rem;&quot;</span><span class="p">&gt;</span>
  I am a box with themed spacing!
<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
</code></pre></div>

<p>Here, we used <code></code>margin${Capitalize<Direction>}<code></code> to programmatically generate the type <code>'marginTop' | 'marginBottom' | ...</code>. This creates a type-safe API for our <code>Box</code> component. A developer using it gets autocompletion for <code>marginTop</code>, and if they provide a value, they get autocompletion for <code>'sm'</code>, <code>'md'</code>, and <code>'lg'</code>.</p>
<h2 id="deep-dive_4">Deep Dive</h2>
<h3 id="combining-unions-in-template-literals">Combining Unions in Template Literals</h3>
<p>Template literals can expand unions of unions, creating a Cartesian product of all possible strings.</p>
<div class="codehilite"><pre><span></span><code><span class="kr">type</span><span class="w"> </span><span class="nx">Size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;small&quot;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s2">&quot;large&quot;</span><span class="p">;</span>
<span class="kr">type</span><span class="w"> </span><span class="nx">Color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;blue&quot;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s2">&quot;red&quot;</span><span class="p">;</span>
<span class="kr">type</span><span class="w"> </span><span class="nx">Variant</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sb">`</span><span class="si">${</span><span class="nx">Size</span><span class="si">}</span><span class="sb">-</span><span class="si">${</span><span class="nx">Color</span><span class="si">}</span><span class="sb">`</span><span class="p">;</span>
<span class="c1">// `Variant` is &#39;small-blue&#39; | &#39;small-red&#39; | &#39;large-blue&#39; | &#39;large-red&#39;</span>
</code></pre></div>

<p>This is extremely powerful for generating types for component variants, class names, or any string-based API that follows a consistent pattern.</p>
<h3 id="intrinsic-string-manipulation-types">Intrinsic String Manipulation Types</h3>
<p>TypeScript provides several utility types for manipulating strings at the type level, which are often used with template literals:</p>
<ul>
<li><code>Capitalize&lt;T&gt;</code>: Converts the first character to uppercase.</li>
<li><code>Uncapitalize&lt;T&gt;</code>: Converts the first character to lowercase.</li>
<li><code>Uppercase&lt;T&gt;</code>: Converts the whole string to uppercase.</li>
<li><code>Lowercase&lt;T&gt;</code>: Converts the whole string to lowercase.</li>
</ul>
<p>We used <code>Capitalize</code> in our example to convert <code>'top'</code> to <code>'Top'</code> to create <code>'marginTop'</code>.</p>
<h3 id="production-perspective_4">Production Perspective</h3>
<ul>
<li><strong>CSS-in-JS Libraries</strong>: This is the core mechanism behind modern type-safe CSS-in-JS libraries like Panda CSS, Stitches, and the styling engines in frameworks like Chakra UI. They use template literals and mapped types to generate thousands of type-safe style props based on your theme file.</li>
<li><strong>Enforcing Design Tokens</strong>: This pattern is the ultimate way to enforce the use of a design system's tokens (colors, spacing, fonts). It makes it easy for developers to do the right thing (use a theme value) and hard to do the wrong thing (use a magic number).</li>
<li><strong>Type Generation, Not Runtime Logic</strong>: Remember that all of this happens at the type level. It has zero runtime performance cost. It's purely a tool to improve the developer experience and prevent bugs during development.</li>
</ul>
<h2 id="mapped-types-for-dynamic-props">Mapped Types for Dynamic Props</h2>
<h2 id="learning-objective_5">Learning Objective</h2>
<p>Use mapped types to programmatically create new object types from unions or existing object keys, enabling dynamic and DRY prop definitions.</p>
<h2 id="why-this-matters_5">Why This Matters</h2>
<p>As your application and component library grow, you'll notice patterns in your prop types. You might have several components that all need a set of <code>margin</code> props, or you might want to create boolean variant props like <code>isPrimary</code> and <code>isSecondary</code>. Mapped types allow you to define this logic once and reuse it, keeping your types consistent and maintainable.</p>
<h2 id="discovery-phase_5">Discovery Phase</h2>
<p>Let's build a <code>Button</code> component that can have several boolean variant props, like <code>primary</code>, <code>secondary</code>, or <code>danger</code>.</p>
<p>A naive implementation would define them manually:</p>
<div class="codehilite"><pre><span></span><code><span class="nx">type</span><span class="w"> </span><span class="nx">ButtonProps_Flawed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">primary</span><span class="o">?:</span><span class="w"> </span><span class="kr">boolean</span><span class="p">;</span>
<span class="w">  </span><span class="nx">secondary</span><span class="o">?:</span><span class="w"> </span><span class="kr">boolean</span><span class="p">;</span>
<span class="w">  </span><span class="nx">danger</span><span class="o">?:</span><span class="w"> </span><span class="kr">boolean</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// What if we add a &#39;warning&#39; variant? We have to update this manually.</span>
<span class="p">};</span>
</code></pre></div>

<p>This is not scalable. If we add a new variant, we have to remember to update this type. A mapped type lets us generate these props from a single source of truth.</p>
<div class="codehilite"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;react&#39;</span><span class="p">;</span>

<span class="c1">// Step 1: Define the single source of truth for our variants.</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">ButtonVariant</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;primary&#39;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s1">&#39;secondary&#39;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s1">&#39;danger&#39;</span><span class="p">;</span>

<span class="c1">// Step 2: Use a mapped type to generate the boolean props.</span>
<span class="c1">// This reads: &quot;For each key `V` in `ButtonVariant`, create a property</span>
<span class="c1">// where the key is `V` and the value is an optional boolean.&quot;</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">VariantProps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">[</span><span class="nx">V</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nx">ButtonVariant</span><span class="p">]</span><span class="o">?:</span><span class="w"> </span><span class="kr">boolean</span><span class="p">;</span>
<span class="p">};</span>
<span class="cm">/*</span>
<span class="cm">  This generates the following type:</span>
<span class="cm">  {</span>
<span class="cm">    primary?: boolean;</span>
<span class="cm">    secondary?: boolean;</span>
<span class="cm">    danger?: boolean;</span>
<span class="cm">  }</span>
<span class="cm">*/</span>

<span class="nx">type</span><span class="w"> </span><span class="nx">ButtonProps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">VariantProps</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">children</span><span class="o">:</span><span class="w"> </span><span class="nx">React</span><span class="p">.</span><span class="nx">ReactNode</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">Button</span><span class="p">({</span><span class="w"> </span><span class="nx">children</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="nx">variantProps</span><span class="w"> </span><span class="p">}</span><span class="o">:</span><span class="w"> </span><span class="nx">ButtonProps</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="nx">backgroundColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;grey&#39;</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">variantProps</span><span class="p">.</span><span class="nx">primary</span><span class="p">)</span><span class="w"> </span><span class="nx">backgroundColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;blue&#39;</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">variantProps</span><span class="p">.</span><span class="nx">secondary</span><span class="p">)</span><span class="w"> </span><span class="nx">backgroundColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;green&#39;</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">variantProps</span><span class="p">.</span><span class="nx">danger</span><span class="p">)</span><span class="w"> </span><span class="nx">backgroundColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;red&#39;</span><span class="p">;</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">button</span><span class="w"> </span><span class="na">style</span><span class="o">=</span><span class="p">{{</span><span class="w"> </span><span class="nx">backgroundColor</span><span class="p">,</span><span class="w"> </span><span class="nx">color</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;white&#39;</span><span class="w"> </span><span class="p">}}&gt;{</span><span class="nx">children</span><span class="p">}&lt;/</span><span class="nt">button</span><span class="p">&gt;;</span>
<span class="p">}</span>

<span class="c1">// --- USAGE ---</span>
<span class="k">export</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">App</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">div</span><span class="w"> </span><span class="na">style</span><span class="o">=</span><span class="p">{{</span><span class="w"> </span><span class="nx">display</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;flex&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">gap</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;10px&#39;</span><span class="w"> </span><span class="p">}}&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">Button</span><span class="w"> </span><span class="na">primary</span><span class="p">&gt;</span><span class="nx">Primary</span><span class="p">&lt;/</span><span class="nt">Button</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">Button</span><span class="w"> </span><span class="na">secondary</span><span class="p">&gt;</span><span class="nx">Secondary</span><span class="p">&lt;/</span><span class="nt">Button</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">Button</span><span class="w"> </span><span class="na">danger</span><span class="p">&gt;</span><span class="nx">Danger</span><span class="p">&lt;/</span><span class="nt">Button</span><span class="p">&gt;</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>Rendered Output</strong>:</p>
<div class="codehilite"><pre><span></span><code><span class="k">[Primary] [Secondary] [Danger]</span>
<span class="na">(Three buttons with blue, green, and red backgrounds respectively.)</span>
</code></pre></div>

<p>Now, if we want to add a <code>'warning'</code> variant, we only need to change one line:
<code>type ButtonVariant = 'primary' | 'secondary' | 'danger' | 'warning';</code>
The <code>VariantProps</code> type will automatically update to include <code>warning?: boolean</code>. This is the power of DRY (Don't Repeat Yourself) for types.</p>
<h2 id="deep-dive_5">Deep Dive</h2>
<h3 id="the-mapped-type-syntax">The Mapped Type Syntax</h3>
<p>The syntax <code>[K in KeyType]: ValueType</code> is the core of mapped types. Let's break it down:</p>
<ul>
<li><strong><code>K</code></strong>: A variable that represents the key in each iteration. You can name it anything.</li>
<li><strong><code>in</code></strong>: The keyword that iterates over a union of keys.</li>
<li><strong><code>KeyType</code></strong>: A union of string or number literals (e.g., <code>'primary' | 'secondary'</code>) or an object type whose keys we want to use (via <code>keyof T</code>).</li>
<li><strong><code>ValueType</code></strong>: The type of the value for each property. This can be a fixed type or can be computed based on <code>K</code>.</li>
</ul>
<h3 id="mapping-modifiers">Mapping Modifiers</h3>
<p>You can add modifiers to control optionality (<code>?</code>) and writability (<code>readonly</code>).</p>
<div class="codehilite"><pre><span></span><code><span class="kr">type</span><span class="w"> </span><span class="nx">MyType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Make all properties readonly</span>
<span class="w">  </span><span class="k">readonly</span><span class="w"> </span><span class="p">[</span><span class="nx">K</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="s2">&quot;a&quot;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s2">&quot;b&quot;</span><span class="p">]</span><span class="o">:</span><span class="w"> </span><span class="nx">K</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// { readonly a: &#39;a&#39;; readonly b: &#39;b&#39;; }</span>

<span class="kr">type</span><span class="w"> </span><span class="nx">MyPartial</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Make all properties of T optional</span>
<span class="w">  </span><span class="p">[</span><span class="nx">K</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nx">keyof</span><span class="w"> </span><span class="nx">T</span><span class="p">]</span><span class="nx">?</span><span class="o">:</span><span class="w"> </span><span class="kt">T</span><span class="p">[</span><span class="nx">K</span><span class="p">];</span>
<span class="p">};</span>
<span class="c1">// This is how the built-in `Partial&lt;T&gt;` utility type is implemented!</span>
</code></pre></div>

<h3 id="key-remapping-with-as">Key Remapping with <code>as</code></h3>
<p>You can even change the names of the keys as you map them. This is often combined with template literal types.</p>
<div class="codehilite"><pre><span></span><code><span class="nx">type</span><span class="w"> </span><span class="nx">Events</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;click&#39;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s1">&#39;focus&#39;</span><span class="p">;</span>

<span class="c1">// Let&#39;s create a props type for event handlers: `onClick`, `onFocus`</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">EventProps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// For each event `E` in `Events`, create a key `on${Capitalize&lt;E&gt;}`</span>
<span class="w">  </span><span class="p">[</span><span class="nx">E</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nx">Events</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="sb">`on</span><span class="si">${</span><span class="nx">Capitalize</span><span class="o">&lt;</span><span class="nx">E</span><span class="o">&gt;</span><span class="si">}</span><span class="sb">`</span><span class="p">]</span><span class="o">?:</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ow">void</span><span class="p">;</span>
<span class="p">};</span>
<span class="cm">/*</span>
<span class="cm">  Generates:</span>
<span class="cm">  {</span>
<span class="cm">    onClick?: () =&gt; void;</span>
<span class="cm">    onFocus?: () =&gt; void;</span>
<span class="cm">  }</span>
<span class="cm">*/</span>
</code></pre></div>

<p>This advanced pattern allows you to generate entire APIs programmatically from a simple union of strings, which is incredibly powerful for building consistent and maintainable libraries.</p>
<h3 id="production-perspective_5">Production Perspective</h3>
<ul>
<li><strong>Single Source of Truth</strong>: Mapped types are essential for maintaining a single source of truth. Define your core concepts (like variants, sizes, colors) as simple union types, and then use mapped types to generate the complex prop types needed by your components.</li>
<li><strong>Utility Types</strong>: Many of TypeScript's built-in utility types (<code>Partial</code>, <code>Required</code>, <code>Readonly</code>, <code>Pick</code>, <code>Record</code>) are implemented using mapped types. Understanding mapped types helps you understand how these utilities work and even create your own custom utility types.</li>
<li><strong>Code Generation at the Type Level</strong>: Think of mapped types as a form of code generation that happens entirely within the type system. It lets you write more abstract and maintainable types that expand into the concrete definitions your components need.</li>
</ul>
<h2 id="type-guards-and-narrowing">Type Guards and Narrowing</h2>
<h2 id="learning-objective_6">Learning Objective</h2>
<p>Write custom type guard functions to narrow down union types in complex scenarios where TypeScript's built-in analysis is not sufficient.</p>
<h2 id="why-this-matters_6">Why This Matters</h2>
<p>TypeScript's ability to narrow types in <code>if</code> and <code>switch</code> blocks is powerful, but it's based on simple checks (<code>typeof</code>, <code>instanceof</code>, property existence). Sometimes, your logic for determining a type is more complex. A custom type guard is a function you write that performs this complex check and explicitly tells the compiler, "If this function returns true, you can safely assume the variable is of this more specific type."</p>
<h2 id="discovery-phase_6">Discovery Phase</h2>
<p>Imagine we're fetching a list of <code>Media</code> items from an API. Some are <code>Video</code>s and some are <code>Image</code>s, and they have different properties.</p>
<div class="codehilite"><pre><span></span><code><span class="nx">type</span><span class="w"> </span><span class="nx">Image</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;image&#39;</span><span class="p">;</span>
<span class="w">  </span><span class="nx">src</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">;</span>
<span class="w">  </span><span class="nx">alt</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">type</span><span class="w"> </span><span class="nx">Video</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;video&#39;</span><span class="p">;</span>
<span class="w">  </span><span class="nx">source</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">format</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;mp4&#39;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s1">&#39;webm&#39;</span><span class="p">;</span><span class="w"> </span><span class="nx">url</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="w"> </span><span class="p">};</span>
<span class="w">  </span><span class="nx">title</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">type</span><span class="w"> </span><span class="nx">Media</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">Image</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">Video</span><span class="p">;</span>

<span class="c1">// Let&#39;s write a function to get the primary URL for any media item.</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">getMediaUrl</span><span class="p">(</span><span class="nx">media</span><span class="o">:</span><span class="w"> </span><span class="nx">Media</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// TypeScript knows `media` is either Image or Video here.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">media</span><span class="p">.</span><span class="nx">kind</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;image&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// This is standard narrowing. TS knows `media` is `Image`.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">media</span><span class="p">.</span><span class="nx">src</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// And here it knows `media` is `Video`.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">media</span><span class="p">.</span><span class="nx">source</span><span class="p">.</span><span class="nx">url</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>This works great because we have a simple discriminant property, <code>kind</code>. But what if the data structure is less clean? What if we only have <code>src</code> for images and <code>source</code> for videos?</p>
<div class="codehilite"><pre><span></span><code><span class="nx">type</span><span class="w"> </span><span class="nx">ImageWithNoKind</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">src</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">;</span><span class="w"> </span><span class="nx">alt</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="w"> </span><span class="p">};</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">VideoWithNoKind</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">source</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">url</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="nx">title</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="w"> </span><span class="p">};</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">MediaWithNoKind</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">ImageWithNoKind</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">VideoWithNoKind</span><span class="p">;</span>

<span class="c1">// Now, let&#39;s create a custom type guard function.</span>
<span class="c1">// The special return type `media is ImageWithNoKind` is the &quot;type predicate&quot;.</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">isImage</span><span class="p">(</span><span class="nx">media</span><span class="o">:</span><span class="w"> </span><span class="nx">MediaWithNoKind</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="nx">media</span><span class="w"> </span><span class="nx">is</span><span class="w"> </span><span class="nx">ImageWithNoKind</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Our custom logic: if it has an `src` property, it&#39;s an image.</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="s1">&#39;src&#39;</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nx">media</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">MediaDisplay</span><span class="p">({</span><span class="w"> </span><span class="nx">media</span><span class="w"> </span><span class="p">}</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">media</span><span class="o">:</span><span class="w"> </span><span class="nx">MediaWithNoKind</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// We use our type guard in an `if` statement.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">isImage</span><span class="p">(</span><span class="nx">media</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Because `isImage` returned true, TypeScript narrows `media`</span>
<span class="w">    </span><span class="c1">// to `ImageWithNoKind` inside this block.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">img</span><span class="w"> </span><span class="na">src</span><span class="o">=</span><span class="p">{</span><span class="nx">media</span><span class="p">.</span><span class="nx">src</span><span class="p">}</span><span class="w"> </span><span class="na">alt</span><span class="o">=</span><span class="p">{</span><span class="nx">media</span><span class="p">.</span><span class="nx">alt</span><span class="p">}</span><span class="w"> </span><span class="p">/&gt;;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Outside the `if` block, TS knows `media` must be `VideoWithNoKind`.</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">video</span><span class="w"> </span><span class="na">src</span><span class="o">=</span><span class="p">{</span><span class="nx">media</span><span class="p">.</span><span class="nx">source</span><span class="p">.</span><span class="nx">url</span><span class="p">}</span><span class="w"> </span><span class="na">title</span><span class="o">=</span><span class="p">{</span><span class="nx">media</span><span class="p">.</span><span class="nx">title</span><span class="p">}</span><span class="w"> </span><span class="p">/&gt;;</span>
<span class="p">}</span>
</code></pre></div>

<p>The function <code>isImage</code> is a custom type guard. Its special return type, <code>media is ImageWithNoKind</code>, is called a type predicate. It doesn't just return a boolean; it makes a type assertion to the compiler. This allows us to encapsulate complex checking logic into a reusable function that aids TypeScript's narrowing process.</p>
<h2 id="deep-dive_6">Deep Dive</h2>
<h3 id="the-type-predicate">The Type Predicate</h3>
<p>The syntax <code>argumentName is Type</code> is the key to a type guard.</p>
<ul>
<li><code>argumentName</code> must be the name of one of the function's parameters.</li>
<li><code>Type</code> must be a more specific type than the parameter's original type.</li>
</ul>
<p>The function must return a boolean. If it returns <code>true</code>, TypeScript will narrow the type of the argument to <code>Type</code> in the calling scope.</p>
<h3 id="when-to-use-type-guards">When to Use Type Guards</h3>
<p>Use a custom type guard when TypeScript's built-in narrowing isn't sufficient. This often happens when:</p>
<ol>
<li><strong>The check is complex</strong>: The logic to differentiate types involves multiple properties or complex computations.</li>
<li><strong>You want to reuse the logic</strong>: The same type check is needed in multiple places. A type guard keeps your code DRY.</li>
<li><strong>You're working with external data</strong>: When data comes from an API, its shape might not be guaranteed. Type guards are a great way to validate and narrow the type of this data upon receipt.</li>
</ol>
<h3 id="production-perspective_6">Production Perspective</h3>
<ul>
<li><strong>Data Validation</strong>: Type guards are a form of runtime data validation that also informs the static type system. They are a bridge between the unpredictable runtime world (e.g., API responses) and the statically-typed world of your application.</li>
<li><strong>Assertion vs. Guard</strong>: A related concept is a "type assertion function," which throws an error if the type is not what's expected.
  <code>typescript
  function assertIsImage(media: Media): asserts media is Image {
    if (media.kind !== "image") throw new Error("Not an image!");
  }
  // After calling assertIsImage(myMedia), TS knows myMedia is an Image.</code>
  Use guards for control flow (<code>if/else</code>) and assertions when an invalid type is an exceptional, unrecoverable error.</li>
<li><strong>A Tool of Last Resort</strong>: Always try to use simpler narrowing techniques first (like discriminated unions). Custom type guards are powerful, but they place the responsibility of correctness on you. If your <code>isImage</code> function has a bug and returns <code>true</code> for a video, TypeScript will trust you, and you'll get a runtime error.</li>
</ul>
<h2 id="branded-types-for-domain-modeling">Branded Types for Domain Modeling</h2>
<h2 id="learning-objective_7">Learning Objective</h2>
<p>Use branded (or opaque) types to create distinct, non-interchangeable types for primitives like strings or numbers, preventing common domain logic errors.</p>
<h2 id="why-this-matters_7">Why This Matters</h2>
<p>In a large application, you might have many kinds of IDs: <code>UserID</code>, <code>ProductID</code>, <code>OrderID</code>. At the JavaScript level, these are all just strings or numbers. This makes it dangerously easy to mix them up, for example, by passing a <code>ProductID</code> to a function that fetches a user. Branded types solve this problem at the compile time, making such logical errors impossible.</p>
<h2 id="discovery-phase_7">Discovery Phase</h2>
<p>Let's see the problem in action with plain types.</p>
<div class="codehilite"><pre><span></span><code><span class="nx">type</span><span class="w"> </span><span class="nx">UserID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">string</span><span class="p">;</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">ProductID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">string</span><span class="p">;</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">getUser</span><span class="p">(</span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="nx">UserID</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`Fetching user with ID: </span><span class="si">${</span><span class="nx">id</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">getProduct</span><span class="p">(</span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="nx">ProductID</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`Fetching product with ID: </span><span class="si">${</span><span class="nx">id</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">myUserId</span><span class="o">:</span><span class="w"> </span><span class="nx">UserID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;user-123&#39;</span><span class="p">;</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">myProductId</span><span class="o">:</span><span class="w"> </span><span class="nx">ProductID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;prod-abc&#39;</span><span class="p">;</span>

<span class="c1">// The problem: TypeScript sees `UserID` and `ProductID` as just `string`.</span>
<span class="c1">// This is allowed, but it&#39;s a logical bug!</span>
<span class="nx">getUser</span><span class="p">(</span><span class="nx">myProductId</span><span class="p">);</span><span class="w"> </span><span class="c1">// Prints &quot;Fetching user with ID: prod-abc&quot;</span>
</code></pre></div>

<p><code>type UserID = string</code> is just a type alias. It doesn't create a new, distinct type. To solve this, we can use a "brand"‚Äîa unique, non-existent property that we intersect with the primitive type.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// Step 1: Define the branded types.</span>
<span class="c1">// We intersect `string` with an object that has a unique, private-like property.</span>
<span class="k">export</span><span class="w"> </span><span class="nx">type</span><span class="w"> </span><span class="nx">UserID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">string</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">readonly</span><span class="w"> </span><span class="nx">__brand</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;UserID&#39;</span><span class="w"> </span><span class="p">};</span>
<span class="k">export</span><span class="w"> </span><span class="nx">type</span><span class="w"> </span><span class="nx">ProductID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">string</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">readonly</span><span class="w"> </span><span class="nx">__brand</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;ProductID&#39;</span><span class="w"> </span><span class="p">};</span>

<span class="c1">// Step 2: Create &quot;constructor&quot; functions to safely create branded types.</span>
<span class="c1">// These are type assertion functions.</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">asUserID</span><span class="p">(</span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="nx">UserID</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">id</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="nx">UserID</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">asProductID</span><span class="p">(</span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="nx">ProductID</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">id</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="nx">ProductID</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Step 3: Update our functions to use the branded types.</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">getUser</span><span class="p">(</span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="nx">UserID</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`Fetching user with ID: </span><span class="si">${</span><span class="nx">id</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
<span class="p">}</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">getProduct</span><span class="p">(</span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="nx">ProductID</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`Fetching product with ID: </span><span class="si">${</span><span class="nx">id</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Step 4: Create instances using our constructors.</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">myUserId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">asUserID</span><span class="p">(</span><span class="s1">&#39;user-123&#39;</span><span class="p">);</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">myProductId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">asProductID</span><span class="p">(</span><span class="s1">&#39;prod-abc&#39;</span><span class="p">);</span>

<span class="c1">// Now, the logical bug is a compile-time error!</span>
<span class="c1">// getUser(myProductId);</span>
<span class="c1">// Error: Argument of type &#39;ProductID&#39; is not assignable to parameter of type &#39;UserID&#39;.</span>
<span class="c1">//        Type &#39;ProductID&#39; is not assignable to type &#39;{ readonly __brand: &quot;UserID&quot;; }&#39;.</span>

<span class="c1">// This still works correctly.</span>
<span class="nx">getUser</span><span class="p">(</span><span class="nx">myUserId</span><span class="p">);</span>
</code></pre></div>

<p>This pattern is incredibly effective.</p>
<ul>
<li>At runtime, <code>myUserId</code> is still just the string <code>'user-123'</code>. There is zero performance overhead.</li>
<li>At compile time, TypeScript sees <code>UserID</code> and <code>ProductID</code> as completely different and incompatible types because their <code>__brand</code> properties are different.</li>
</ul>
<h2 id="deep-dive_7">Deep Dive</h2>
<h3 id="how-the-brand-works">How the Brand Works</h3>
<p>The type <code>string &amp; { readonly __brand: 'UserID' }</code> is an intersection. It describes a value that is <em>both</em> a <code>string</code> and an object with that specific brand property. Of course, no such value can exist at runtime. But the type system doesn't know that. It uses this "impossible" type to create a unique "tag" or "brand" for our strings, allowing it to differentiate them.</p>
<p>The <code>as UserID</code> type assertion in our constructor function is where we tell the compiler, "Trust me, I know what I'm doing. This string should be treated as a <code>UserID</code> from now on."</p>
<h3 id="a-generic-brand-helper">A Generic Brand Helper</h3>
<p>You can create a generic helper type to make branding easier.</p>
<div class="codehilite"><pre><span></span><code><span class="nx">type</span><span class="w"> </span><span class="nx">Brand</span><span class="o">&lt;</span><span class="nx">K</span><span class="p">,</span><span class="w"> </span><span class="nx">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">K</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">readonly</span><span class="w"> </span><span class="nx">__brand</span><span class="o">:</span><span class="w"> </span><span class="nx">T</span><span class="w"> </span><span class="p">};</span>

<span class="c1">// Usage:</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">Email</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">Brand</span><span class="o">&lt;</span><span class="nx">string</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;Email&#39;</span><span class="o">&gt;</span><span class="p">;</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">CentAmount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">Brand</span><span class="o">&lt;</span><span class="nx">number</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;CentAmount&#39;</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">asEmail</span><span class="p">(</span><span class="nx">email</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="nx">Email</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Add validation logic here!</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nx">email</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="s1">&#39;@&#39;</span><span class="p">))</span><span class="w"> </span><span class="k">throw</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="ne">Error</span><span class="p">(</span><span class="s2">&quot;Invalid email&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">email</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="nx">Email</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">sendEmail</span><span class="p">(</span><span class="nx">to</span><span class="o">:</span><span class="w"> </span><span class="nx">Email</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* ... */</span><span class="w"> </span><span class="p">}</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">userEmail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">asEmail</span><span class="p">(</span><span class="s1">&#39;test@example.com&#39;</span><span class="p">);</span>
<span class="nx">sendEmail</span><span class="p">(</span><span class="nx">userEmail</span><span class="p">);</span><span class="w"> </span><span class="c1">// OK</span>

<span class="c1">// const invalidEmail = &#39;not-an-email&#39;;</span>
<span class="c1">// sendEmail(invalidEmail); // Compile-time error!</span>
</code></pre></div>

<p>This shows how branded types can be combined with validation logic in the constructor function to create highly secure and correct domain models.</p>
<h3 id="production-perspective_7">Production Perspective</h3>
<ul>
<li><strong>Domain-Driven Design</strong>: Branded types are a powerful tool for implementing Domain-Driven Design (DDD) in TypeScript. They allow you to create a rich, expressive type system that models your business domain and prevents invalid operations at the boundaries of your system.</li>
<li><strong>API Safety</strong>: Use branded types for any primitive value that has a specific meaning in your domain: IDs, emails, phone numbers, monetary amounts, etc. This is especially important in function signatures that form the public API of your modules.</li>
<li><strong>Boilerplate vs. Safety</strong>: The main drawback of this pattern is the boilerplate of creating the brand and the constructor function. This is a trade-off. For simple applications, it might be overkill. For large, complex systems where logical correctness is critical (e.g., financial tech, healthcare), the safety it provides is well worth the extra code.</li>
</ul>
<h2 id="module-synthesis">Module Synthesis üìã</h2>
<h2 id="module-synthesis_1">Module Synthesis</h2>
<p>In this chapter, we have ventured into the most advanced and powerful corners of TypeScript as applied to React. We've moved beyond typing simple props and state to crafting component APIs that are not just safe, but also flexible, expressive, and highly reusable.</p>
<p>We started with <strong>Discriminated Unions</strong>, a robust pattern for creating components with mutually exclusive modes, eliminating impossible prop combinations. We then laid the conceptual groundwork for <strong>Polymorphic Components</strong> before implementing the industry-standard <strong>"as prop" pattern</strong>, enabling us to build foundational design system components that can render as any HTML element while preserving type safety.</p>
<p>We explored how to model intricate prop dependencies with <strong>Conditional Types</strong>, creating "smart" components that adapt their types based on their props. We then saw how <strong>Template Literal Types</strong> and <strong>Mapped Types</strong> work together to programmatically generate entire sets of props from a single source of truth, keeping our design systems DRY and consistent.</p>
<p>Finally, we looked at two patterns for enhancing runtime correctness through the type system. <strong>Custom Type Guards</strong> allow us to give hints to the compiler in complex narrowing scenarios, while <strong>Branded Types</strong> provide a way to create distinct types for primitives, preventing critical domain logic errors.</p>
<h2 id="looking-ahead">Looking Ahead</h2>
<p>You are now equipped with the patterns used by professional developers to build world-class component libraries and design systems. You can create APIs that are not only safe but also provide an exceptional developer experience.</p>
<p>In the next chapter, <strong>Chapter 23: Typing Hooks and State</strong>, we will shift our focus inward. We'll take these advanced concepts and apply them to the internal logic of our components. We'll cover advanced patterns for typing <code>useState</code>, mastering the complex types of <code>useReducer</code>, ensuring type-safe global state with <code>useContext</code>, and creating fully-typed, reusable custom hooks.</p>
        </div>
        <div class="footer">
            Generated on 2025-10-25 16:27:48 | Made with ‚ù§Ô∏è by GitHub Pages Generator
        </div>
    </div>
    <script>
        // Syntax highlighting for code blocks
        document.addEventListener('DOMContentLoaded', (event) => {
            // Highlight code blocks
            document.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightElement(block);
            });
            
            // Add copy buttons to code blocks
            document.querySelectorAll('pre').forEach((pre) => {
                const button = document.createElement('button');
                button.className = 'copy-btn';
                button.textContent = 'Copy';
                
                button.addEventListener('click', () => {
                    const code = pre.querySelector('code').textContent;
                    navigator.clipboard.writeText(code).then(() => {
                        button.textContent = 'Copied!';
                        button.classList.add('copied');
                        setTimeout(() => {
                            button.textContent = 'Copy';
                            button.classList.remove('copied');
                        }, 2000);
                    }).catch(err => {
                        console.error('Failed to copy:', err);
                        button.textContent = 'Error';
                        setTimeout(() => {
                            button.textContent = 'Copy';
                        }, 2000);
                    });
                });
                
                pre.appendChild(button);
            });
        });
    </script>
</body>
</html>