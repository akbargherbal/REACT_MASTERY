<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>23_Typing_Hooks_and_State</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <style>
        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --secondary: #8b5cf6;
            --bg-main: #0f172a;
            --bg-card: #1e293b;
            --bg-code: #0f172a;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --border: #334155;
            --accent: #06b6d4;
            --success: #10b981;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            line-height: 1.7; 
            color: var(--text-primary); 
            background: var(--bg-main);
        }
        
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            padding: 20px; 
        }
        
        .home-btn { 
            position: fixed; 
            top: 20px; 
            right: 20px; 
            background: var(--accent);
            color: white; 
            width: 50px;
            height: 50px;
            border-radius: 50%;
            text-decoration: none; 
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(6, 182, 212, 0.4);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .home-btn:hover { 
            background: #0891b2;
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(6, 182, 212, 0.5);
        }
        
        .breadcrumb { 
            background: var(--bg-card);
            padding: 12px 0; 
            margin-bottom: 24px; 
            font-size: 14px;
            border-radius: 8px;
            border: 1px solid var(--border);
        }
        
        .breadcrumb a { 
            color: var(--accent);
            text-decoration: none;
            transition: color 0.2s;
        }
        
        .breadcrumb a:hover { 
            color: var(--primary);
            text-decoration: underline;
        }
        
        .content { 
            background: var(--bg-card);
            padding: 3rem; 
            border-radius: 16px; 
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border);
        }
        
        .file-list { 
            display: grid; 
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); 
            gap: 1.5rem; 
            margin: 2rem 0; 
        }
        
        .file-item { 
            padding: 1.5rem; 
            border: 1px solid var(--border);
            border-radius: 12px; 
            background: var(--bg-main);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .file-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .file-item:hover { 
            transform: translateY(-4px); 
            box-shadow: 0 8px 30px rgba(99, 102, 241, 0.3);
            border-color: var(--primary);
        }
        
        .file-item:hover::before {
            opacity: 1;
        }
        
        .file-item a { 
            color: var(--text-primary);
            text-decoration: none; 
            font-weight: 600; 
            display: block;
            font-size: 1.1rem;
        }
        
        .file-item a:hover { 
            color: var(--primary);
        }
        
        .file-type { 
            font-size: 13px; 
            color: var(--text-secondary);
            margin-top: 8px; 
            font-weight: 500;
        }
        
        /* Code Blocks */
        pre { 
            background: var(--bg-code);
            padding: 1.5rem; 
            border-radius: 12px; 
            overflow-x: auto;
            border: 1px solid var(--border);
            margin: 1.5rem 0;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            position: relative;
        }
        
        pre code { 
            background: none;
            padding: 0;
            font-family: 'Fira Code', 'Consolas', monospace;
            font-size: 0.9em;
            line-height: 1.6;
        }
        
        /* Copy Button */
        .copy-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: var(--primary);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
            opacity: 0.7;
            z-index: 10;
        }
        
        .copy-btn:hover {
            opacity: 1;
            background: var(--primary-dark);
            transform: translateY(-1px);
        }
        
        .copy-btn.copied {
            background: var(--success);
        }
        
        pre:hover .copy-btn {
            opacity: 1;
        }
        
        /* Inline Code */
        code { 
            background: var(--bg-code);
            color: #8b5cf6;
            padding: 3px 8px; 
            border-radius: 6px; 
            font-size: 1.1em;
            font-family: 'Fira Code', 'Consolas', monospace;
            border: 1px solid var(--border);
        }
        
        /* Headings */
        h1, h2, h3, h4, h5, h6 { 
            color: var(--text-primary);
            margin: 2rem 0 1rem 0;
            font-weight: 700;
            letter-spacing: -0.5px;
        }
        
        h1 { 
            font-size: 2.5rem;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            border-bottom: 3px solid var(--primary);
            padding-bottom: 12px;
            margin-bottom: 1.5rem;
        }
        
        h2 { 
            font-size: 2rem;
            color: var(--primary);
            border-bottom: 2px solid var(--border);
            padding-bottom: 8px;
        }
        
        h3 { 
            font-size: 1.5rem;
            color: var(--accent);
        }
        
        /* Links */
        a { 
            color: var(--accent);
            transition: color 0.2s;
        }
        
        a:hover { 
            color: var(--primary);
        }
        
        /* Paragraphs */
        p {
            margin: 1rem 0;
            color: var(--text-secondary);
        }
        
        /* Lists */
        ul, ol {
            margin: 1rem 0;
            padding-left: 2rem;
            color: var(--text-secondary);
        }
        
        li {
            margin: 0.5rem 0;
        }
        
        /* Tables */
        table { 
            border-collapse: collapse;
            width: 100%;
            margin: 1.5rem 0;
            background: var(--bg-main);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        
        th, td { 
            border: 1px solid var(--border);
            padding: 12px 16px;
            text-align: left;
        }
        
        th { 
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            font-weight: 600;
        }
        
        tr:hover {
            background: var(--bg-card);
        }
        
        /* Blockquotes */
        blockquote {
            border-left: 4px solid var(--primary);
            padding: 1rem 1.5rem;
            margin: 1.5rem 0;
            background: var(--bg-main);
            border-radius: 0 8px 8px 0;
            color: var(--text-secondary);
            font-style: italic;
        }
        
        /* Horizontal Rule */
        hr {
            border: none;
            border-top: 2px solid var(--border);
            margin: 2rem 0;
        }
        
        .footer { 
            text-align: center; 
            padding: 2rem; 
            color: var(--text-secondary);
            border-top: 1px solid var(--border);
            margin-top: 3rem; 
            font-size: 14px;
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--bg-main);
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 6px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary);
        }
        
        @media (max-width: 768px) {
            .container { padding: 10px; }
            .file-list { grid-template-columns: 1fr; }
            .content { padding: 1.5rem; }
            h1 { font-size: 2rem; }
            h2 { font-size: 1.5rem; }
        }
    </style>
</head>
<body>
    <a href="../index.html" class="home-btn">üè†</a>
    <div class="container">
        <div class="breadcrumb">
            <div style="padding: 0 20px;">
                <a href="../index.html">üè† Home</a> <span style="color: #64748b;">/</span> <a href="index.html">04_TypeScript_Integration</a>
            </div>
        </div>
        <div class="content">
            <h1 id="chapter-23-typing-hooks-and-state">Chapter 23: Typing Hooks and State</h1>
<h2 id="usestate-with-typescript">useState with TypeScript</h2>
<h2 id="learning-objective">Learning Objective</h2>
<p>Type <code>useState</code> for simple and complex states, including objects, arrays, and union types, by leveraging both type inference and explicit generic arguments.</p>
<h2 id="why-this-matters">Why This Matters</h2>
<p><code>useState</code> is the most fundamental hook for managing state in React. Understanding how to type it correctly is the first step toward building interactive, type-safe components. Getting this right prevents a wide range of bugs, from trying to put a string into a number state to accessing non-existent properties on a state object.</p>
<h2 id="discovery-phase">Discovery Phase</h2>
<p>For simple primitive values, TypeScript's inference works perfectly, and you don't need to do anything special.</p>
<div class="codehilite"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">useState</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;react&quot;</span><span class="p">;</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">Counter</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// TypeScript infers the type from the initial value (0).</span>
<span class="w">  </span><span class="c1">// `count` is inferred as type `number`.</span>
<span class="w">  </span><span class="c1">// `setCount` is inferred as `React.Dispatch&lt;React.SetStateAction&lt;number&gt;&gt;`.</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">count</span><span class="p">,</span><span class="w"> </span><span class="nx">setCount</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">(</span><span class="mf">0</span><span class="p">);</span>

<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">increment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// This is type-safe. We are passing a number.</span>
<span class="w">    </span><span class="nx">setCount</span><span class="p">(</span><span class="nx">count</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// The function update form is also typed. `c` is inferred as a number.</span>
<span class="w">    </span><span class="nx">setCount</span><span class="p">((</span><span class="nx">c</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1</span><span class="p">);</span>
<span class="w">  </span><span class="p">};</span>

<span class="w">  </span><span class="c1">// setCount(&#39;hello&#39;); // This would be a compile-time error.</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span><span class="nx">Count</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="nx">count</span><span class="p">}&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">button</span><span class="w"> </span><span class="na">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">increment</span><span class="p">}&gt;</span><span class="nx">Increment</span><span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>This is the ideal scenario. You provide an initial value, and TypeScript handles the rest. However, what if your state can be one of several types, or starts as <code>null</code>? This is where you need to give TypeScript an explicit hint using a generic argument.</p>
<div class="codehilite"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">useState</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;react&#39;</span><span class="p">;</span>

<span class="nx">type</span><span class="w"> </span><span class="nx">User</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">;</span>
<span class="w">  </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="nx">number</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">UserProfile</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// The user data might not be loaded yet, so it starts as `null`.</span>
<span class="w">  </span><span class="c1">// We must explicitly tell `useState` that this state can be `User` OR `null`.</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">user</span><span class="p">,</span><span class="w"> </span><span class="nx">setUser</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">&lt;</span><span class="nt">User</span><span class="w"> </span><span class="err">|</span><span class="w"> </span><span class="na">null</span><span class="p">&gt;(</span><span class="kc">null</span><span class="p">);</span>

<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">login</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">setUser</span><span class="p">({</span><span class="w"> </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Alice&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="p">};</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nx">user</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">button</span><span class="w"> </span><span class="na">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">login</span><span class="p">}&gt;</span><span class="nx">Login</span><span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Because of our type, TS knows `user` is a `User` object here.</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span><span class="nx">Welcome</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="nx">user</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="o">!</span><span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;;</span>
<span class="p">}</span>
</code></pre></div>

<p>Without the <code>&lt;User | null&gt;</code> generic, <code>useState(null)</code> would infer the type as <code>null</code>, and you would never be able to call <code>setUser</code> with a user object. The generic argument is your way of telling TypeScript the full range of possible types for that state variable.</p>
<h2 id="deep-dive">Deep Dive</h2>
<h3 id="when-to-use-explicit-generics">When to Use Explicit Generics</h3>
<p>You must provide an explicit generic argument to <code>useState</code> in two common scenarios:</p>
<ol>
<li><strong>When the initial state is <code>null</code> or <code>undefined</code></strong>, but it will hold a value of a different type later (like our <code>User</code> example).</li>
<li><strong>When the initial state is an empty array <code>[]</code></strong>, but you want TypeScript to know the type of items the array will eventually hold.</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">useState</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;react&#39;</span><span class="p">;</span>

<span class="nx">type</span><span class="w"> </span><span class="nx">Todo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="nx">number</span><span class="p">;</span><span class="w"> </span><span class="nx">text</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">TodoList</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Without `&lt;Todo[]&gt;`, `todos` would be inferred as `never[]`,</span>
<span class="w">  </span><span class="c1">// and you couldn&#39;t add any items to it.</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">todos</span><span class="p">,</span><span class="w"> </span><span class="nx">setTodos</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">&lt;</span><span class="nt">Todo</span><span class="err">[]</span><span class="p">&gt;([]);</span>

<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">addTodo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">newTodo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">(),</span><span class="w"> </span><span class="nx">text</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;New task&#39;</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="nx">setTodos</span><span class="p">([...</span><span class="nx">todos</span><span class="p">,</span><span class="w"> </span><span class="nx">newTodo</span><span class="p">]);</span>
<span class="w">  </span><span class="p">};</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">button</span><span class="w"> </span><span class="na">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">addTodo</span><span class="p">}&gt;</span><span class="nx">Add</span><span class="w"> </span><span class="nx">Todo</span><span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">ul</span><span class="p">&gt;</span>
<span class="w">        </span><span class="p">{</span><span class="nx">todos</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">todo</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">li</span><span class="w"> </span><span class="na">key</span><span class="o">=</span><span class="p">{</span><span class="nx">todo</span><span class="p">.</span><span class="nx">id</span><span class="p">}&gt;{</span><span class="nx">todo</span><span class="p">.</span><span class="nx">text</span><span class="p">}&lt;/</span><span class="nt">li</span><span class="p">&gt;)}</span>
<span class="w">      </span><span class="p">&lt;/</span><span class="nt">ul</span><span class="p">&gt;</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="typing-object-state">Typing Object State</h3>
<p>When your state is an object, it's best to define a <code>type</code> or <code>interface</code> for its shape.</p>
<div class="codehilite"><pre><span></span><code><span class="kr">type</span><span class="w"> </span><span class="nx">Settings</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">theme</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;light&quot;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s2">&quot;dark&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="nx">notifications</span><span class="o">:</span><span class="w"> </span><span class="kt">boolean</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">SettingsPanel</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">settings</span><span class="p">,</span><span class="w"> </span><span class="nx">setSettings</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="o">&lt;</span><span class="nx">Settings</span><span class="o">&gt;</span><span class="p">({</span>
<span class="w">    </span><span class="nx">theme</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;light&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nx">notifications</span><span class="o">:</span><span class="w"> </span><span class="kt">true</span><span class="p">,</span>
<span class="w">  </span><span class="p">});</span>

<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">toggleTheme</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Use the spread operator to update one part of the object</span>
<span class="w">    </span><span class="c1">// while preserving the rest.</span>
<span class="w">    </span><span class="nx">setSettings</span><span class="p">((</span><span class="nx">currentSettings</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">({</span>
<span class="w">      </span><span class="p">...</span><span class="nx">currentSettings</span><span class="p">,</span>
<span class="w">      </span><span class="nx">theme</span><span class="o">:</span><span class="w"> </span><span class="kt">currentSettings.theme</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s2">&quot;light&quot;</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s2">&quot;dark&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;light&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">}));</span>
<span class="w">  </span><span class="p">};</span>
<span class="p">}</span>
</code></pre></div>

<p>This ensures that you can't accidentally remove a property or add a new one that isn't part of the <code>Settings</code> type.</p>
<h3 id="common-confusion-why-cant-i-just-use-usestate-for-an-object">Common Confusion: "Why can't I just use <code>useState({})</code> for an object?"</h3>
<p><strong>You might think</strong>: "I'll start with an empty object and add properties later."</p>
<p><strong>Actually</strong>: <code>useState({})</code> tells TypeScript that the state is of type <code>{}</code>‚Äîan object with no properties. You will get an error if you try to access or set any properties on it later.</p>
<p><strong>Why the confusion happens</strong>: It's a common pattern in JavaScript to initialize an empty object.</p>
<p><strong>How to remember</strong>: With <code>useState</code>, you must declare the full shape of your state upfront. Either provide a complete initial object for inference, or use a generic argument like <code>useState&lt;MyObjectType | null&gt;(null)</code>.</p>
<h3 id="production-perspective">Production Perspective</h3>
<ul>
<li><strong>Keep State Flat</strong>: When dealing with complex object state, prefer keeping it as flat as possible. Deeply nested state objects can be difficult to update immutably.</li>
<li><strong>Consider <code>useReducer</code></strong>: If you find yourself with multiple <code>useState</code> calls that are all related, or if the logic for updating your state object is complex, it's a strong signal that you should refactor to <code>useReducer</code>. We'll cover this in the next section.</li>
</ul>
<h2 id="usereducer-type-patterns"><code>useReducer</code> Type Patterns</h2>
<h2 id="learning-objective_1">Learning Objective</h2>
<p>Implement a fully-typed <code>useReducer</code> hook by defining types for the state, a discriminated union for actions, and the reducer function itself.</p>
<h2 id="why-this-matters_1">Why This Matters</h2>
<p>For complex state management, <code>useReducer</code> provides a more structured and predictable alternative to <code>useState</code>. Typing it correctly makes your state transitions explicit and bulletproof, preventing invalid state changes and making the logic easier to reason about, test, and maintain.</p>
<h2 id="discovery-phase_1">Discovery Phase</h2>
<p>Let's refactor our simple <code>Counter</code> from the previous section to use <code>useReducer</code>. This will clearly illustrate the core concepts.</p>
<div class="codehilite"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">useReducer</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;react&#39;</span><span class="p">;</span>

<span class="c1">// Step 1: Define the shape of the state.</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">CounterState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">count</span><span class="o">:</span><span class="w"> </span><span class="nx">number</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Step 2: Define the actions using a discriminated union.</span>
<span class="c1">// This is the most important part. It lists all possible state transitions.</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">CounterAction</span><span class="w"> </span><span class="o">=</span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">type</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;increment&#39;</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">type</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;decrement&#39;</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">type</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;reset&#39;</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">type</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;add_amount&#39;</span><span class="p">;</span><span class="w"> </span><span class="nx">payload</span><span class="o">:</span><span class="w"> </span><span class="nx">number</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// An action with a payload</span>

<span class="c1">// Step 3: Define the reducer function.</span>
<span class="c1">// It takes the current state and an action, and returns the new state.</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">counterReducer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">state</span><span class="o">:</span><span class="w"> </span><span class="nx">CounterState</span><span class="p">,</span><span class="w"> </span><span class="nx">action</span><span class="o">:</span><span class="w"> </span><span class="nx">CounterAction</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="nx">CounterState</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="nx">action</span><span class="p">.</span><span class="nx">type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="s1">&#39;increment&#39;</span><span class="o">:</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">count</span><span class="o">:</span><span class="w"> </span><span class="nx">state</span><span class="p">.</span><span class="nx">count</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="s1">&#39;decrement&#39;</span><span class="o">:</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">count</span><span class="o">:</span><span class="w"> </span><span class="nx">state</span><span class="p">.</span><span class="nx">count</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="s1">&#39;reset&#39;</span><span class="o">:</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">count</span><span class="o">:</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="s1">&#39;add_amount&#39;</span><span class="o">:</span>
<span class="w">      </span><span class="c1">// TS knows `action` has a `payload` of type `number` here.</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">count</span><span class="o">:</span><span class="w"> </span><span class="nx">state</span><span class="p">.</span><span class="nx">count</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">action</span><span class="p">.</span><span class="nx">payload</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="k">default</span><span class="o">:</span>
<span class="w">      </span><span class="k">throw</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="ne">Error</span><span class="p">(</span><span class="s1">&#39;Unhandled action type&#39;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">initialState</span><span class="o">:</span><span class="w"> </span><span class="nx">CounterState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">count</span><span class="o">:</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">};</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">Counter</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Step 4: Use the hook. TypeScript infers everything from the reducer.</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">state</span><span class="p">,</span><span class="w"> </span><span class="nx">dispatch</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useReducer</span><span class="p">(</span><span class="nx">counterReducer</span><span class="p">,</span><span class="w"> </span><span class="nx">initialState</span><span class="p">);</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span><span class="nx">Count</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="nx">state</span><span class="p">.</span><span class="nx">count</span><span class="p">}&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">{</span><span class="cm">/* `dispatch` is fully typed. It will only accept objects</span>
<span class="cm">          that match our `CounterAction` type. */</span><span class="p">}</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">button</span><span class="w"> </span><span class="na">onClick</span><span class="o">=</span><span class="p">{()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">dispatch</span><span class="p">({</span><span class="w"> </span><span class="nx">type</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;increment&#39;</span><span class="w"> </span><span class="p">})}&gt;</span><span class="nx">Increment</span><span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">button</span><span class="w"> </span><span class="na">onClick</span><span class="o">=</span><span class="p">{()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">dispatch</span><span class="p">({</span><span class="w"> </span><span class="nx">type</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;decrement&#39;</span><span class="w"> </span><span class="p">})}&gt;</span><span class="nx">Decrement</span><span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">button</span><span class="w"> </span><span class="na">onClick</span><span class="o">=</span><span class="p">{()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">dispatch</span><span class="p">({</span><span class="w"> </span><span class="nx">type</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;add_amount&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">payload</span><span class="o">:</span><span class="w"> </span><span class="mf">5</span><span class="w"> </span><span class="p">})}&gt;</span><span class="nx">Add</span><span class="w"> </span><span class="mf">5</span><span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">button</span><span class="w"> </span><span class="na">onClick</span><span class="o">=</span><span class="p">{()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">dispatch</span><span class="p">({</span><span class="w"> </span><span class="nx">type</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;reset&#39;</span><span class="w"> </span><span class="p">})}&gt;</span><span class="nx">Reset</span><span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>This pattern is incredibly robust:</p>
<ol>
<li>The <code>CounterAction</code> discriminated union acts as a contract for all possible state changes. It's impossible to dispatch an action with a typo (e.g., <code>dispatch({ type: 'incremennt' })</code>).</li>
<li>Inside the reducer's <code>switch</code> statement, TypeScript narrows the <code>action</code> type. In the <code>'add_amount'</code> case, it knows that <code>action.payload</code> exists and is a number.</li>
<li>The <code>useReducer</code> hook infers the types of <code>state</code> and <code>dispatch</code> from the reducer function you provide. You don't need to add any generics to the hook call itself.</li>
</ol>
<h2 id="deep-dive_1">Deep Dive</h2>
<h3 id="why-a-discriminated-union-for-actions">Why a Discriminated Union for Actions?</h3>
<p>Using a discriminated union for your actions is the cornerstone of this pattern. It provides several key benefits over using, for example, a single object type with optional properties:</p>
<ul>
<li><strong>Explicitness</strong>: It clearly enumerates every possible action.</li>
<li><strong>Safety</strong>: It prevents you from dispatching actions with invalid combinations of properties.</li>
<li><strong>Type Narrowing</strong>: It enables TypeScript's <code>switch</code> statement narrowing, which is what makes the reducer implementation so safe and provides excellent autocompletion.</li>
</ul>
<h3 id="production-perspective_1">Production Perspective</h3>
<ul>
<li><strong>When to Choose <code>useReducer</code></strong>:</li>
<li>When you have complex state logic that involves multiple sub-values.</li>
<li>When the next state depends on the previous one.</li>
<li>When you want to co-locate all state transition logic in one place.</li>
<li>When you want to optimize performance for components that trigger deep updates, as you can pass <code>dispatch</code> down instead of callbacks.</li>
<li><strong>Organization</strong>: For complex components, it's a common and highly recommended practice to extract the reducer, action types, and initial state into a separate file (e.g., <code>counterReducer.ts</code>). This separates the state management logic from the view logic, making both easier to manage and test.</li>
<li><strong>Testing</strong>: Reducer functions are "pure functions"‚Äîthey take state and an action and return a new state with no side effects. This makes them incredibly easy to unit test. You can test your entire state logic without even rendering a React component.</li>
</ul>
<h2 id="usecontext-with-typescript"><code>useContext</code> with TypeScript</h2>
<h2 id="learning-objective_2">Learning Objective</h2>
<p>Create and consume a type-safe context, handling the common case of a nullable default value and creating a custom hook to provide a non-null context value.</p>
<h2 id="why-this-matters_2">Why This Matters</h2>
<p><code>useContext</code> is React's solution for avoiding "prop drilling"‚Äîpassing props down through many levels of the component tree. Typing your context correctly ensures that any component consuming it receives the expected data and functions, and it prevents runtime errors from consuming a context outside of its provider.</p>
<h2 id="discovery-phase_2">Discovery Phase</h2>
<p>Let's create a simple context to provide user authentication status to any component in our app.</p>
<div class="codehilite"><pre><span></span><code><span class="s1">&#39;use client&#39;</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">createContext</span><span class="p">,</span><span class="w"> </span><span class="nx">useContext</span><span class="p">,</span><span class="w"> </span><span class="nx">useState</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;react&#39;</span><span class="p">;</span>

<span class="c1">// Step 1: Define the shape of the context&#39;s value.</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">AuthContextType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">isAuthenticated</span><span class="o">:</span><span class="w"> </span><span class="kr">boolean</span><span class="p">;</span>
<span class="w">  </span><span class="nx">username</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span>
<span class="w">  </span><span class="nx">login</span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="nx">username</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ow">void</span><span class="p">;</span>
<span class="w">  </span><span class="nx">logout</span><span class="o">:</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ow">void</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Step 2: Create the context with a generic argument and a default value.</span>
<span class="c1">// It&#39;s common to use `null` as the default for contexts that require a provider.</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">AuthContext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">createContext</span><span class="p">&lt;</span><span class="nt">AuthContextType</span><span class="w"> </span><span class="err">|</span><span class="w"> </span><span class="na">null</span><span class="p">&gt;(</span><span class="kc">null</span><span class="p">);</span>

<span class="c1">// Step 3: Create the Provider component.</span>
<span class="k">export</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">AuthProvider</span><span class="p">({</span><span class="w"> </span><span class="nx">children</span><span class="w"> </span><span class="p">}</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">children</span><span class="o">:</span><span class="w"> </span><span class="nx">React</span><span class="p">.</span><span class="nx">ReactNode</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">username</span><span class="p">,</span><span class="w"> </span><span class="nx">setUsername</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">&lt;</span><span class="nt">string</span><span class="w"> </span><span class="err">|</span><span class="w"> </span><span class="na">null</span><span class="p">&gt;(</span><span class="kc">null</span><span class="p">);</span>

<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">login</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">setUsername</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">logout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">setUsername</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>

<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="nx">AuthContextType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">isAuthenticated</span><span class="o">:</span><span class="w"> </span><span class="nx">username</span><span class="w"> </span><span class="o">!==</span><span class="w"> </span><span class="kc">null</span><span class="p">,</span>
<span class="w">    </span><span class="nx">username</span><span class="p">,</span>
<span class="w">    </span><span class="nx">login</span><span class="p">,</span>
<span class="w">    </span><span class="nx">logout</span><span class="p">,</span>
<span class="w">  </span><span class="p">};</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">AuthContext</span><span class="p">.</span><span class="na">Provider</span><span class="w"> </span><span class="na">value</span><span class="o">=</span><span class="p">{</span><span class="nx">value</span><span class="p">}&gt;{</span><span class="nx">children</span><span class="p">}&lt;/</span><span class="nt">AuthContext</span><span class="p">.</span><span class="na">Provider</span><span class="p">&gt;;</span>
<span class="p">}</span>

<span class="c1">// Step 4: Create a component that consumes the context.</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">UserStatus</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">auth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useContext</span><span class="p">(</span><span class="nx">AuthContext</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Step 5: Handle the nullable type.</span>
<span class="w">  </span><span class="c1">// `auth` is of type `AuthContextType | null`. We must check for null.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nx">auth</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// This happens if `UserStatus` is rendered outside of `AuthProvider`.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span><span class="nx">Please</span><span class="w"> </span><span class="nx">wrap</span><span class="w"> </span><span class="nx">your</span><span class="w"> </span><span class="nx">app</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nx">AuthProvider</span><span class="p">.&lt;/</span><span class="nt">p</span><span class="p">&gt;;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">{</span><span class="nx">auth</span><span class="p">.</span><span class="nx">isAuthenticated</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="p">(</span>
<span class="w">        </span><span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span><span class="nx">Welcome</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="nx">auth</span><span class="p">.</span><span class="nx">username</span><span class="p">}</span><span class="o">!</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">button</span><span class="w"> </span><span class="na">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">auth</span><span class="p">.</span><span class="nx">logout</span><span class="p">}&gt;</span><span class="nx">Logout</span><span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span>
<span class="w">        </span><span class="p">&lt;</span><span class="nt">button</span><span class="w"> </span><span class="na">onClick</span><span class="o">=</span><span class="p">{()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">auth</span><span class="p">.</span><span class="nx">login</span><span class="p">(</span><span class="s1">&#39;Alice&#39;</span><span class="p">)}&gt;</span><span class="nx">Login</span><span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">)}</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// --- USAGE ---</span>
<span class="k">export</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">App</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">        </span><span class="p">&lt;</span><span class="nt">AuthProvider</span><span class="p">&gt;</span>
<span class="w">            </span><span class="p">&lt;</span><span class="nt">UserStatus</span><span class="w"> </span><span class="p">/&gt;</span>
<span class="w">        </span><span class="p">&lt;/</span><span class="nt">AuthProvider</span><span class="p">&gt;</span>
<span class="w">    </span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>

<p>This pattern is robust and safe. The key is <code>createContext&lt;AuthContextType | null&gt;(null)</code>.</p>
<ul>
<li>The generic <code>&lt;AuthContextType | null&gt;</code> tells TypeScript what types to expect.</li>
<li>The <code>null</code> initial value forces any consumer of the context to perform a null check. This is a feature, not a bug! It prevents you from accidentally using the component without wrapping it in the necessary provider, which would lead to a runtime error.</li>
</ul>
<h2 id="deep-dive_2">Deep Dive</h2>
<h3 id="creating-a-custom-hook-for-the-context">Creating a Custom Hook for the Context</h3>
<p>Having to check for <code>null</code> in every component that consumes the context can be repetitive. A very common and highly recommended pattern is to create a custom hook that wraps <code>useContext</code> and includes the null check.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// In the same file as the context creation...</span>

<span class="c1">// This custom hook provides a better developer experience.</span>
<span class="k">export</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">useAuth</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useContext</span><span class="p">(</span><span class="nx">AuthContext</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">context</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// This provides a much more helpful error message.</span>
<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="ne">Error</span><span class="p">(</span><span class="s2">&quot;useAuth must be used within an AuthProvider&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">context</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Now, our consumer component becomes much cleaner:</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">UserStatusWithHook</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// `auth` is now guaranteed to be of type `AuthContextType`.</span>
<span class="w">  </span><span class="c1">// No null check needed!</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">auth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useAuth</span><span class="p">();</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">{</span><span class="nx">auth</span><span class="p">.</span><span class="nx">isAuthenticated</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="p">(</span>
<span class="w">        </span><span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>
<span class="w">          </span><span class="nx">Welcome</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="nx">auth</span><span class="p">.</span><span class="nx">username</span><span class="p">}</span><span class="o">!</span><span class="p">{</span><span class="s2">&quot; &quot;</span><span class="p">}</span>
<span class="w">          </span><span class="p">&lt;</span><span class="nt">button</span><span class="w"> </span><span class="na">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">auth</span><span class="p">.</span><span class="nx">logout</span><span class="p">}&gt;</span><span class="nx">Logout</span><span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
<span class="w">        </span><span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span>
<span class="w">        </span><span class="p">&lt;</span><span class="nt">button</span><span class="w"> </span><span class="na">onClick</span><span class="o">=</span><span class="p">{()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">auth</span><span class="p">.</span><span class="nx">login</span><span class="p">(</span><span class="s2">&quot;Alice&quot;</span><span class="p">)}&gt;</span><span class="nx">Login</span><span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">)}</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>This is the professional standard for working with context.</p>
<ol>
<li>It encapsulates the <code>useContext</code> call and the null check.</li>
<li>It provides a clear, descriptive error if the provider is missing.</li>
<li>It provides a non-nullable context value to the components, simplifying their implementation.</li>
</ol>
<h3 id="production-perspective_2">Production Perspective</h3>
<ul>
<li><strong>Provider Placement</strong>: Place your context providers as low in the component tree as possible. Wrapping your entire application in a provider can cause unnecessary re-renders in large parts of your app when the context value changes.</li>
<li><strong>Context for Low-Frequency Updates</strong>: Context is best suited for global data that doesn't change often, such as theme information, user authentication, or language preferences. For high-frequency state updates, consider a more optimized state management library or local state.</li>
<li><strong>Memoization</strong>: If the value you provide to a context provider is an object or array literal, it will be recreated on every render, causing all consumers to re-render. You should memoize the value with <code>useMemo</code> to prevent this.</li>
</ul>
<h2 id="useref-generic-types"><code>useRef</code> Generic Types</h2>
<h2 id="learning-objective_3">Learning Objective</h2>
<p>Correctly apply generic types to <code>useRef</code> for two distinct use cases: accessing DOM elements and persisting mutable values across renders.</p>
<h2 id="why-this-matters_3">Why This Matters</h2>
<p><code>useRef</code> is a versatile hook, but its typing can be subtle because it behaves differently depending on how you initialize it. Providing the correct generic type and initial value is crucial for safely interacting with DOM nodes and for correctly typing mutable "instance variables" in your function components.</p>
<h2 id="discovery-phase_3">Discovery Phase</h2>
<p>We'll look at the two primary use cases for <code>useRef</code> side-by-side to highlight the difference in their typing.</p>
<h3 id="use-case-1-accessing-a-dom-element">Use Case 1: Accessing a DOM Element</h3>
<p>This is the most common use case. You want a reference to a DOM node, like an <code>&lt;input&gt;</code>, to call methods like <code>.focus()</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">useRef</span><span class="p">,</span><span class="w"> </span><span class="nx">useEffect</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;react&quot;</span><span class="p">;</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">DOMRefExample</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// For DOM refs, the generic is the element type.</span>
<span class="w">  </span><span class="c1">// The initial value MUST be `null`.</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">inputRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useRef</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">HTMLInputElement</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span>

<span class="w">  </span><span class="nx">useEffect</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Because the initial value is `null`, TypeScript correctly infers</span>
<span class="w">    </span><span class="c1">// the type of `inputRef.current` as `HTMLInputElement | null`.</span>
<span class="w">    </span><span class="c1">// We must use optional chaining `?.` or an explicit check.</span>
<span class="w">    </span><span class="nx">inputRef</span><span class="p">.</span><span class="nx">current</span><span class="o">?</span><span class="p">.</span><span class="nx">focus</span><span class="p">();</span>
<span class="w">  </span><span class="p">},</span><span class="w"> </span><span class="p">[]);</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">input</span><span class="w"> </span><span class="na">ref</span><span class="o">=</span><span class="p">{</span><span class="nx">inputRef</span><span class="p">}</span><span class="w"> </span><span class="na">placeholder</span><span class="o">=</span><span class="s">&quot;I will be focused&quot;</span><span class="w"> </span><span class="p">/&gt;;</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>Rule for DOM Refs</strong>: <code>useRef&lt;ElementType&gt;(null)</code></p>
<h3 id="use-case-2-storing-a-mutable-value">Use Case 2: Storing a Mutable Value</h3>
<p>Sometimes you need to store a value that persists across renders but doesn't trigger a re-render when it changes. This is like an instance variable.</p>
<div class="codehilite"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">useRef</span><span class="p">,</span><span class="w"> </span><span class="nx">useEffect</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;react&quot;</span><span class="p">;</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">MutableValueRefExample</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// For mutable values, the generic is the value type.</span>
<span class="w">  </span><span class="c1">// We provide a concrete initial value.</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">renderCountRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useRef</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">number</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span>

<span class="w">  </span><span class="nx">useEffect</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// We can safely increment this on every render.</span>
<span class="w">    </span><span class="c1">// Mutating `.current` does NOT cause a re-render.</span>
<span class="w">    </span><span class="nx">renderCountRef</span><span class="p">.</span><span class="nx">current</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mf">1</span><span class="p">;</span>
<span class="w">  </span><span class="p">});</span>

<span class="w">  </span><span class="c1">// Because we provided a non-null initial value, TypeScript knows</span>
<span class="w">  </span><span class="c1">// `renderCountRef.current` is always a `number`. No null check needed.</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span><span class="nx">This</span><span class="w"> </span><span class="nx">component</span><span class="w"> </span><span class="nx">has</span><span class="w"> </span><span class="nx">rendered</span><span class="w"> </span><span class="p">{</span><span class="nx">renderCountRef</span><span class="p">.</span><span class="nx">current</span><span class="p">}</span><span class="w"> </span><span class="nx">times</span><span class="p">.&lt;/</span><span class="nt">p</span><span class="p">&gt;;</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>Rule for Mutable Values</strong>: <code>useRef&lt;ValueType&gt;(initialValue)</code></p>
<h2 id="deep-dive_3">Deep Dive</h2>
<h3 id="the-current-propertys-type">The <code>current</code> Property's Type</h3>
<p>The key difference lies in the type of the <code>.current</code> property that TypeScript infers:</p>
<ul>
<li><code>useRef&lt;T&gt;(null)</code> ‚Üí <code>ref.current</code> is of type <code>T | null</code>.</li>
<li><code>useRef&lt;T&gt;(initialValue: T)</code> ‚Üí <code>ref.current</code> is of type <code>T</code>.</li>
<li><code>useRef&lt;T&gt;()</code> (no initial value) ‚Üí <code>ref.current</code> is of type <code>T | undefined</code>.</li>
</ul>
<p>This last case is often used for values that will be set later, like a timer ID.</p>
<div class="codehilite"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">useRef</span><span class="p">,</span><span class="w"> </span><span class="nx">useEffect</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;react&#39;</span><span class="p">;</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">Timer</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// We don&#39;t have the timer ID initially.</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">timerRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useRef</span><span class="o">&lt;</span><span class="nx">number</span><span class="o">&gt;</span><span class="p">();</span><span class="w"> </span><span class="c1">// `timerRef.current` is `number | undefined`</span>

<span class="w">  </span><span class="nx">useEffect</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">timerRef</span><span class="p">.</span><span class="nx">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">window</span><span class="p">.</span><span class="nx">setInterval</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Tick&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="p">},</span><span class="w"> </span><span class="mf">1000</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// We need to check for undefined before clearing.</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">timerRef</span><span class="p">.</span><span class="nx">current</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nb">window</span><span class="p">.</span><span class="nx">clearInterval</span><span class="p">(</span><span class="nx">timerRef</span><span class="p">.</span><span class="nx">current</span><span class="p">);</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">  </span><span class="p">},</span><span class="w"> </span><span class="p">[]);</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="nx">Timer</span><span class="w"> </span><span class="nx">is</span><span class="w"> </span><span class="nx">running</span><span class="w"> </span><span class="p">(</span><span class="nx">see</span><span class="w"> </span><span class="nx">console</span><span class="p">).</span><span class="o">&lt;</span><span class="err">/div&gt;;</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="common-confusion-why-is-the-initial-value-for-dom-refs-null">Common Confusion: "Why is the initial value for DOM refs <code>null</code>?"</h3>
<p><strong>You might think</strong>: "The element exists, so why start with <code>null</code>?"</p>
<p><strong>Actually</strong>: When the <code>useRef</code> line is executed during the component's render, the DOM has not been updated yet. The <code>&lt;input&gt;</code> element doesn't exist in the DOM at that moment. React only populates <code>ref.current</code> with the DOM node <em>after</em> the render is complete and the element has been mounted. Therefore, its initial value must be <code>null</code> to accurately reflect its state during the initial render.</p>
<p><strong>How to remember</strong>: <code>useRef</code> runs before the <code>return</code> statement. The <code>ref</code> attribute in JSX is handled <em>after</em> the <code>return</code>. So, the initial value has to be empty.</p>
<h3 id="production-perspective_3">Production Perspective</h3>
<ul>
<li><strong><code>useImperativeHandle</code></strong>: When creating a component that forwards a ref to a custom component (not a DOM node), you'll often combine <code>useRef</code> with <code>useImperativeHandle</code>. The generic type on the ref should match the handle type you define. (See Chapter 20.4 for a full example).</li>
<li><strong>Storing Previous State</strong>: A classic use case for a mutable ref is to store a value from the previous render. This is often extracted into a custom hook.
  <code>typescript
  function usePrevious&lt;T&gt;(value: T): T | undefined {
    const ref = useRef&lt;T&gt;();
    useEffect(() =&gt; {
      ref.current = value;
    }, [value]);
    return ref.current;
  }</code></li>
</ul>
<h2 id="usecallback-and-usememo-types-when-needed"><code>useCallback</code> and <code>useMemo</code> Types (When Needed)</h2>
<h2 id="learning-objective_4">Learning Objective</h2>
<p>Correctly type <code>useCallback</code> and <code>useMemo</code> while understanding their diminished role for performance optimization in the era of the React 19 Compiler.</p>
<h2 id="why-this-matters_4">Why This Matters</h2>
<p>In previous versions of React, <code>useCallback</code> and <code>useMemo</code> were essential tools for preventing unnecessary re-renders. While the new React Compiler makes them largely obsolete for this purpose, they are still necessary for specific cases, such as maintaining a stable function identity for dependency arrays or third-party libraries. Fortunately, TypeScript's inference makes typing them extremely simple.</p>
<h2 id="discovery-phase_4">Discovery Phase</h2>
<h3 id="usecallback"><code>useCallback</code></h3>
<p><code>useCallback</code> memoizes a function instance. You provide a function and a dependency array.</p>
<div class="codehilite"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">useState</span><span class="p">,</span><span class="w"> </span><span class="nx">useCallback</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;react&#39;</span><span class="p">;</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">Button</span><span class="p">({</span><span class="w"> </span><span class="nx">onClick</span><span class="w"> </span><span class="p">}</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">onClick</span><span class="o">:</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ow">void</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Button rendered&#39;</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">button</span><span class="w"> </span><span class="na">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">onClick</span><span class="p">}&gt;</span><span class="nx">Click</span><span class="w"> </span><span class="nx">Me</span><span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;;</span>
<span class="p">}</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">MemoizedButton</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">React</span><span class="p">.</span><span class="nx">memo</span><span class="p">(</span><span class="nx">Button</span><span class="p">);</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">CallbackExample</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">count</span><span class="p">,</span><span class="w"> </span><span class="nx">setCount</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">(</span><span class="mf">0</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// TypeScript infers the entire type of this function.</span>
<span class="w">  </span><span class="c1">// `handleClick` is typed as `() =&gt; void`.</span>
<span class="w">  </span><span class="c1">// No explicit typing is needed on the `useCallback` call itself.</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">handleClick</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useCallback</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Button was clicked!&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// `count` is included in the dependency array, so it&#39;s not stale.</span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`Current count is </span><span class="si">${</span><span class="nx">count</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
<span class="w">  </span><span class="p">},</span><span class="w"> </span><span class="p">[</span><span class="nx">count</span><span class="p">]);</span><span class="w"> </span><span class="c1">// Dependency array</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span><span class="nx">Count</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="nx">count</span><span class="p">}&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">button</span><span class="w"> </span><span class="na">onClick</span><span class="o">=</span><span class="p">{()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">setCount</span><span class="p">(</span><span class="nx">c</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1</span><span class="p">)}&gt;</span><span class="nx">Increment</span><span class="w"> </span><span class="nx">Count</span><span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">MemoizedButton</span><span class="w"> </span><span class="na">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">handleClick</span><span class="p">}</span><span class="w"> </span><span class="p">/&gt;</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>Because <code>handleClick</code> is wrapped in <code>useCallback</code>, it will only be a new function instance if <code>count</code> changes. This prevents the <code>MemoizedButton</code> from re-rendering every time <code>CallbackExample</code> re-renders. TypeScript infers the type of <code>handleClick</code> from the function you pass into it.</p>
<h3 id="usememo"><code>useMemo</code></h3>
<p><code>useMemo</code> memoizes a value. You provide a factory function that computes the value and a dependency array.</p>
<div class="codehilite"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">useState</span><span class="p">,</span><span class="w"> </span><span class="nx">useMemo</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;react&#39;</span><span class="p">;</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">expensiveCalculation</span><span class="p">(</span><span class="nx">num</span><span class="o">:</span><span class="w"> </span><span class="nx">number</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="nx">number</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Performing expensive calculation...&#39;</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// Simulate a slow computation</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="nx">total</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">let</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">num</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">1</span><span class="nx">_000_000</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">total</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">i</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">total</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">MemoExample</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">count</span><span class="p">,</span><span class="w"> </span><span class="nx">setCount</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">(</span><span class="mf">10</span><span class="p">);</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">otherState</span><span class="p">,</span><span class="w"> </span><span class="nx">setOtherState</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">(</span><span class="mf">0</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// TypeScript infers the return type of `expensiveCalculation`.</span>
<span class="w">  </span><span class="c1">// `computedValue` is correctly typed as `number`.</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">computedValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useMemo</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">expensiveCalculation</span><span class="p">(</span><span class="nx">count</span><span class="p">);</span>
<span class="w">  </span><span class="p">},</span><span class="w"> </span><span class="p">[</span><span class="nx">count</span><span class="p">]);</span><span class="w"> </span><span class="c1">// Only re-calculates when `count` changes.</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span><span class="nx">Count</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="nx">count</span><span class="p">}&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span><span class="nx">Computed</span><span class="w"> </span><span class="nx">Value</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="nx">computedValue</span><span class="p">}&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">button</span><span class="w"> </span><span class="na">onClick</span><span class="o">=</span><span class="p">{()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">setCount</span><span class="p">(</span><span class="nx">c</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1</span><span class="p">)}&gt;</span><span class="nx">Increment</span><span class="w"> </span><span class="nx">Count</span><span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span><span class="nx">Other</span><span class="w"> </span><span class="nx">State</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="nx">otherState</span><span class="p">}&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">{</span><span class="cm">/* Clicking this button re-renders the component, but the expensive</span>
<span class="cm">          calculation does NOT run again, thanks to `useMemo`. */</span><span class="p">}</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">button</span><span class="w"> </span><span class="na">onClick</span><span class="o">=</span><span class="p">{()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">setOtherState</span><span class="p">(</span><span class="nx">c</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1</span><span class="p">)}&gt;</span><span class="nx">Update</span><span class="w"> </span><span class="nx">Other</span><span class="w"> </span><span class="nx">State</span><span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>Just like <code>useCallback</code>, <code>useMemo</code>'s return type is inferred from the factory function you provide.</p>
<h2 id="deep-dive_4">Deep Dive</h2>
<h3 id="legacy-pattern-notice-the-react-19-compiler">Legacy Pattern Notice: The React 19 Compiler</h3>
<p><strong>Pre-React 19</strong>: Manually wrapping functions in <code>useCallback</code> and values in <code>useMemo</code> was a standard and necessary practice for performance optimization in any non-trivial component.</p>
<p><strong>React 19+</strong>: The React Compiler (<code>react-forget</code>) automates this process. It analyzes your component's code and automatically memoizes components, props, and values where necessary.</p>
<p><strong>This means you should no longer use <code>useCallback</code> or <code>useMemo</code> for performance optimization by default.</strong> The compiler is better at it than humans are.</p>
<p><strong>When are they still useful?</strong></p>
<ol>
<li><strong>Stable Function Identity for Dependencies</strong>: When passing a function to a custom hook that includes it in its dependency array, you may need <code>useCallback</code> to prevent infinite loops.</li>
<li><strong>Third-Party Libraries</strong>: When a library expects a stable function reference (e.g., an event listener for a non-React library).</li>
<li><strong>Expensive Calculations</strong>: For genuinely expensive, synchronous calculations, <code>useMemo</code> is still the correct tool to prevent re-computation on every render. The compiler may not always memoize these aggressively.</li>
<li><strong>Codebases without the Compiler</strong>: If you are working on a project where the React Compiler is not enabled, the old rules still apply.</li>
</ol>
<h3 id="production-perspective_4">Production Perspective</h3>
<ul>
<li><strong>Optimize Last</strong>: Don't prematurely optimize. The React Compiler is the default. Only reach for manual memoization if you have identified a specific performance bottleneck using the React DevTools profiler.</li>
<li><strong>Readability</strong>: One of the biggest benefits of the compiler is improved code readability. Overuse of <code>useCallback</code> and <code>useMemo</code> can clutter components and make them harder to understand. Embrace the simpler, compiler-friendly style of writing components.</li>
</ul>
<h2 id="custom-hook-type-signatures">Custom Hook Type Signatures</h2>
<h2 id="learning-objective_5">Learning Objective</h2>
<p>Write and type custom hooks with clear and explicit type signatures for their parameters and return values, establishing a reusable and self-documenting API.</p>
<h2 id="why-this-matters_5">Why This Matters</h2>
<p>Custom hooks are the primary mechanism for sharing stateful logic between components. A well-typed custom hook is like a mini-API for your application's logic. A clear signature makes the hook easy to use, prevents errors, and allows TypeScript to provide excellent autocompletion and inference in the components that consume it.</p>
<h2 id="discovery-phase_5">Discovery Phase</h2>
<p>Let's build a simple <code>useToggle</code> hook. It will manage a boolean state and provide a function to toggle it.</p>
<div class="codehilite"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">useState</span><span class="p">,</span><span class="w"> </span><span class="nx">useCallback</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;react&#39;</span><span class="p">;</span>

<span class="c1">// Step 1: Define the hook&#39;s signature.</span>
<span class="c1">// It takes an optional initial boolean value.</span>
<span class="c1">// It returns a tuple, just like `useState`.</span>
<span class="k">export</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">useToggle</span><span class="p">(</span>
<span class="w">  </span><span class="nx">initialValue</span><span class="o">:</span><span class="w"> </span><span class="kr">boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span>
<span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="kr">boolean</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ow">void</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">value</span><span class="p">,</span><span class="w"> </span><span class="nx">setValue</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">(</span><span class="nx">initialValue</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// We use `useCallback` to ensure the toggle function has a stable identity.</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">toggle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useCallback</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">setValue</span><span class="p">(</span><span class="nx">currentValue</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="o">!</span><span class="nx">currentValue</span><span class="p">);</span>
<span class="w">  </span><span class="p">},</span><span class="w"> </span><span class="p">[]);</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">[</span><span class="nx">value</span><span class="p">,</span><span class="w"> </span><span class="nx">toggle</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">// --- USAGE ---</span>
<span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;react&#39;</span><span class="p">;</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">ToggleComponent</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// TypeScript infers the types from our hook&#39;s signature.</span>
<span class="w">  </span><span class="c1">// `isOpen` is a boolean.</span>
<span class="w">  </span><span class="c1">// `toggleOpen` is `() =&gt; void`.</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">isOpen</span><span class="p">,</span><span class="w"> </span><span class="nx">toggleOpen</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useToggle</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
<span class="w">      </span><span class="o">&lt;</span><span class="nx">button</span><span class="w"> </span><span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">toggleOpen</span><span class="p">}</span><span class="o">&gt;</span>
<span class="w">        </span><span class="p">{</span><span class="nx">isOpen</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s1">&#39;Hide&#39;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Show&#39;</span><span class="p">}</span>
<span class="w">      </span><span class="o">&lt;</span><span class="err">/button&gt;</span>
<span class="w">      </span><span class="p">{</span><span class="nx">isOpen</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">Now</span><span class="w"> </span><span class="nx">you</span><span class="w"> </span><span class="nx">see</span><span class="w"> </span><span class="nx">me</span><span class="o">!&lt;</span><span class="err">/p&gt;}</span>
<span class="w">    </span><span class="o">&lt;</span><span class="err">/div&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>The key is the function signature: <code>useToggle(initialValue: boolean = false): [boolean, () =&gt; void]</code>.</p>
<ul>
<li><strong>Parameters</strong>: We type <code>initialValue</code> as a <code>boolean</code> and give it a default value.</li>
<li><strong>Return Value</strong>: We explicitly type the return value as a tuple <code>[boolean, () =&gt; void]</code>. This tells consumers exactly what to expect when they destructure the array.</li>
</ul>
<h2 id="deep-dive_5">Deep Dive</h2>
<h3 id="returning-an-object-vs-an-array">Returning an Object vs. an Array</h3>
<p>For hooks that return more than two values, or where the meaning isn't as obvious as <code>[state, setState]</code>, returning an object can be more readable.</p>
<p>Let's build a <code>useCounter</code> hook.</p>
<div class="codehilite"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">useState</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;react&#39;</span><span class="p">;</span>

<span class="c1">// Step 1: Define the return type as an object.</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">UseCounterReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">count</span><span class="o">:</span><span class="w"> </span><span class="nx">number</span><span class="p">;</span>
<span class="w">  </span><span class="nx">increment</span><span class="o">:</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ow">void</span><span class="p">;</span>
<span class="w">  </span><span class="nx">decrement</span><span class="o">:</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ow">void</span><span class="p">;</span>
<span class="w">  </span><span class="nx">reset</span><span class="o">:</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ow">void</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Step 2: Define the hook with the explicit return type.</span>
<span class="k">export</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">useCounter</span><span class="p">(</span><span class="nx">initialValue</span><span class="o">:</span><span class="w"> </span><span class="nx">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="nx">UseCounterReturn</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">count</span><span class="p">,</span><span class="w"> </span><span class="nx">setCount</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">(</span><span class="nx">initialValue</span><span class="p">);</span>

<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">increment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">setCount</span><span class="p">(</span><span class="nx">c</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1</span><span class="p">);</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">decrement</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">setCount</span><span class="p">(</span><span class="nx">c</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1</span><span class="p">);</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">reset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">setCount</span><span class="p">(</span><span class="nx">initialValue</span><span class="p">);</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">count</span><span class="p">,</span><span class="w"> </span><span class="nx">increment</span><span class="p">,</span><span class="w"> </span><span class="nx">decrement</span><span class="p">,</span><span class="w"> </span><span class="nx">reset</span><span class="w"> </span><span class="p">};</span>
<span class="p">}</span>

<span class="c1">// --- USAGE ---</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">CounterComponent</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Destructuring an object makes the usage self-documenting.</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">count</span><span class="p">,</span><span class="w"> </span><span class="nx">increment</span><span class="p">,</span><span class="w"> </span><span class="nx">decrement</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useCounter</span><span class="p">(</span><span class="mf">5</span><span class="p">);</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span><span class="nx">Count</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="nx">count</span><span class="p">}&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">button</span><span class="w"> </span><span class="na">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">increment</span><span class="p">}&gt;</span><span class="o">+</span><span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">button</span><span class="w"> </span><span class="na">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">decrement</span><span class="p">}&gt;</span><span class="o">-</span><span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="array-vs-object-which-to-choose">Array vs. Object: Which to Choose?</h3>
<ul>
<li><strong>Return an array (tuple)</strong> when your hook is a direct analogue of a built-in hook like <code>useState</code>. This allows the consumer to name the destructured variables whatever they want (e.g., <code>const [isOpen, toggle] = useToggle()</code>).</li>
<li><strong>Return an object</strong> when your hook returns multiple values and functions. This makes the code more self-documenting (<code>counter.increment()</code>) and allows the consumer to only destructure the parts they need. It's also easier to add new return values later without breaking the destructuring for existing consumers.</li>
</ul>
<h3 id="production-perspective_5">Production Perspective</h3>
<ul>
<li><strong>Hook Naming</strong>: Always start custom hook names with <code>use</code>. This is a convention that ESLint plugins rely on to check for rules of hooks (e.g., not calling hooks conditionally).</li>
<li><strong>Single Responsibility</strong>: A good custom hook has a single, clear purpose. Don't try to create a "god hook" that does everything. It's better to have several smaller, focused hooks that can be composed together.</li>
<li><strong>Documentation</strong>: A well-typed signature <em>is</em> a form of documentation. For complex hooks, supplement this with JSDoc comments explaining what the hook does, what its parameters are, and what it returns. Your editor will show these comments on hover.</li>
</ul>
<h2 id="generic-custom-hooks">Generic Custom Hooks</h2>
<h2 id="learning-objective_6">Learning Objective</h2>
<p>Create flexible, reusable generic custom hooks that can operate on different data types while maintaining full type safety.</p>
<h2 id="why-this-matters_6">Why This Matters</h2>
<p>Hard-coding types in a custom hook limits its reusability. By making your custom hooks generic, you can create powerful, abstract logic that can be applied to any data structure in your application. This is the key to building a truly reusable logic layer for your frontend.</p>
<h2 id="discovery-phase_6">Discovery Phase</h2>
<p>Let's take a common use case: fetching data from an API. We want a hook that can fetch any kind of data and manage the loading, error, and data states for us. This is a perfect candidate for a generic hook.</p>
<div class="codehilite"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">useState</span><span class="p">,</span><span class="w"> </span><span class="nx">useEffect</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;react&#39;</span><span class="p">;</span>

<span class="c1">// Step 1: Define the shape of the state the hook will manage.</span>
<span class="c1">// It&#39;s generic over `T`, which represents the type of the data.</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">FetchState</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">data</span><span class="o">:</span><span class="w"> </span><span class="nx">T</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span>
<span class="w">  </span><span class="nx">isLoading</span><span class="o">:</span><span class="w"> </span><span class="kr">boolean</span><span class="p">;</span>
<span class="w">  </span><span class="nx">error</span><span class="o">:</span><span class="w"> </span><span class="ne">Error</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Step 2: Make the custom hook generic.</span>
<span class="c1">// `useFetch&lt;T&gt;` introduces the generic type parameter `T`.</span>
<span class="k">export</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">useFetch</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">url</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="nx">FetchState</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">state</span><span class="p">,</span><span class="w"> </span><span class="nx">setState</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="o">&lt;</span><span class="nx">FetchState</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;&gt;</span><span class="p">({</span>
<span class="w">    </span><span class="nx">data</span><span class="o">:</span><span class="w"> </span><span class="kc">null</span><span class="p">,</span>
<span class="w">    </span><span class="nx">isLoading</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">    </span><span class="nx">error</span><span class="o">:</span><span class="w"> </span><span class="kc">null</span><span class="p">,</span>
<span class="w">  </span><span class="p">});</span>

<span class="w">  </span><span class="nx">useEffect</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Reset state for new URL</span>
<span class="w">    </span><span class="nx">setState</span><span class="p">({</span><span class="w"> </span><span class="nx">data</span><span class="o">:</span><span class="w"> </span><span class="kc">null</span><span class="p">,</span><span class="w"> </span><span class="nx">isLoading</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="nx">error</span><span class="o">:</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="p">});</span>

<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">fetchData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">const</span><span class="w"> </span><span class="nx">response</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nx">response</span><span class="p">.</span><span class="nx">ok</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="k">throw</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="ne">Error</span><span class="p">(</span><span class="sb">`HTTP error! status: </span><span class="si">${</span><span class="nx">response</span><span class="p">.</span><span class="nx">status</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="c1">// We assume the response is JSON and can be cast to `T`.</span>
<span class="w">        </span><span class="kd">const</span><span class="w"> </span><span class="nx">data</span><span class="o">:</span><span class="w"> </span><span class="nx">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">response</span><span class="p">.</span><span class="nx">json</span><span class="p">();</span>
<span class="w">        </span><span class="nx">setState</span><span class="p">({</span><span class="w"> </span><span class="nx">data</span><span class="p">,</span><span class="w"> </span><span class="nx">isLoading</span><span class="o">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="nx">error</span><span class="o">:</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="p">});</span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="nx">error</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">setState</span><span class="p">({</span><span class="w"> </span><span class="nx">data</span><span class="o">:</span><span class="w"> </span><span class="kc">null</span><span class="p">,</span><span class="w"> </span><span class="nx">isLoading</span><span class="o">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="nx">error</span><span class="o">:</span><span class="w"> </span><span class="nx">error</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="ne">Error</span><span class="w"> </span><span class="p">});</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="nx">fetchData</span><span class="p">();</span>
<span class="w">  </span><span class="p">},</span><span class="w"> </span><span class="p">[</span><span class="nx">url</span><span class="p">]);</span><span class="w"> </span><span class="c1">// Re-fetch when the URL changes.</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">state</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Now let's see how a component would consume this generic hook.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// --- USAGE ---</span>
<span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;react&#39;</span><span class="p">;</span>

<span class="c1">// Define the shape of the data we expect.</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">Post</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="nx">number</span><span class="p">;</span>
<span class="w">  </span><span class="nx">title</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">;</span>
<span class="w">  </span><span class="nx">body</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">PostViewer</span><span class="p">({</span><span class="w"> </span><span class="nx">postId</span><span class="w"> </span><span class="p">}</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">postId</span><span class="o">:</span><span class="w"> </span><span class="nx">number</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Step 3: Provide the generic type argument when calling the hook.</span>
<span class="w">  </span><span class="c1">// We tell `useFetch` that `T` is `Post`.</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">data</span><span class="p">,</span><span class="w"> </span><span class="nx">isLoading</span><span class="p">,</span><span class="w"> </span><span class="nx">error</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useFetch</span><span class="p">&lt;</span><span class="nt">Post</span><span class="p">&gt;(</span>
<span class="w">    </span><span class="sb">`https://jsonplaceholder.typicode.com/posts/</span><span class="si">${</span><span class="nx">postId</span><span class="si">}</span><span class="sb">`</span>
<span class="w">  </span><span class="p">);</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">isLoading</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span><span class="nx">Loading</span><span class="p">...&lt;/</span><span class="nt">p</span><span class="p">&gt;;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">error</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span><span class="ne">Error</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="nx">error</span><span class="p">.</span><span class="nx">message</span><span class="p">}&lt;/</span><span class="nt">p</span><span class="p">&gt;;</span>

<span class="w">  </span><span class="c1">// Because we provided `&lt;Post&gt;`, TypeScript knows `data` is `Post | null`.</span>
<span class="w">  </span><span class="c1">// After the loading/error checks, we can safely access `data.title`.</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;{</span><span class="nx">data</span><span class="o">?</span><span class="p">.</span><span class="nx">title</span><span class="p">}&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;{</span><span class="nx">data</span><span class="o">?</span><span class="p">.</span><span class="nx">body</span><span class="p">}&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>This pattern is incredibly powerful:</p>
<ol>
<li>The <code>useFetch</code> hook contains all the generic logic for fetching, loading, and error handling.</li>
<li>The <code>PostViewer</code> component is only concerned with its specific needs: what type of data it expects (<code>Post</code>) and how to render it.</li>
<li>By providing <code>&lt;Post&gt;</code> as the generic argument, we create a fully type-safe link between the hook and the component. <code>data</code> is correctly typed as <code>Post | null</code>, giving us autocompletion and safety.</li>
</ol>
<h2 id="deep-dive_6">Deep Dive</h2>
<h3 id="inferring-generics-from-parameters">Inferring Generics from Parameters</h3>
<p>Sometimes, TypeScript can infer the generic type from the hook's arguments, so you don't have to provide it explicitly. Let's create a generic <code>useLocalStorage</code> hook.</p>
<div class="codehilite"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">useState</span><span class="p">,</span><span class="w"> </span><span class="nx">useEffect</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;react&#39;</span><span class="p">;</span>

<span class="k">export</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">useLocalStorage</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">key</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">,</span><span class="w"> </span><span class="nx">initialValue</span><span class="o">:</span><span class="w"> </span><span class="nx">T</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="nx">T</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="nx">T</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ow">void</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">storedValue</span><span class="p">,</span><span class="w"> </span><span class="nx">setStoredValue</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kd">const</span><span class="w"> </span><span class="nx">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">window</span><span class="p">.</span><span class="nx">localStorage</span><span class="p">.</span><span class="nx">getItem</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="nx">item</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="nb">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">initialValue</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="nx">error</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="nx">initialValue</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">});</span>

<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">setValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="nx">T</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">setStoredValue</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
<span class="w">      </span><span class="nb">window</span><span class="p">.</span><span class="nx">localStorage</span><span class="p">.</span><span class="nx">setItem</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span><span class="w"> </span><span class="nb">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">value</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="nx">error</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">};</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">[</span><span class="nx">storedValue</span><span class="p">,</span><span class="w"> </span><span class="nx">setValue</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">// --- USAGE ---</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">Settings</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Here, we do NOT need to write `&lt;boolean&gt;`.</span>
<span class="w">    </span><span class="c1">// TypeScript infers that `T` is `boolean` because `initialValue` is `true`.</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">isDarkMode</span><span class="p">,</span><span class="w"> </span><span class="nx">setDarkMode</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useLocalStorage</span><span class="p">(</span><span class="s1">&#39;darkMode&#39;</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// `isDarkMode` is correctly typed as `boolean`.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">&lt;</span><span class="nx">button</span><span class="w"> </span><span class="nx">onClick</span><span class="o">=</span><span class="p">{()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">setDarkMode</span><span class="p">(</span><span class="o">!</span><span class="nx">isDarkMode</span><span class="p">)}</span><span class="o">&gt;</span><span class="nx">Toggle</span><span class="w"> </span><span class="nx">Dark</span><span class="w"> </span><span class="nx">Mode</span><span class="o">&lt;</span><span class="err">/button&gt;</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>When do you need to be explicit?</strong></p>
<ul>
<li><strong>Be explicit</strong> (<code>useFetch&lt;Post&gt;</code>) when the generic type only appears in the <em>return value</em> of the hook.</li>
<li><strong>Let it be inferred</strong> (<code>useLocalStorage('key', true)</code>) when the generic type is used in one of the hook's <em>parameters</em> (like <code>initialValue: T</code>).</li>
</ul>
<h3 id="production-perspective_6">Production Perspective</h3>
<ul>
<li><strong>Data Fetching Libraries</strong>: Professional data fetching libraries like React Query (<code>useQuery</code>) and SWR (<code>useSWR</code>) are built around this exact generic custom hook pattern. They add more advanced features like caching, revalidation, and mutations, but the core typing strategy is the same.</li>
<li><strong>Abstracting Logic</strong>: Generic custom hooks are the ultimate tool for abstracting away complex but reusable logic. Any time you find yourself writing similar stateful logic in multiple components, consider if it can be extracted into a generic custom hook.</li>
</ul>
<h2 id="hook-type-inference-best-practices">Hook Type Inference Best Practices</h2>
<h2 id="learning-objective_7">Learning Objective</h2>
<p>Synthesize best practices for leveraging TypeScript's type inference with hooks to write code that is clean, maintainable, and minimally annotated.</p>
<h2 id="why-this-matters_7">Why This Matters</h2>
<p>The goal of using TypeScript with React is not to add type annotations everywhere. It's to add them in strategic places to enable TypeScript's powerful inference engine to do most of the work for you. Following these best practices leads to code that is both safe and highly readable.</p>
<h2 id="discovery-phase_7">Discovery Phase</h2>
<p>Let's look at two versions of the same component. The first is "over-typed," with many redundant annotations. The second follows best practices, relying on inference.</p>
<div class="codehilite"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">useState</span><span class="p">,</span><span class="w"> </span><span class="nx">useCallback</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;react&#39;</span><span class="p">;</span>

<span class="c1">// Version 1: Over-typed and verbose</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">VerboseCounter</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Redundant: `number` is easily inferred from `0`.</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">count</span><span class="p">,</span><span class="w"> </span><span class="nx">setCount</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">&lt;</span><span class="nt">number</span><span class="p">&gt;(</span><span class="mf">0</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Redundant: The callback&#39;s type is easily inferred.</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">increment</span><span class="o">:</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ow">void</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useCallback</span><span class="p">(()</span><span class="o">:</span><span class="w"> </span><span class="ow">void</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Redundant: `c` is inferred as `number`.</span>
<span class="w">    </span><span class="nx">setCount</span><span class="p">((</span><span class="nx">c</span><span class="o">:</span><span class="w"> </span><span class="nx">number</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1</span><span class="p">);</span>
<span class="w">  </span><span class="p">},</span><span class="w"> </span><span class="p">[]);</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">button</span><span class="w"> </span><span class="na">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">increment</span><span class="p">}&gt;</span><span class="nx">Count</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="nx">count</span><span class="p">}&lt;/</span><span class="nt">button</span><span class="p">&gt;;</span>
<span class="p">}</span>

<span class="c1">// Version 2: Clean and inferred (Best Practice)</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">CleanCounter</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// `count` is inferred as `number`. Perfect.</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">count</span><span class="p">,</span><span class="w"> </span><span class="nx">setCount</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">(</span><span class="mf">0</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// `increment` is inferred as `() =&gt; void`. Perfect.</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">increment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useCallback</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// `c` is inferred as `number`. Perfect.</span>
<span class="w">    </span><span class="nx">setCount</span><span class="p">(</span><span class="nx">c</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1</span><span class="p">);</span>
<span class="w">  </span><span class="p">},</span><span class="w"> </span><span class="p">[]);</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">button</span><span class="w"> </span><span class="na">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">increment</span><span class="p">}&gt;</span><span class="nx">Count</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="nx">count</span><span class="p">}&lt;/</span><span class="nt">button</span><span class="p">&gt;;</span>
<span class="p">}</span>
</code></pre></div>

<p>Both components are equally type-safe. However, the second version is much cleaner and easier to read. It trusts TypeScript to do its job. Our goal is to write code that looks like the second version.</p>
<h2 id="deep-dive_7">Deep Dive</h2>
<h3 id="a-checklist-for-hook-typing">A Checklist for Hook Typing</h3>
<p>Here is a summary of the best practices we've learned, framed as a set of rules.</p>
<p><strong>1. <code>useState</code>:</strong></p>
<ul>
<li><strong>DO</strong> let the type be inferred from a non-empty initial value (<code>useState(0)</code>, <code>useState('hello')</code>, <code>useState({ a: 1 })</code>).</li>
<li><strong>DO</strong> provide an explicit generic when the initial value is <code>null</code>, <code>undefined</code>, or an empty array (<code>useState&lt;User | null&gt;(null)</code>, <code>useState&lt;Todo[]&gt;([])</code>).</li>
</ul>
<p><strong>2. <code>useReducer</code>:</strong></p>
<ul>
<li><strong>DO</strong> define explicit types for your <code>State</code> and your <code>Action</code> (preferably a discriminated union).</li>
<li><strong>DO</strong> type the parameters and return value of your reducer function.</li>
<li><strong>DON'T</strong> add generics to the <code>useReducer</code> call itself. Let it be inferred from the reducer.</li>
</ul>
<p><strong>3. <code>useContext</code>:</strong></p>
<ul>
<li><strong>DO</strong> provide an explicit generic to <code>createContext</code> (<code>createContext&lt;MyContextType | null&gt;(null)</code>).</li>
<li><strong>DON'T</strong> add types to the <code>useContext</code> call. Let it be inferred from the context object.</li>
<li><strong>DO</strong> create a custom hook to encapsulate the null check.</li>
</ul>
<p><strong>4. <code>useRef</code>:</strong></p>
<ul>
<li><strong>DO</strong> provide an explicit generic for DOM refs and initialize with <code>null</code> (<code>useRef&lt;HTMLInputElement&gt;(null)</code>).</li>
<li><strong>DO</strong> provide an explicit generic for mutable values if the initial value is not provided (<code>useRef&lt;number&gt;()</code>).</li>
<li><strong>DO</strong> let the type be inferred if providing a concrete initial value (<code>useRef(0)</code>).</li>
</ul>
<p><strong>5. <code>useCallback</code> &amp; <code>useMemo</code>:</strong></p>
<ul>
<li><strong>DON'T</strong> add explicit types to the hooks themselves. Let them be inferred from the function you pass in.</li>
</ul>
<p><strong>6. Custom Hooks:</strong></p>
<ul>
<li><strong>DO</strong> define explicit types for the hook's parameters and its return value. This is the "public API" of your hook.</li>
<li><strong>DON'T</strong> over-type the variables <em>inside</em> your custom hook. Let inference work there.</li>
</ul>
<h3 id="production-perspective_7">Production Perspective</h3>
<ul>
<li><strong>Type the Boundaries</strong>: The recurring theme is to <strong>type the boundaries</strong> of your logic. For components, the boundary is <code>props</code>. For hooks, it's the function signature (parameters and return value). For context, it's the <code>createContext</code> call. For reducers, it's the reducer function signature. If you type these boundaries correctly, inference can handle almost everything else.</li>
<li><strong>Readability Trumps Verbosity</strong>: The goal is code that is easy for humans to read and maintain. Redundant type annotations add noise and can make the code harder to follow. Trust the compiler and your editor's hover tooltips to know the inferred types.</li>
<li><strong>Configuration is Key</strong>: All of this relies on having a strict <code>tsconfig.json</code> (<code>"strict": true</code>). A strict configuration enables the compiler to catch more errors and perform more powerful inference, which in turn allows you to write cleaner, less annotated code.</li>
</ul>
<h2 id="module-synthesis">Module Synthesis üìã</h2>
<h2 id="module-synthesis_1">Module Synthesis</h2>
<p>In this chapter, we've taken a deep dive into the heart of a component's internal logic: its state. We have systematically covered how to apply TypeScript to React's core hooks, ensuring that the state driving our components is robust, predictable, and free from common type-related bugs.</p>
<p>We began with <strong><code>useState</code></strong>, learning the crucial distinction between relying on inference for simple cases and providing explicit generics for nullable or empty initial states. We then leveled up to <strong><code>useReducer</code></strong>, mastering the powerful pattern of using discriminated unions for actions to create fully type-safe state machines.</p>
<p>We explored how to manage shared state with <strong><code>useContext</code></strong>, establishing the best practice of creating a typed context, providing a <code>null</code> default, and wrapping it in a custom hook to ensure consumers are always within a provider. We clarified the dual nature of <strong><code>useRef</code></strong>, learning the distinct typing patterns for both DOM element access and mutable instance variables.</p>
<p>We also addressed the legacy optimization hooks, <strong><code>useCallback</code> and <code>useMemo</code></strong>, noting their diminished importance in the face of the React 19 Compiler but confirming how easily their types are inferred. Finally, we tied everything together by learning to write and type <strong>custom hooks</strong>, including powerful <strong>generic custom hooks</strong>, which represent the pinnacle of reusable, type-safe logic in React.</p>
<h2 id="looking-ahead">Looking Ahead</h2>
<p>You are now capable of managing state of any complexity within your React components in a fully type-safe manner. You can create reusable, encapsulated logic with custom hooks that are as robust as those from a professional library.</p>
<p>In the next chapter, <strong>Chapter 24: TypeScript with State Management</strong>, we will look beyond React's built-in hooks. We'll explore how to integrate TypeScript with popular external state management libraries. We'll cover typing Redux with Redux Toolkit, see the elegant simplicity of Zustand's type support, and revisit the Context API with more advanced patterns to create scalable, type-safe global state solutions for large applications.</p>
        </div>
        <div class="footer">
            Generated on 2025-10-25 16:27:48 | Made with ‚ù§Ô∏è by GitHub Pages Generator
        </div>
    </div>
    <script>
        // Syntax highlighting for code blocks
        document.addEventListener('DOMContentLoaded', (event) => {
            // Highlight code blocks
            document.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightElement(block);
            });
            
            // Add copy buttons to code blocks
            document.querySelectorAll('pre').forEach((pre) => {
                const button = document.createElement('button');
                button.className = 'copy-btn';
                button.textContent = 'Copy';
                
                button.addEventListener('click', () => {
                    const code = pre.querySelector('code').textContent;
                    navigator.clipboard.writeText(code).then(() => {
                        button.textContent = 'Copied!';
                        button.classList.add('copied');
                        setTimeout(() => {
                            button.textContent = 'Copy';
                            button.classList.remove('copied');
                        }, 2000);
                    }).catch(err => {
                        console.error('Failed to copy:', err);
                        button.textContent = 'Error';
                        setTimeout(() => {
                            button.textContent = 'Copy';
                        }, 2000);
                    });
                });
                
                pre.appendChild(button);
            });
        });
    </script>
</body>
</html>