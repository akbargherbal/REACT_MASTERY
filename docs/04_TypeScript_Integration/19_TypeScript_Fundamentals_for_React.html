<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>19_TypeScript_Fundamentals_for_React</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <style>
        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --secondary: #8b5cf6;
            --bg-main: #0f172a;
            --bg-card: #1e293b;
            --bg-code: #0f172a;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --border: #334155;
            --accent: #06b6d4;
            --success: #10b981;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            line-height: 1.7; 
            color: var(--text-primary); 
            background: var(--bg-main);
        }
        
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            padding: 20px; 
        }
        
        .home-btn { 
            position: fixed; 
            top: 20px; 
            right: 20px; 
            background: var(--accent);
            color: white; 
            width: 50px;
            height: 50px;
            border-radius: 50%;
            text-decoration: none; 
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(6, 182, 212, 0.4);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .home-btn:hover { 
            background: #0891b2;
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(6, 182, 212, 0.5);
        }
        
        .breadcrumb { 
            background: var(--bg-card);
            padding: 12px 0; 
            margin-bottom: 24px; 
            font-size: 14px;
            border-radius: 8px;
            border: 1px solid var(--border);
        }
        
        .breadcrumb a { 
            color: var(--accent);
            text-decoration: none;
            transition: color 0.2s;
        }
        
        .breadcrumb a:hover { 
            color: var(--primary);
            text-decoration: underline;
        }
        
        .content { 
            background: var(--bg-card);
            padding: 3rem; 
            border-radius: 16px; 
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border);
        }
        
        .file-list { 
            display: grid; 
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); 
            gap: 1.5rem; 
            margin: 2rem 0; 
        }
        
        .file-item { 
            padding: 1.5rem; 
            border: 1px solid var(--border);
            border-radius: 12px; 
            background: var(--bg-main);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .file-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .file-item:hover { 
            transform: translateY(-4px); 
            box-shadow: 0 8px 30px rgba(99, 102, 241, 0.3);
            border-color: var(--primary);
        }
        
        .file-item:hover::before {
            opacity: 1;
        }
        
        .file-item a { 
            color: var(--text-primary);
            text-decoration: none; 
            font-weight: 600; 
            display: block;
            font-size: 1.1rem;
        }
        
        .file-item a:hover { 
            color: var(--primary);
        }
        
        .file-type { 
            font-size: 13px; 
            color: var(--text-secondary);
            margin-top: 8px; 
            font-weight: 500;
        }
        
        /* Code Blocks */
        pre { 
            background: var(--bg-code);
            padding: 1.5rem; 
            border-radius: 12px; 
            overflow-x: auto;
            border: 1px solid var(--border);
            margin: 1.5rem 0;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            position: relative;
        }
        
        pre code { 
            background: none;
            padding: 0;
            font-family: 'Fira Code', 'Consolas', monospace;
            font-size: 0.9em;
            line-height: 1.6;
        }
        
        /* Copy Button */
        .copy-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: var(--primary);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
            opacity: 0.7;
            z-index: 10;
        }
        
        .copy-btn:hover {
            opacity: 1;
            background: var(--primary-dark);
            transform: translateY(-1px);
        }
        
        .copy-btn.copied {
            background: var(--success);
        }
        
        pre:hover .copy-btn {
            opacity: 1;
        }
        
        /* Inline Code */
        code { 
            background: var(--bg-code);
            color: #8b5cf6;
            padding: 3px 8px; 
            border-radius: 6px; 
            font-size: 1.1em;
            font-family: 'Fira Code', 'Consolas', monospace;
            border: 1px solid var(--border);
        }
        
        /* Headings */
        h1, h2, h3, h4, h5, h6 { 
            color: var(--text-primary);
            margin: 2rem 0 1rem 0;
            font-weight: 700;
            letter-spacing: -0.5px;
        }
        
        h1 { 
            font-size: 2.5rem;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            border-bottom: 3px solid var(--primary);
            padding-bottom: 12px;
            margin-bottom: 1.5rem;
        }
        
        h2 { 
            font-size: 2rem;
            color: var(--primary);
            border-bottom: 2px solid var(--border);
            padding-bottom: 8px;
        }
        
        h3 { 
            font-size: 1.5rem;
            color: var(--accent);
        }
        
        /* Links */
        a { 
            color: var(--accent);
            transition: color 0.2s;
        }
        
        a:hover { 
            color: var(--primary);
        }
        
        /* Paragraphs */
        p {
            margin: 1rem 0;
            color: var(--text-secondary);
        }
        
        /* Lists */
        ul, ol {
            margin: 1rem 0;
            padding-left: 2rem;
            color: var(--text-secondary);
        }
        
        li {
            margin: 0.5rem 0;
        }
        
        /* Tables */
        table { 
            border-collapse: collapse;
            width: 100%;
            margin: 1.5rem 0;
            background: var(--bg-main);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        
        th, td { 
            border: 1px solid var(--border);
            padding: 12px 16px;
            text-align: left;
        }
        
        th { 
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            font-weight: 600;
        }
        
        tr:hover {
            background: var(--bg-card);
        }
        
        /* Blockquotes */
        blockquote {
            border-left: 4px solid var(--primary);
            padding: 1rem 1.5rem;
            margin: 1.5rem 0;
            background: var(--bg-main);
            border-radius: 0 8px 8px 0;
            color: var(--text-secondary);
            font-style: italic;
        }
        
        /* Horizontal Rule */
        hr {
            border: none;
            border-top: 2px solid var(--border);
            margin: 2rem 0;
        }
        
        .footer { 
            text-align: center; 
            padding: 2rem; 
            color: var(--text-secondary);
            border-top: 1px solid var(--border);
            margin-top: 3rem; 
            font-size: 14px;
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--bg-main);
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 6px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary);
        }
        
        @media (max-width: 768px) {
            .container { padding: 10px; }
            .file-list { grid-template-columns: 1fr; }
            .content { padding: 1.5rem; }
            h1 { font-size: 2rem; }
            h2 { font-size: 1.5rem; }
        }
    </style>
</head>
<body>
    <a href="../index.html" class="home-btn">üè†</a>
    <div class="container">
        <div class="breadcrumb">
            <div style="padding: 0 20px;">
                <a href="../index.html">üè† Home</a> <span style="color: #64748b;">/</span> <a href="index.html">04_TypeScript_Integration</a>
            </div>
        </div>
        <div class="content">
            <h1 id="chapter-19-typescript-fundamentals-for-react">Chapter 19: TypeScript Fundamentals for React</h1>
<h2 id="why-typescript-with-react-19">Why TypeScript with React 19?</h2>
<h2 id="learning-objective">Learning Objective</h2>
<p>Understand the core benefits of using TypeScript in a modern React 19 application and why it's the industry standard for building robust, scalable projects.</p>
<h2 id="why-this-matters">Why This Matters</h2>
<p>As applications grow, JavaScript's dynamic nature can lead to bugs that are hard to track down. TypeScript acts as a "co-pilot," catching errors before your code even runs. In React 19, with powerful new features like Server Actions, this safety net becomes even more crucial for building reliable, maintainable applications.</p>
<h2 id="discovery-phase">Discovery Phase</h2>
<p>Let's start with a simple JavaScript React component that has a subtle bug.</p>
<p>Imagine a component that displays a user's name and age. In JavaScript, it might look like this:</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// FileName: UserProfile.jsx (Plain JavaScript)</span>
<span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;react&quot;</span><span class="p">;</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">UserProfile</span><span class="p">({</span><span class="w"> </span><span class="nx">user</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// What if user is null or user.age is missing?</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">birthYear</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Date</span><span class="p">().</span><span class="nx">getFullYear</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">user</span><span class="p">.</span><span class="nx">age</span><span class="p">;</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;{</span><span class="nx">user</span><span class="p">.</span><span class="nx">name</span><span class="p">}&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span><span class="nx">Born</span><span class="w"> </span><span class="ow">in</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="nx">birthYear</span><span class="p">}&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>

<span class="k">export</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">App</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">userData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Alice&quot;</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// Oops, forgot the age property!</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">UserProfile</span><span class="w"> </span><span class="na">user</span><span class="o">=</span><span class="p">{</span><span class="nx">userData</span><span class="p">}</span><span class="w"> </span><span class="p">/&gt;;</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>Rendered Output</strong>:</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// This will crash the application!</span>
<span class="n">TypeError</span><span class="p">:</span><span class="w"> </span><span class="n">Cannot</span><span class="w"> </span><span class="nb">read</span><span class="w"> </span><span class="k">properties</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">undefined</span><span class="w"> </span><span class="p">(</span><span class="n">reading</span><span class="w"> </span><span class="s">&#39;age&#39;</span><span class="p">)</span>
</code></pre></div>

<p>This component works perfectly if <code>user</code> has both <code>name</code> and <code>age</code>. But in our <code>App</code> component, we forgot to pass the <code>age</code>. A JavaScript app would crash at runtime, potentially showing a blank screen to the user. This is the kind of error that can easily slip through to production.</p>
<p>Now, let's see the exact same logic with TypeScript.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// FileName: UserProfile.tsx (TypeScript)</span>
<span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;react&quot;</span><span class="p">;</span>

<span class="c1">// We define the &quot;shape&quot; of the user object we expect.</span>
<span class="kr">interface</span><span class="w"> </span><span class="nx">User</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">;</span>
<span class="w">  </span><span class="nx">age</span><span class="o">:</span><span class="w"> </span><span class="nx">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// We &quot;annotate&quot; our props with this shape.</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">UserProfile</span><span class="p">({</span><span class="w"> </span><span class="nx">user</span><span class="w"> </span><span class="p">}</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">user</span><span class="o">:</span><span class="w"> </span><span class="nx">User</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">birthYear</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Date</span><span class="p">().</span><span class="nx">getFullYear</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">user</span><span class="p">.</span><span class="nx">age</span><span class="p">;</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;{</span><span class="nx">user</span><span class="p">.</span><span class="nx">name</span><span class="p">}&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span><span class="nx">Born</span><span class="w"> </span><span class="ow">in</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="nx">birthYear</span><span class="p">}&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>

<span class="k">export</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">App</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// TypeScript ERROR here!</span>
<span class="w">  </span><span class="c1">// Property &#39;age&#39; is missing in type &#39;{ name: string; }&#39;</span>
<span class="w">  </span><span class="c1">// but required in type &#39;User&#39;.</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">userData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Alice&quot;</span><span class="w"> </span><span class="p">};</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">UserProfile</span><span class="w"> </span><span class="na">user</span><span class="o">=</span><span class="p">{</span><span class="nx">userData</span><span class="p">}</span><span class="w"> </span><span class="p">/&gt;;</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>Development-Time Behavior</strong>:</p>
<p>Your code editor (like VS Code) will immediately show a red squiggly line under <code>userData</code> in the <code>App</code> component. The error message is crystal clear: you've violated the contract you defined. The bug is caught <em>before you even save the file</em>, let alone run the application.</p>
<p>This is the fundamental value proposition of TypeScript: shifting runtime errors to compile-time errors.</p>
<h2 id="deep-dive">Deep Dive</h2>
<p>TypeScript is a "superset" of JavaScript, meaning any valid JavaScript is technically valid TypeScript. It adds a powerful type system on top of JavaScript. This type system is completely erased during the "compilation" step‚Äîthe final code that runs in the browser is plain JavaScript. TypeScript's benefits are primarily for the developer during the development process.</p>
<p>Let's break down the key advantages in a React context:</p>
<ol>
<li><strong>Type Safety</strong>: As we saw, this prevents you from passing the wrong type of data to a component, calling non-existent functions, or accessing properties that might be <code>undefined</code>.</li>
<li><strong>Superior Autocompletion</strong>: When you type <code>user.</code> inside the <code>UserProfile</code> component, your editor instantly knows that <code>name</code> and <code>age</code> are the only available properties. This speeds up development and reduces reliance on documentation.</li>
<li><strong>Refactoring Confidence</strong>: Imagine you need to rename <code>age</code> to <code>userAge</code> across a large application. In TypeScript, you can use your editor's "Rename Symbol" feature, and it will safely update every usage. In JavaScript, a simple find-and-replace might accidentally change unrelated code.</li>
<li><strong>Self-Documenting Code</strong>: The type definitions themselves act as documentation. When another developer looks at <code>UserProfile</code>, they immediately know what <code>props</code> it expects without reading its implementation.</li>
<li><strong>Enhanced React 19 Support</strong>: New features like Server Actions involve data passing between the client and server. TypeScript ensures the data payloads on both ends match, preventing a whole class of network-related bugs.</li>
</ol>
<h3 id="common-confusion-typescript-is-just-for-large-teams">Common Confusion: "TypeScript is just for large teams."</h3>
<p><strong>You might think</strong>: "My project is small, TypeScript is just unnecessary boilerplate."</p>
<p><strong>Actually</strong>: The benefits of TypeScript scale down to even the smallest projects. The improved autocompletion and immediate error feedback accelerate development from day one. It establishes good habits and makes it trivial to scale the project later without a painful migration.</p>
<p><strong>Why the confusion happens</strong>: Early versions of TypeScript with React required more verbose setup. Modern tools like Vite make it a zero-configuration choice.</p>
<p><strong>How to remember</strong>: TypeScript isn't a burden; it's a co-pilot. It helps you write better code, faster, regardless of project size.</p>
<h3 id="production-perspective">Production Perspective</h3>
<p><strong>When professionals choose this</strong>:</p>
<ul>
<li><strong>Almost always</strong>. For any project intended for production, TypeScript is the default choice in the modern React ecosystem.</li>
<li><strong>Team Collaboration</strong>: It's non-negotiable for teams. Types create clear contracts between components and developers, reducing miscommunication.</li>
<li><strong>Long-Term Maintainability</strong>: A year from now, when you return to a codebase, types make it dramatically easier to understand what the code does and how to modify it safely.</li>
</ul>
<p><strong>Trade-offs</strong>:</p>
<ul>
<li>‚úÖ <strong>Advantage</strong>: Catches bugs early, leading to higher quality software.</li>
<li>‚úÖ <strong>Advantage</strong>: Drastically improves the developer experience (DX).</li>
<li>‚ö†Ô∏è <strong>Cost</strong>: A slight learning curve if you're coming from a purely dynamic language. You need to learn the basic syntax for defining types.</li>
<li>‚ö†Ô∏è <strong>Cost</strong>: Can sometimes require complex types for highly generic or flexible components, which can be challenging for beginners.</li>
</ul>
<p>In essence, you trade a small amount of upfront effort (defining types) for a massive reduction in debugging time and runtime errors later. It's a trade-off that overwhelmingly pays off.</p>
<h2 id="typescript-basics-refresher">TypeScript Basics Refresher</h2>
<h2 id="learning-objective_1">Learning Objective</h2>
<p>Review the fundamental TypeScript types and syntax that are most relevant for building React applications.</p>
<h2 id="why-this-matters_1">Why This Matters</h2>
<p>While TypeScript has a deep and powerful type system, you only need to know a handful of core concepts to be highly effective in React. This section provides a focused refresher on those essentials.</p>
<h2 id="discovery-phase_1">Discovery Phase</h2>
<p>Let's explore the basic building blocks of the TypeScript type system. We'll look at how to describe primitive values, arrays, and objects.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// FileName: types-examples.ts</span>

<span class="c1">// --- Primitive Types ---</span>
<span class="c1">// TypeScript can often infer the type from the value</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">framework</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;React&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Inferred as type &#39;string&#39;</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">version</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">19</span><span class="p">;</span><span class="w">       </span><span class="c1">// Inferred as type &#39;number&#39;</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">isAwesome</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">   </span><span class="c1">// Inferred as type &#39;boolean&#39;</span>

<span class="c1">// You can also be explicit, which is good for function parameters</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">pageTitle</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">;</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">userCount</span><span class="o">:</span><span class="w"> </span><span class="nx">number</span><span class="p">;</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">isLoading</span><span class="o">:</span><span class="w"> </span><span class="kr">boolean</span><span class="p">;</span>

<span class="c1">// Special primitive-like types</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">noValue</span><span class="o">:</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">notAssigned</span><span class="o">:</span><span class="w"> </span><span class="kc">undefined</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">undefined</span><span class="p">;</span>

<span class="c1">// --- Arrays ---</span>
<span class="c1">// Two common ways to type arrays. Both are equivalent.</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">versions</span><span class="o">:</span><span class="w"> </span><span class="nx">number</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="p">;</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">frameworks</span><span class="o">:</span><span class="w"> </span><span class="nb">Array</span><span class="o">&lt;</span><span class="nx">string</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s1">&#39;React&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;Vue&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;Svelte&#39;</span><span class="p">];</span>

<span class="c1">// --- Objects ---</span>
<span class="c1">// The most common way to describe an object is with an inline annotation</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">component</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">;</span><span class="w"> </span><span class="nx">props</span><span class="o">:</span><span class="w"> </span><span class="nx">object</span><span class="w"> </span><span class="p">};</span>
<span class="nx">component</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;UserProfile&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">props</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">userId</span><span class="o">:</span><span class="w"> </span><span class="mf">123</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">};</span>

<span class="c1">// We can make properties optional with a `?`</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">style</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">color</span><span class="o">?:</span><span class="w"> </span><span class="nx">string</span><span class="p">;</span><span class="w"> </span><span class="nx">fontSize</span><span class="o">?:</span><span class="w"> </span><span class="nx">number</span><span class="w"> </span><span class="p">};</span>
<span class="nx">style</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">color</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;blue&#39;</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// This is valid</span>
<span class="nx">style</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"> </span><span class="c1">// This is also valid</span>

<span class="c1">// --- Special Types: any, unknown, void ---</span>

<span class="c1">// `any`: The escape hatch. It opts out of type checking. AVOID THIS.</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">anything</span><span class="o">:</span><span class="w"> </span><span class="nx">any</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4</span><span class="p">;</span>
<span class="nx">anything</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;hello&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// No error</span>
<span class="nx">anything</span><span class="p">.</span><span class="nx">nonExistentMethod</span><span class="p">();</span><span class="w"> </span><span class="c1">// No error at compile time, but will crash at runtime!</span>

<span class="c1">// `unknown`: A safer alternative to `any`. You must check its type before using it.</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">maybeValue</span><span class="o">:</span><span class="w"> </span><span class="nx">unknown</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;I could be anything&#39;</span><span class="p">;</span>
<span class="c1">// console.log(maybeValue.length); // Error: Object is of type &#39;unknown&#39;.</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="ow">typeof</span><span class="w"> </span><span class="nx">maybeValue</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;string&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">maybeValue</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span><span class="w"> </span><span class="c1">// OK, TypeScript now knows it&#39;s a string.</span>
<span class="p">}</span>

<span class="c1">// `void`: Used for functions that do not return a value.</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">logMessage</span><span class="p">(</span><span class="nx">message</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="ow">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">message</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// No return statement</span>
<span class="p">}</span>
</code></pre></div>

<p>This code snippet demonstrates the core syntax. The key takeaway is the <code>: Type</code> annotation that follows a variable or parameter name. This tells TypeScript what kind of value to expect, enabling it to help you.</p>
<h2 id="deep-dive_1">Deep Dive</h2>
<h3 id="type-inference-your-smart-assistant">Type Inference: Your Smart Assistant</h3>
<p>One of TypeScript's best features is its ability to infer types.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// No type annotation needed here</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">myName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;Alice&quot;</span><span class="p">;</span>
</code></pre></div>

<p>Here, TypeScript sees you've assigned a string literal to <code>myName</code>. It automatically infers that <code>myName</code> is of type <code>string</code>. From this point on, it will enforce that type.</p>
<div class="codehilite"><pre><span></span><code><span class="nx">myName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">123</span><span class="p">;</span><span class="w"> </span><span class="c1">// Error: Type &#39;number&#39; is not assignable to type &#39;string&#39;.</span>
</code></pre></div>

<p><strong>When should you rely on inference vs. being explicit?</strong></p>
<ul>
<li><strong>Rely on inference</strong> for variables within a function's scope. It keeps code clean.</li>
<li><strong>Be explicit</strong> for function parameters and return values. This creates a clear "contract" for what the function does, which is crucial for reusability and clarity.</li>
</ul>
<p>Let's look at a function:</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// Explicit annotations for function boundaries</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">createGreeting</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">,</span><span class="w"> </span><span class="nx">isExcited</span><span class="o">:</span><span class="w"> </span><span class="kr">boolean</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="nx">greeting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sb">`Hello, </span><span class="si">${</span><span class="nx">name</span><span class="si">}</span><span class="sb">!`</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">isExcited</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// `greeting` is inferred as a string, no need to annotate it here</span>
<span class="w">    </span><span class="nx">greeting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">greeting</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">greeting</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Here, we are explicit about the inputs (<code>name: string</code>, <code>isExcited: boolean</code>) and the output (<code>: string</code>). This is a best practice. Inside the function, we let TypeScript infer the type of the <code>greeting</code> variable.</p>
<h3 id="common-confusion-null-vs-undefined">Common Confusion: <code>null</code> vs. <code>undefined</code></h3>
<p><strong>You might think</strong>: <code>null</code> and <code>undefined</code> are basically the same thing.</p>
<p><strong>Actually</strong>: In TypeScript (and modern JavaScript), they represent different concepts.</p>
<ul>
<li><code>undefined</code>: A variable has been declared but not yet assigned a value. It's the default state.</li>
<li><code>null</code>: A value was explicitly assigned to be "nothing" or "empty." It's an intentional absence of a value.</li>
</ul>
<p><strong>Why the confusion happens</strong>: In JavaScript, they often behave similarly (e.g., <code>null == undefined</code> is true).</p>
<p><strong>How to remember</strong>: Think of <code>undefined</code> as "uninitialized" and <code>null</code> as "intentionally empty." In React, you might initialize a state that will hold fetched data as <code>null</code>: <code>const [user, setUser] = useState&lt;User | null&gt;(null);</code>. This clearly signals that the data is not there yet, but we expect it to be an object of type <code>User</code> eventually.</p>
<h3 id="production-perspective_1">Production Perspective</h3>
<ul>
<li><strong>Avoid <code>any</code> at all costs</strong>. Using <code>any</code> is like turning off TypeScript for that variable. It defeats the purpose of using TypeScript in the first place. If you're migrating a JavaScript codebase, you might use it temporarily, but the goal should always be to eliminate it.</li>
<li><strong>Prefer <code>unknown</code> over <code>any</code></strong>. When you truly don't know the type of a value (e.g., data from an API response), use <code>unknown</code>. It forces you to perform type-checking before you can use the value, making your code safer.</li>
<li><strong>Strict Mode is Your Friend</strong>. In your <code>tsconfig.json</code>, always enable <code>"strict": true</code>. This turns on a suite of checks (like <code>strictNullChecks</code>) that prevent common errors, such as assuming a value is present when it could be <code>null</code> or <code>undefined</code>.</li>
</ul>
<h2 id="setting-up-typescript-in-react-19-projects">Setting Up TypeScript in React 19 Projects</h2>
<h2 id="learning-objective_2">Learning Objective</h2>
<p>Create a new React 19 project with TypeScript using Vite and understand the key configuration files.</p>
<h2 id="why-this-matters_2">Why This Matters</h2>
<p>A proper setup is the foundation for a good developer experience. Modern tools like Vite make starting a TypeScript React project incredibly simple, allowing you to focus on building your application rather than wrestling with configuration.</p>
<h2 id="discovery-phase_2">Discovery Phase</h2>
<p>The recommended way to start a new React project is with a build tool like Vite. It's fast, modern, and has first-class TypeScript support.</p>
<p>To create a new project, open your terminal and run this command:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># npm</span>
npm<span class="w"> </span>create<span class="w"> </span>vite@latest<span class="w"> </span>my-react-ts-app<span class="w"> </span>--<span class="w"> </span>--template<span class="w"> </span>react-ts

<span class="c1"># yarn</span>
yarn<span class="w"> </span>create<span class="w"> </span>vite<span class="w"> </span>my-react-ts-app<span class="w"> </span>--template<span class="w"> </span>react-ts

<span class="c1"># pnpm</span>
pnpm<span class="w"> </span>create<span class="w"> </span>vite<span class="w"> </span>my-react-ts-app<span class="w"> </span>--template<span class="w"> </span>react-ts
</code></pre></div>

<p>This command will scaffold a new directory named <code>my-react-ts-app</code> with a minimal, ready-to-run React and TypeScript setup.</p>
<p>Let's navigate into the project and see what was created:</p>
<div class="codehilite"><pre><span></span><code><span class="nb">cd</span><span class="w"> </span>my-react-ts-app
npm<span class="w"> </span>install
npm<span class="w"> </span>run<span class="w"> </span>dev
</code></pre></div>

<p>Your new React application is now running! Notice the file extensions: <code>.tsx</code> instead of <code>.jsx</code>. The <code>x</code> signifies that the file contains JSX syntax.</p>
<h3 id="key-files">Key Files</h3>
<ol>
<li><strong><code>main.tsx</code></strong>: The entry point of your application.</li>
<li><strong><code>App.tsx</code></strong>: Your root React component.</li>
<li><strong><code>tsconfig.json</code></strong>: The TypeScript compiler configuration file. This is the most important file for our purposes.</li>
</ol>
<p>Let's look at a simplified <code>App.tsx</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// FileName: src/App.tsx</span>
<span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">useState</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;react&quot;</span><span class="p">;</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">App</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">count</span><span class="p">,</span><span class="w"> </span><span class="nx">setCount</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">(</span><span class="mf">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// count is inferred as `number`</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span><span class="nx">Welcome</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">React</span><span class="w"> </span><span class="kd">with</span><span class="w"> </span><span class="nx">TypeScript</span><span class="o">!</span><span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">button</span><span class="w"> </span><span class="na">onClick</span><span class="o">=</span><span class="p">{()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">setCount</span><span class="p">((</span><span class="nx">c</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1</span><span class="p">)}&gt;</span><span class="nx">Count</span><span class="w"> </span><span class="nx">is</span><span class="w"> </span><span class="p">{</span><span class="nx">count</span><span class="p">}&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>

<span class="k">export</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="nx">App</span><span class="p">;</span>
</code></pre></div>

<p>Notice how little has changed from a JavaScript version. The <code>useState</code> hook automatically infers that <code>count</code> is a <code>number</code> because we initialized it with <code>0</code>. If you were to try <code>setCount('hello')</code>, TypeScript would immediately give you an error.</p>
<h2 id="deep-dive_2">Deep Dive</h2>
<h3 id="understanding-tsconfigjson">Understanding <code>tsconfig.json</code></h3>
<p>This file tells the TypeScript compiler how to behave. The template from Vite provides excellent defaults. Let's look at a few key options:</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// FileName: tsconfig.json (simplified)</span>
<span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;compilerOptions&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;target&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;ES2020&quot;</span><span class="p">,</span><span class="w"> </span><span class="c1">// Compile to modern JavaScript</span>
<span class="w">    </span><span class="nt">&quot;useDefineForClassFields&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;lib&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;ES2020&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;DOM&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;DOM.Iterable&quot;</span><span class="p">],</span>
<span class="w">    </span><span class="nt">&quot;module&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;ESNext&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;skipLibCheck&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>

<span class="w">    </span><span class="cm">/* Bundler mode */</span>
<span class="w">    </span><span class="nt">&quot;moduleResolution&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;bundler&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;allowImportingTsExtensions&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;resolveJsonModule&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;isolatedModules&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;noEmit&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="c1">// Vite handles emitting files, TypeScript only does type checking</span>
<span class="w">    </span><span class="nt">&quot;jsx&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;react-jsx&quot;</span><span class="p">,</span><span class="w"> </span><span class="c1">// Use the modern JSX transform</span>

<span class="w">    </span><span class="cm">/* Linting */</span>
<span class="w">    </span><span class="nt">&quot;strict&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="c1">// Enable all strict type-checking options</span>
<span class="w">    </span><span class="nt">&quot;noUnusedLocals&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;noUnusedParameters&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;noFallthroughCasesInSwitch&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="nt">&quot;include&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;src&quot;</span><span class="p">],</span><span class="w"> </span><span class="c1">// Only check files in the `src` directory</span>
<span class="w">  </span><span class="nt">&quot;references&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="w"> </span><span class="nt">&quot;path&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;./tsconfig.node.json&quot;</span><span class="w"> </span><span class="p">}]</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="key-tsconfigjson-properties-explained">Key <code>tsconfig.json</code> Properties Explained</h3>
<ul>
<li><strong><code>"jsx": "react-jsx"</code></strong>: This is the modern standard. It means you no longer need to <code>import React from 'react'</code> in every file just to use JSX.</li>
<li><strong><code>"strict": true"</code></strong>: This is the most important setting. It's a shorthand for enabling a family of strict type-checking rules. Without this, TypeScript is far less effective. It forces you to handle cases where a value might be <code>null</code> or <code>undefined</code>, preventing a huge category of runtime errors.</li>
<li><strong><code>"noEmit": true"</code></strong>: This might seem strange. It tells TypeScript <em>not</em> to produce any JavaScript output files. Why? Because Vite (or another bundler) is responsible for that. We are using TypeScript purely for its static analysis and type-checking capabilities. The bundler transpiles the <code>.tsx</code> files into browser-ready JavaScript.</li>
<li><strong><code>"include": ["src"]</code></strong>: This tells TypeScript to only analyze files within the <code>src</code> folder, ignoring <code>node_modules</code> and other build artifacts.</li>
</ul>
<h3 id="common-confusion-ts-vs-tsx">Common Confusion: <code>.ts</code> vs. <code>.tsx</code></h3>
<p><strong>You might think</strong>: I should just use <code>.tsx</code> for all my files.</p>
<p><strong>Actually</strong>: You should use the extension that matches the file's content.</p>
<ul>
<li>Use <strong><code>.tsx</code></strong> for any file that contains JSX syntax (e.g., React components).</li>
<li>Use <strong><code>.ts</code></strong> for plain TypeScript files that do not contain any JSX (e.g., utility functions, type definitions, API logic).</li>
</ul>
<p><strong>Why the confusion happens</strong>: It's tempting to simplify and use one extension everywhere.</p>
<p><strong>How to remember</strong>: If you see <code>&lt;</code> or <code>&gt;</code> tags that are part of your UI, it needs to be a <code>.tsx</code> file. Sticking to this convention makes it clear which files are related to rendering and which are pure logic.</p>
<h3 id="production-perspective_2">Production Perspective</h3>
<ul>
<li><strong>Start with the official templates</strong>: Always use the official <code>react-ts</code> template from Vite or <code>create-next-app</code>. They are maintained by experts and provide a battle-tested configuration.</li>
<li><strong>Keep <code>"strict": true</code></strong>: It might feel annoying at first when TypeScript complains about potential <code>null</code> values, but this discipline will save you countless hours of debugging. Learning to write code that satisfies strict mode is a key step to becoming a professional React developer.</li>
<li><strong>Integrate with ESLint</strong>: The Vite template comes with ESLint configured for TypeScript. This adds another layer of code quality checks, catching stylistic issues and potential bugs that even the TypeScript compiler might miss.</li>
</ul>
<h2 id="type-annotations-and-inference">Type Annotations and Inference</h2>
<h2 id="learning-objective_3">Learning Objective</h2>
<p>Distinguish between explicit type annotations and implicit type inference, and learn when to use each for writing clean and robust code.</p>
<h2 id="why-this-matters_3">Why This Matters</h2>
<p>Understanding the balance between letting TypeScript infer types and explicitly defining them is key to writing code that is both safe and readable. Over-annotating clutters your code, while under-annotating can hide potential bugs.</p>
<h2 id="discovery-phase_3">Discovery Phase</h2>
<p>We've already seen type inference in action. Let's make the distinction crystal clear with a side-by-side comparison.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// Version 1: Explicit Annotations</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">calculateTotal</span><span class="p">(</span><span class="nx">price</span><span class="o">:</span><span class="w"> </span><span class="nx">number</span><span class="p">,</span><span class="w"> </span><span class="nx">quantity</span><span class="o">:</span><span class="w"> </span><span class="nx">number</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="nx">number</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">total</span><span class="o">:</span><span class="w"> </span><span class="nx">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">price</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">quantity</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">total</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Version 2: Using Type Inference</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">calculateTotalWithInference</span><span class="p">(</span><span class="nx">price</span><span class="o">:</span><span class="w"> </span><span class="nx">number</span><span class="p">,</span><span class="w"> </span><span class="nx">quantity</span><span class="o">:</span><span class="w"> </span><span class="nx">number</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="nx">number</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// `total` is automatically inferred to be of type `number`</span>
<span class="w">  </span><span class="c1">// because the result of `number * number` is always a `number`.</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">total</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">price</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">quantity</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">total</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Both functions are equally type-safe. TypeScript understands that <code>total</code> in the second version must be a number. The second version is cleaner and less redundant.</p>
<p>The key principle is this: <strong>Annotate your function boundaries (parameters and return values), and let TypeScript infer the rest.</strong></p>
<p>Think of a function as a public contract. By annotating its inputs and output, you make its behavior predictable and easy to use for other developers (and your future self). What happens <em>inside</em> the function is an implementation detail where inference is usually sufficient.</p>
<p>Let's see a React component example:</p>
<div class="codehilite"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;react&quot;</span><span class="p">;</span>

<span class="c1">// --- ANNOTATE PROPS ---</span>
<span class="c1">// This is a function boundary, so we are explicit.</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">ButtonProps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">label</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">,</span>
<span class="w">  </span><span class="nx">onClick</span><span class="o">:</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ow">void</span><span class="p">,</span><span class="w"> </span><span class="c1">// A function that takes no arguments and returns nothing.</span>
<span class="w">  </span><span class="nx">disabled</span><span class="o">?:</span><span class="w"> </span><span class="kr">boolean</span><span class="p">,</span><span class="w"> </span><span class="c1">// An optional boolean prop.</span>
<span class="p">};</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">Button</span><span class="p">({</span><span class="w"> </span><span class="nx">label</span><span class="p">,</span><span class="w"> </span><span class="nx">onClick</span><span class="p">,</span><span class="w"> </span><span class="nx">disabled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="p">}</span><span class="o">:</span><span class="w"> </span><span class="nx">ButtonProps</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// --- INFER INSIDE THE COMPONENT ---</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">buttonText</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">label</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">();</span><span class="w"> </span><span class="c1">// Inferred as `string`</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">isDisabled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">disabled</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Inferred as `boolean`</span>

<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">handleClick</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">event</span><span class="o">:</span><span class="w"> </span><span class="nx">React</span><span class="p">.</span><span class="nx">MouseEvent</span><span class="p">&lt;</span><span class="nt">HTMLButtonElement</span><span class="p">&gt;)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// We annotate the event type, which React provides for us.</span>
<span class="w">    </span><span class="c1">// This gives us autocomplete for properties like `event.currentTarget`.</span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;Button clicked!&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="nx">onClick</span><span class="p">();</span>
<span class="w">  </span><span class="p">};</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">button</span><span class="w"> </span><span class="na">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">handleClick</span><span class="p">}</span><span class="w"> </span><span class="na">disabled</span><span class="o">=</span><span class="p">{</span><span class="nx">isDisabled</span><span class="p">}&gt;</span>
<span class="w">      </span><span class="p">{</span><span class="nx">buttonText</span><span class="p">}</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>In this <code>Button</code> component:</p>
<ol>
<li>We <strong>explicitly</strong> define the <code>ButtonProps</code> type. This is the component's public API.</li>
<li>Inside the component, <code>buttonText</code> and <code>isDisabled</code> have their types <strong>inferred</strong>.</li>
<li>For event handlers, we <strong>explicitly</strong> type the <code>event</code> object. React exports helpful types like <code>React.MouseEvent</code> for every possible event. This is a crucial pattern for correctly handling events.</li>
</ol>
<h2 id="deep-dive_3">Deep Dive</h2>
<h3 id="where-inference-shines">Where Inference Shines</h3>
<ul>
<li><strong>Simple variables</strong>: <code>const name = 'React';</code></li>
<li><strong><code>useState</code></strong>: <code>const [count, setCount] = useState(0);</code> - TypeScript knows <code>count</code> is a <code>number</code> and <code>setCount</code> is <code>React.Dispatch&lt;React.SetStateAction&lt;number&gt;&gt;</code>.</li>
<li><strong><code>useRef</code></strong>: <code>const inputRef = useRef&lt;HTMLInputElement&gt;(null);</code> - Here we give a "generic argument" to tell TypeScript what kind of element the ref will hold.</li>
<li><strong>Chained methods</strong>: <code>const names = users.map(u =&gt; u.name).filter(n =&gt; n.length &gt; 5);</code> - TypeScript can trace the type through the entire chain, knowing that <code>names</code> is <code>string[]</code>.</li>
</ul>
<h3 id="where-annotations-are-essential">Where Annotations are Essential</h3>
<ul>
<li><strong>Function parameters and return values</strong>: As discussed, this is the most important place to be explicit.</li>
<li><strong>Object literals when the type can't be fully inferred</strong>: If you create an empty object that will be populated later, you must tell TypeScript its shape.
  <code>typescript
  type User = { name: string; id: number };
  const user: User = {}; // Error: Property 'name' and 'id' are missing.
  // This forces you to initialize objects with the required shape.</code></li>
<li><strong>Complex types</strong>: When a function returns a complex object or union type, annotating the return type can improve error messages and clarity, even if TypeScript could infer it.</li>
</ul>
<h3 id="common-confusion-why-do-i-need-to-type-the-event-object">Common Confusion: "Why do I need to type the event object?"</h3>
<p><strong>You might think</strong>: "JavaScript events just work, why is <code>event: React.MouseEvent</code> necessary?"</p>
<p><strong>Actually</strong>: By typing the event, you get type safety and autocompletion on all event properties. React's event system is a synthetic wrapper around the browser's native events, and <code>@types/react</code> provides precise types for them.</p>
<p><strong>Why the confusion happens</strong>: In plain JS, you might <code>console.log(event)</code> to see what properties are available. TypeScript gives you this information upfront.</p>
<p><strong>How to remember</strong>: For any <code>on...</code> prop in JSX, hover over it in your editor. It will show you the exact function signature required, including the event type. For <code>onClick</code> on a <code>&lt;button&gt;</code>, it's <code>(event: React.MouseEvent&lt;HTMLButtonElement&gt;) =&gt; void</code>.</p>
<h3 id="production-perspective_3">Production Perspective</h3>
<ul>
<li><strong>Team Consistency</strong>: Establish a team convention for when to use annotations vs. inference. The "annotate function boundaries" rule is a solid, widely-accepted standard.</li>
<li><strong>Readability is Key</strong>: The goal is not just to satisfy the compiler, but to make the code easier for humans to read. If adding an annotation makes the code's intent clearer, add it. If it's just repeating what's obvious from the assigned value, omit it.</li>
<li><strong>Leverage Editor Tooling</strong>: Modern editors can often automatically add type annotations for you. They can also display the inferred type of any variable when you hover over it, which is a great way to learn and debug.</li>
</ul>
<h2 id="interfaces-vs-types">Interfaces vs Types</h2>
<h2 id="learning-objective_4">Learning Objective</h2>
<p>Understand the similarities and differences between <code>interface</code> and <code>type</code> in TypeScript and establish a consistent convention for use in React projects.</p>
<h2 id="why-this-matters_4">Why This Matters</h2>
<p>Both <code>interface</code> and <code>type</code> can be used to describe the shape of objects, and the choice between them can be confusing for newcomers. Knowing the subtle differences and choosing a consistent approach will make your codebase cleaner and more predictable.</p>
<h2 id="discovery-phase_4">Discovery Phase</h2>
<p>Let's define the props for a component using both <code>interface</code> and <code>type</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// FileName: definitions.ts</span>

<span class="c1">// --- Using `interface` ---</span>
<span class="c1">// Describes the shape of an object.</span>
<span class="kr">interface</span><span class="w"> </span><span class="nx">UserCardPropsInterface</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">;</span>
<span class="w">  </span><span class="nx">age</span><span class="o">:</span><span class="w"> </span><span class="nx">number</span><span class="p">;</span>
<span class="w">  </span><span class="nx">isActive</span><span class="o">:</span><span class="w"> </span><span class="kr">boolean</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// --- Using `type` ---</span>
<span class="c1">// Can also describe the shape of an object.</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">UserCardPropsType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">,</span>
<span class="w">  </span><span class="nx">age</span><span class="o">:</span><span class="w"> </span><span class="nx">number</span><span class="p">,</span>
<span class="w">  </span><span class="nx">isActive</span><span class="o">:</span><span class="w"> </span><span class="kr">boolean</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// In this simple case, they are functionally identical.</span>
<span class="c1">// You can use them to type component props interchangeably.</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">UserCard</span><span class="p">(</span><span class="nx">props</span><span class="o">:</span><span class="w"> </span><span class="nx">UserCardPropsInterface</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="cm">/* ... */</span>
<span class="p">}</span>
<span class="c1">// OR</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">UserCard</span><span class="p">(</span><span class="nx">props</span><span class="o">:</span><span class="w"> </span><span class="nx">UserCardPropsType</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="cm">/* ... */</span>
<span class="p">}</span>
</code></pre></div>

<p>As you can see, for defining the shape of component props, <code>interface</code> and <code>type</code> look almost identical. So what's the difference?</p>
<p>The primary differences lie in two areas: how they are extended, and what other kinds of types they can represent.</p>
<h3 id="extending">Extending</h3>
<p>Interfaces can be extended using the <code>extends</code> keyword. Types can be extended using an intersection (<code>&amp;</code>).</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// Extending an interface</span>
<span class="kr">interface</span><span class="w"> </span><span class="nx">BaseProps</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">interface</span><span class="w"> </span><span class="nx">AdminUserCardProps</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nx">BaseProps</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">permissions</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">[];</span>
<span class="p">}</span>
<span class="c1">// AdminUserCardProps now has `id`, and `permissions`.</span>

<span class="c1">// Extending a type with an intersection</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">BaseType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">,</span>
<span class="p">};</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">AdminUserCardType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">BaseType</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">permissions</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">[],</span>
<span class="p">};</span>
<span class="c1">// AdminUserCardType also has `id` and `permissions`.</span>
</code></pre></div>

<p>Again, for this common use case, they achieve the same result with slightly different syntax. The more significant difference is a feature of interfaces called "declaration merging."</p>
<h3 id="declaration-merging">Declaration Merging</h3>
<p>An interface can be defined multiple times in the same scope, and TypeScript will merge them into a single definition. This is not possible with <code>type</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="kr">interface</span><span class="w"> </span><span class="nx">Merged</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// This is allowed. TypeScript merges them.</span>
<span class="kr">interface</span><span class="w"> </span><span class="nx">Merged</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">age</span><span class="o">:</span><span class="w"> </span><span class="nx">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">user</span><span class="o">:</span><span class="w"> </span><span class="nx">Merged</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Alice&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nx">age</span><span class="o">:</span><span class="w"> </span><span class="mf">30</span><span class="p">,</span><span class="w"> </span><span class="c1">// Both properties are required</span>
<span class="p">};</span>
</code></pre></div>

<p>This feature is useful when augmenting types from third-party libraries, but it's less common in everyday application code and can sometimes lead to confusion.</p>
<h3 id="flexibility-of-type">Flexibility of <code>type</code></h3>
<p>The <code>type</code> keyword is more versatile. It can define not just object shapes, but also unions, tuples, and other complex types.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// A union of string literals (impossible with `interface`)</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">Status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;loading&quot;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s2">&quot;success&quot;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s2">&quot;error&quot;</span><span class="p">;</span>

<span class="c1">// A function signature (impossible with `interface`)</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">ClickHandler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="nx">number</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ow">void</span><span class="p">;</span>

<span class="c1">// A tuple (impossible with `interface`)</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">Point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="nx">number</span><span class="p">,</span><span class="w"> </span><span class="nx">number</span><span class="p">];</span>
</code></pre></div>

<h2 id="deep-dive_4">Deep Dive</h2>
<h3 id="so-which-one-should-you-use">So, Which One Should You Use?</h3>
<p>There is no single "correct" answer, and the React community itself is divided. However, here is a pragmatic recommendation:</p>
<p><strong>Use <code>type</code> by default, and use <code>interface</code> when you need its specific features.</strong></p>
<p><strong>Why <code>type</code> by default?</strong></p>
<ol>
<li><strong>Consistency</strong>: Since <code>type</code> can do everything <code>interface</code> can do for object shapes, <em>plus</em> define unions, tuples, etc., using it everywhere provides a single, consistent way to define types in your application.</li>
<li><strong>Clarity</strong>: <code>type</code> is more explicit. Intersections (<code>&amp;</code>) make it very clear where you are combining types, whereas an <code>interface</code> might have been extended in another file via declaration merging, which can be harder to trace.</li>
<li><strong>Better with Complex Types</strong>: When you start using utility types like <code>Pick</code> or <code>Omit</code>, they work with <code>type</code> aliases naturally.</li>
</ol>
<p><strong>When to use <code>interface</code>?</strong></p>
<ol>
<li><strong>Declaration Merging</strong>: If you are a library author or need to augment a global type (like the <code>window</code> object) or a module from <code>node_modules</code>, <code>interface</code> is the tool for the job.</li>
<li><strong>Team Convention</strong>: If you join a team that uses <code>interface</code> for all object shapes, stick to that convention. Consistency within a project is more important than the <code>type</code> vs. <code>interface</code> debate.</li>
</ol>
<h3 id="common-confusion-interfaces-are-better-for-performance">Common Confusion: "Interfaces are better for performance."</h3>
<p><strong>You might think</strong>: "I heard interfaces are faster because they are 'lazily evaluated'."</p>
<p><strong>Actually</strong>: This is a myth in the context of application development. Any performance difference between <code>type</code> and <code>interface</code> is negligible and only affects the TypeScript compiler's internal workings, not your application's runtime performance.</p>
<p><strong>Why the confusion happens</strong>: Nuanced discussions about compiler internals can sometimes be misinterpreted as practical advice for application developers.</p>
<p><strong>How to remember</strong>: Choose based on consistency and features, not on performance. Your choice will have zero impact on how fast your React app runs.</p>
<h3 id="production-perspective_4">Production Perspective</h3>
<ul>
<li><strong>Establish a Linting Rule</strong>: The most important thing is consistency. Use ESLint to enforce the chosen convention. The <code>@typescript-eslint/consistent-type-definitions</code> rule can be set to enforce either <code>type</code> or <code>interface</code>.</li>
<li><strong>Example: Props for a component</strong></li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="c1">// Recommended approach using `type`</span>
<span class="k">export</span><span class="w"> </span><span class="kr">type</span><span class="w"> </span><span class="nx">UserProfileProps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">userId</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">;</span>
<span class="w">  </span><span class="nx">onFollow</span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="nx">userId</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ow">void</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">export</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">UserProfile</span><span class="p">(</span><span class="nx">props</span><span class="o">:</span><span class="w"> </span><span class="kt">UserProfileProps</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>

<ul>
<li><strong>Clarity is King</strong>: The goal is to make your code as easy to understand as possible. For most React developers, <code>type</code> offers a slightly more straightforward and versatile toolset.</li>
</ul>
<h2 id="union-and-intersection-types">Union and Intersection Types</h2>
<h2 id="learning-objective_5">Learning Objective</h2>
<p>Use union (<code>|</code>) and intersection (<code>&amp;</code>) types to create flexible and composable component APIs.</p>
<h2 id="why-this-matters_5">Why This Matters</h2>
<p>Real-world components are rarely simple. They often need to handle different states or combine different sets of properties. Union and intersection types are the fundamental tools TypeScript provides for modeling this complexity in a safe and expressive way.</p>
<h2 id="discovery-phase_5">Discovery Phase</h2>
<h3 id="union-types">Union Types (<code>|</code>)</h3>
<p>A union type allows a variable to be one of several possible types. This is incredibly useful for props that can only accept a specific set of string values, often called "discriminated unions."</p>
<p>Let's build a <code>StatusBadge</code> component. The status can be <code>'loading'</code>, <code>'success'</code>, or <code>'error'</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;react&quot;</span><span class="p">;</span>

<span class="c1">// Define a union type for the status prop.</span>
<span class="c1">// This acts like an enum and prevents typos.</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">Status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;loading&quot;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s2">&quot;success&quot;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s2">&quot;error&quot;</span><span class="p">;</span>

<span class="nx">type</span><span class="w"> </span><span class="nx">StatusBadgeProps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">status</span><span class="o">:</span><span class="w"> </span><span class="nx">Status</span><span class="p">,</span>
<span class="p">};</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">StatusBadge</span><span class="p">({</span><span class="w"> </span><span class="nx">status</span><span class="w"> </span><span class="p">}</span><span class="o">:</span><span class="w"> </span><span class="nx">StatusBadgeProps</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="nx">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;grey&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">status</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s2">&quot;success&quot;</span><span class="p">)</span><span class="w"> </span><span class="nx">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;green&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">status</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s2">&quot;error&quot;</span><span class="p">)</span><span class="w"> </span><span class="nx">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;red&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">status</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s2">&quot;loading&quot;</span><span class="p">)</span><span class="w"> </span><span class="nx">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;blue&quot;</span><span class="p">;</span>

<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">style</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">padding</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;8px&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nx">borderRadius</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;4px&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nx">color</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;white&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nx">backgroundColor</span><span class="o">:</span><span class="w"> </span><span class="nx">color</span><span class="p">,</span>
<span class="w">  </span><span class="p">};</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">span</span><span class="w"> </span><span class="na">style</span><span class="o">=</span><span class="p">{</span><span class="nx">style</span><span class="p">}&gt;{</span><span class="nx">status</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">()}&lt;/</span><span class="nt">span</span><span class="p">&gt;;</span>
<span class="p">}</span>

<span class="k">export</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">App</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">div</span><span class="w"> </span><span class="na">style</span><span class="o">=</span><span class="p">{{</span><span class="w"> </span><span class="nx">display</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;flex&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">gap</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;10px&quot;</span><span class="w"> </span><span class="p">}}&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">StatusBadge</span><span class="w"> </span><span class="na">status</span><span class="o">=</span><span class="s">&quot;success&quot;</span><span class="w"> </span><span class="p">/&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">StatusBadge</span><span class="w"> </span><span class="na">status</span><span class="o">=</span><span class="s">&quot;loading&quot;</span><span class="w"> </span><span class="p">/&gt;</span>
<span class="w">      </span><span class="p">{</span><span class="cm">/* &lt;StatusBadge status=&quot;pending&quot; /&gt; */</span><span class="p">}</span>
<span class="w">      </span><span class="p">{</span><span class="cm">/* The line above would cause a TypeScript error:</span>
<span class="cm">          Type &#39;&quot;pending&quot;&#39; is not assignable to type &#39;Status&#39;.</span>
<span class="cm">      */</span><span class="p">}</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>Rendered Output</strong>:</p>
<div class="codehilite"><pre><span></span><code><span class="k">[SUCCESS] [LOADING]</span>
<span class="na">(Styled with green and blue backgrounds respectively)</span>
</code></pre></div>

<p>The union type <code>Status</code> ensures that it's impossible to pass an invalid status string to the <code>StatusBadge</code> component. This prevents a common class of bugs and provides excellent autocompletion for developers using the component.</p>
<h3 id="intersection-types">Intersection Types (<code>&amp;</code>)</h3>
<p>An intersection type combines multiple types into one. This is useful for extending existing types or composing different sets of props.</p>
<p>Let's create a <code>Button</code> component that has basic styling props, and an <code>IconButton</code> that has all the button props <em>plus</em> an icon prop.</p>
<div class="codehilite"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;react&quot;</span><span class="p">;</span>

<span class="nx">type</span><span class="w"> </span><span class="nx">BaseButtonProps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">onClick</span><span class="o">:</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ow">void</span><span class="p">,</span>
<span class="w">  </span><span class="nx">children</span><span class="o">:</span><span class="w"> </span><span class="nx">React</span><span class="p">.</span><span class="nx">ReactNode</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// IconProps defines the shape for icon-related props</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">IconProps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">icon</span><span class="o">:</span><span class="w"> </span><span class="nx">React</span><span class="p">.</span><span class="nx">ReactElement</span><span class="p">,</span><span class="w"> </span><span class="c1">// e.g., &lt;IconComponent /&gt;</span>
<span class="w">  </span><span class="nx">iconPosition</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;left&quot;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s2">&quot;right&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// An IconButton has all the BaseButtonProps AND all the IconProps</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">IconButtonProps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">BaseButtonProps</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nx">IconProps</span><span class="p">;</span>

<span class="c1">// A regular button component</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">Button</span><span class="p">({</span><span class="w"> </span><span class="nx">onClick</span><span class="p">,</span><span class="w"> </span><span class="nx">children</span><span class="w"> </span><span class="p">}</span><span class="o">:</span><span class="w"> </span><span class="nx">BaseButtonProps</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">button</span><span class="w"> </span><span class="na">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">onClick</span><span class="p">}&gt;{</span><span class="nx">children</span><span class="p">}&lt;/</span><span class="nt">button</span><span class="p">&gt;;</span>
<span class="p">}</span>

<span class="c1">// An icon button component using the intersection type</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">IconButton</span><span class="p">({</span>
<span class="w">  </span><span class="nx">onClick</span><span class="p">,</span>
<span class="w">  </span><span class="nx">children</span><span class="p">,</span>
<span class="w">  </span><span class="nx">icon</span><span class="p">,</span>
<span class="w">  </span><span class="nx">iconPosition</span><span class="p">,</span>
<span class="p">}</span><span class="o">:</span><span class="w"> </span><span class="nx">IconButtonProps</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">button</span>
<span class="w">      </span><span class="na">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">onClick</span><span class="p">}</span>
<span class="w">      </span><span class="na">style</span><span class="o">=</span><span class="p">{{</span><span class="w"> </span><span class="nx">display</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;flex&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">alignItems</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;center&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">gap</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;8px&quot;</span><span class="w"> </span><span class="p">}}</span>
<span class="w">    </span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">{</span><span class="nx">iconPosition</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s2">&quot;left&quot;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">icon</span><span class="p">}</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">span</span><span class="p">&gt;{</span><span class="nx">children</span><span class="p">}&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">{</span><span class="nx">iconPosition</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s2">&quot;right&quot;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">icon</span><span class="p">}</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Example usage</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">MyIcon</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">span</span><span class="p">&gt;</span><span class="err">‚≠ê</span><span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;;</span>

<span class="k">export</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">App</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">IconButton</span>
<span class="w">      </span><span class="na">onClick</span><span class="o">=</span><span class="p">{()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">alert</span><span class="p">(</span><span class="s2">&quot;Clicked!&quot;</span><span class="p">)}</span>
<span class="w">      </span><span class="na">icon</span><span class="o">=</span><span class="p">{&lt;</span><span class="nt">MyIcon</span><span class="w"> </span><span class="p">/&gt;}</span>
<span class="w">      </span><span class="na">iconPosition</span><span class="o">=</span><span class="s">&quot;left&quot;</span>
<span class="w">    </span><span class="p">&gt;</span>
<span class="w">      </span><span class="nx">Submit</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">IconButton</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>Rendered Output</strong>:</p>
<div class="codehilite"><pre><span></span><code>[‚≠ê Submit] (A button with an icon and text)
</code></pre></div>

<p>By using an intersection (<code>&amp;</code>), we created a new type <code>IconButtonProps</code> that is guaranteed to have all the properties of <code>BaseButtonProps</code> and <code>IconProps</code>. This is a clean, reusable way to build up complex component APIs without duplicating type definitions.</p>
<h2 id="deep-dive_5">Deep Dive</h2>
<h3 id="discriminated-unions">Discriminated Unions</h3>
<p>A powerful pattern that combines union types with object shapes is the "discriminated union." This is where you have a common property (the "discriminant") that TypeScript can use to figure out the shape of the rest of the object.</p>
<p>Let's model an API request state.</p>
<div class="codehilite"><pre><span></span><code><span class="nx">type</span><span class="w"> </span><span class="nx">LoadingState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">status</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;loading&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="nx">type</span><span class="w"> </span><span class="nx">SuccessState</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">status</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;success&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nx">data</span><span class="o">:</span><span class="w"> </span><span class="nx">T</span><span class="p">,</span><span class="w"> </span><span class="c1">// Generic data type</span>
<span class="p">};</span>

<span class="nx">type</span><span class="w"> </span><span class="nx">ErrorState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">status</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;error&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nx">error</span><span class="o">:</span><span class="w"> </span><span class="ne">Error</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// A union of all possible states</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">ApiState</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">LoadingState</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">SuccessState</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">ErrorState</span><span class="p">;</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">DataDisplay</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">({</span><span class="w"> </span><span class="nx">state</span><span class="w"> </span><span class="p">}</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">state</span><span class="o">:</span><span class="w"> </span><span class="nx">ApiState</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// TypeScript&#39;s control flow analysis is key here.</span>
<span class="w">  </span><span class="c1">// Inside each `if` block, TypeScript &quot;narrows&quot; the type of `state`.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">state</span><span class="p">.</span><span class="nx">status</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s2">&quot;loading&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="nx">Loading</span><span class="p">...</span><span class="o">&lt;</span><span class="err">/div&gt;;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">state</span><span class="p">.</span><span class="nx">status</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s2">&quot;error&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="ne">Error</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="nx">state</span><span class="p">.</span><span class="nx">error</span><span class="p">.</span><span class="nx">message</span><span class="p">}</span><span class="o">&lt;</span><span class="err">/div&gt;;</span>
<span class="w">    </span><span class="c1">// `state.data` would be an error here.</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// If we reach here, TypeScript knows state.status MUST be &#39;success&#39;.</span>
<span class="w">  </span><span class="c1">// So it allows us to safely access `state.data`.</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="o">&lt;</span><span class="nx">pre</span><span class="o">&gt;</span><span class="p">{</span><span class="nb">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">state</span><span class="p">.</span><span class="nx">data</span><span class="p">)}</span><span class="o">&lt;</span><span class="err">/pre&gt;;</span>
<span class="p">}</span>
</code></pre></div>

<p>This pattern is extremely robust. The <code>status</code> property acts as the discriminant. When you check <code>state.status</code>, TypeScript is smart enough to know which other properties are available on the <code>state</code> object within that code block. This makes it impossible to access <code>data</code> when the state is <code>error</code>, or <code>error</code> when the state is <code>success</code>.</p>
<h3 id="common-confusion-vs-extends">Common Confusion: <code>&amp;</code> vs <code>extends</code></h3>
<p><strong>You might think</strong>: "Intersection (<code>&amp;</code>) with <code>type</code> and <code>extends</code> with <code>interface</code> are the same."</p>
<p><strong>Actually</strong>: They are very similar for simple cases, but can behave differently with overlapping properties. If two combined types have a property with the same name but different types, <code>intersection</code> will create an impossible type (<code>string &amp; number</code>), while <code>extends</code> will raise an error.</p>
<p><strong>Why the confusion happens</strong>: Their basic use case (combining object shapes) is identical.</p>
<p><strong>How to remember</strong>: Think of <code>&amp;</code> as "AND" - the resulting type must satisfy <em>both</em> original types. Think of <code>extends</code> as inheritance - a more specialized version of a base type. For component props, their behavior is usually what you'd expect from either.</p>
<h3 id="production-perspective_5">Production Perspective</h3>
<ul>
<li><strong>Use Union Types for State Machines</strong>: Discriminated unions are the gold standard for modeling component state, especially when dealing with data fetching (<code>loading</code>, <code>success</code>, <code>error</code>). This is far superior to using multiple boolean flags like <code>isLoading</code> and <code>isError</code>, which can lead to impossible states (e.g., <code>isLoading = true</code> and <code>isError = true</code>).</li>
<li><strong>Use Intersections for Composition</strong>: Use <code>&amp;</code> to build complex prop types from smaller, reusable pieces. This aligns with React's philosophy of composition. You can have <code>ClickableProps</code>, <code>StylableProps</code>, <code>FormInputProps</code>, and combine them as needed for different components.</li>
<li><strong>Avoid Overly Complex Unions/Intersections</strong>: While powerful, deeply nested or wide union/intersection types can make error messages hard to read. If a type becomes too complex, consider refactoring your component's API to be simpler.</li>
</ul>
<h2 id="generics-fundamentals">Generics Fundamentals</h2>
<h2 id="learning-objective_6">Learning Objective</h2>
<p>Use TypeScript generics to create reusable, type-safe components and functions that can work with a variety of data types.</p>
<h2 id="why-this-matters_6">Why This Matters</h2>
<p>Hard-coding types for every component is not scalable. Generics allow you to write components that are flexible and reusable, like a <code>List</code> component that can render a list of users, products, or anything else, all while maintaining full type safety.</p>
<h2 id="discovery-phase_6">Discovery Phase</h2>
<p>Imagine we want to build a <code>List</code> component. A naive implementation might be typed to only work with an array of strings.</p>
<div class="codehilite"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;react&quot;</span><span class="p">;</span>

<span class="c1">// Version 1: Not reusable. Only works for strings.</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">StringListProps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">items</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">[],</span>
<span class="p">};</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">StringList</span><span class="p">({</span><span class="w"> </span><span class="nx">items</span><span class="w"> </span><span class="p">}</span><span class="o">:</span><span class="w"> </span><span class="nx">StringListProps</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">ul</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">{</span><span class="nx">items</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">item</span><span class="p">,</span><span class="w"> </span><span class="nx">index</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">(</span>
<span class="w">        </span><span class="p">&lt;</span><span class="nt">li</span><span class="w"> </span><span class="na">key</span><span class="o">=</span><span class="p">{</span><span class="nx">index</span><span class="p">}&gt;{</span><span class="nx">item</span><span class="p">}&lt;/</span><span class="nt">li</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">))}</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">ul</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>This works, but what if we want to render a list of numbers? Or a list of user objects? We would have to create <code>NumberList</code> and <code>UserList</code> components, duplicating logic. This is where generics come in.</p>
<p>A generic is a placeholder for a type. We use angle brackets <code>&lt;T&gt;</code> to introduce a type variable, often called <code>T</code> by convention (for "Type").</p>
<p>Let's create a generic <code>List</code> component.</p>
<div class="codehilite"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;react&quot;</span><span class="p">;</span>

<span class="c1">// Version 2: Generic and Reusable!</span>
<span class="c1">// We introduce a generic type parameter `T`.</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">ListProps</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">items</span><span class="o">:</span><span class="w"> </span><span class="nx">T</span><span class="p">[],</span><span class="w"> </span><span class="c1">// `items` is an array of whatever type `T` is.</span>
<span class="w">  </span><span class="nx">renderItem</span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="nx">item</span><span class="o">:</span><span class="w"> </span><span class="nx">T</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">React</span><span class="p">.</span><span class="nx">ReactNode</span><span class="p">,</span><span class="w"> </span><span class="c1">// A function to render one item of type `T`.</span>
<span class="p">};</span>

<span class="c1">// The component itself is also generic.</span>
<span class="k">export</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">List</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;({</span><span class="w"> </span><span class="nx">items</span><span class="p">,</span><span class="w"> </span><span class="nx">renderItem</span><span class="w"> </span><span class="p">}</span><span class="o">:</span><span class="w"> </span><span class="nx">ListProps</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">ul</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">{</span><span class="nx">items</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">item</span><span class="p">,</span><span class="w"> </span><span class="nx">index</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">(</span>
<span class="w">        </span><span class="c1">// The key should ideally be a unique property of the item, not the index.</span>
<span class="w">        </span><span class="c1">// We&#39;ll cover this in more detail in other chapters.</span>
<span class="w">        </span><span class="p">&lt;</span><span class="nt">li</span><span class="w"> </span><span class="na">key</span><span class="o">=</span><span class="p">{</span><span class="nx">index</span><span class="p">}&gt;{</span><span class="nx">renderItem</span><span class="p">(</span><span class="nx">item</span><span class="p">)}&lt;/</span><span class="nt">li</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">))}</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">ul</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// --- USAGE ---</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">products</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Laptop&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">price</span><span class="o">:</span><span class="w"> </span><span class="mf">1200</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Mouse&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">price</span><span class="o">:</span><span class="w"> </span><span class="mf">50</span><span class="w"> </span><span class="p">},</span>
<span class="p">];</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">users</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="mf">101</span><span class="p">,</span><span class="w"> </span><span class="nx">username</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;alice&quot;</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="mf">102</span><span class="p">,</span><span class="w"> </span><span class="nx">username</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;bob&quot;</span><span class="w"> </span><span class="p">},</span>
<span class="p">];</span>

<span class="k">export</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">App</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">h2</span><span class="p">&gt;</span><span class="nx">Products</span><span class="p">&lt;/</span><span class="nt">h2</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">List</span>
<span class="w">        </span><span class="na">items</span><span class="o">=</span><span class="p">{</span><span class="nx">products</span><span class="p">}</span>
<span class="w">        </span><span class="na">renderItem</span><span class="o">=</span><span class="p">{(</span><span class="nx">product</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">(</span>
<span class="w">          </span><span class="c1">// `product` is correctly inferred as { id: number, name: string, price: number }</span>
<span class="w">          </span><span class="p">&lt;</span><span class="nt">span</span><span class="p">&gt;</span>
<span class="w">            </span><span class="p">{</span><span class="nx">product</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">$</span><span class="p">{</span><span class="nx">product</span><span class="p">.</span><span class="nx">price</span><span class="p">}</span>
<span class="w">          </span><span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
<span class="w">        </span><span class="p">)}</span>
<span class="w">      </span><span class="p">/&gt;</span>

<span class="w">      </span><span class="p">&lt;</span><span class="nt">h2</span><span class="p">&gt;</span><span class="nx">Users</span><span class="p">&lt;/</span><span class="nt">h2</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">List</span>
<span class="w">        </span><span class="na">items</span><span class="o">=</span><span class="p">{</span><span class="nx">users</span><span class="p">}</span>
<span class="w">        </span><span class="na">renderItem</span><span class="o">=</span><span class="p">{(</span><span class="nx">user</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">(</span>
<span class="w">          </span><span class="c1">// `user` is correctly inferred as { id: number, username: string }</span>
<span class="w">          </span><span class="p">&lt;</span><span class="nt">strong</span><span class="p">&gt;{</span><span class="nx">user</span><span class="p">.</span><span class="nx">username</span><span class="p">}&lt;/</span><span class="nt">strong</span><span class="p">&gt;</span>
<span class="w">        </span><span class="p">)}</span>
<span class="w">      </span><span class="p">/&gt;</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>Rendered Output</strong>:</p>
<div class="codehilite"><pre><span></span><code>Products
- Laptop - $1200
- Mouse - $50

Users
- alice
- bob
</code></pre></div>

<p>This is a huge improvement!</p>
<ol>
<li>We defined <code>ListProps&lt;T&gt;</code> and <code>List&lt;T&gt;</code> with a generic type parameter <code>T</code>.</li>
<li>When we use <code>&lt;List items={products} ... /&gt;</code>, TypeScript infers that <code>T</code> is of type <code>{ id: number, name: string, price: number }</code>.</li>
<li>Because of this inference, inside the <code>renderItem</code> function, the <code>product</code> parameter is fully typed, giving us autocompletion for <code>.name</code> and <code>.price</code>.</li>
<li>The same logic applies to the <code>users</code> list. We have one component that is completely type-safe for any kind of data we pass to it.</li>
</ol>
<h2 id="deep-dive_6">Deep Dive</h2>
<h3 id="generic-constraints">Generic Constraints</h3>
<p>Sometimes, you need to ensure that the generic type <code>T</code> has a certain shape. For example, our <code>List</code> component uses the array index as a <code>key</code>, which is not ideal. A better key would be a unique <code>id</code> property on each item. We can enforce this with a generic constraint.</p>
<div class="codehilite"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;react&#39;</span><span class="p">;</span>

<span class="c1">// We constrain `T` to be an object that MUST have an `id` property of type string or number.</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">ListItem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">number</span><span class="w"> </span><span class="p">};</span>

<span class="nx">type</span><span class="w"> </span><span class="nx">BetterListProps</span><span class="p">&lt;</span><span class="nt">T</span><span class="w"> </span><span class="na">extends</span><span class="w"> </span><span class="na">ListItem</span><span class="p">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">items</span><span class="o">:</span><span class="w"> </span><span class="nx">T</span><span class="p">[];</span>
<span class="w">  </span><span class="nx">renderItem</span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="nx">item</span><span class="o">:</span><span class="w"> </span><span class="nx">T</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">React</span><span class="p">.</span><span class="nx">ReactNode</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">export</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">BetterList</span><span class="p">&lt;</span><span class="nt">T</span><span class="w"> </span><span class="na">extends</span><span class="w"> </span><span class="na">ListItem</span><span class="p">&gt;({</span><span class="w"> </span><span class="nx">items</span><span class="p">,</span><span class="w"> </span><span class="nx">renderItem</span><span class="w"> </span><span class="p">}</span><span class="o">:</span><span class="w"> </span><span class="nx">BetterListProps</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">ul</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">{</span><span class="nx">items</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">item</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">(</span>
<span class="w">        </span><span class="c1">// Now we can safely use item.id as the key!</span>
<span class="w">        </span><span class="p">&lt;</span><span class="nt">li</span><span class="w"> </span><span class="na">key</span><span class="o">=</span><span class="p">{</span><span class="nx">item</span><span class="p">.</span><span class="nx">id</span><span class="p">}&gt;{</span><span class="nx">renderItem</span><span class="p">(</span><span class="nx">item</span><span class="p">)}&lt;/</span><span class="nt">li</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">))}</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">ul</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// --- USAGE ---</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">products</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Laptop&#39;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">];</span><span class="w"> </span><span class="c1">// This works</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">users</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;u1&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">username</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;alice&#39;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">];</span><span class="w"> </span><span class="c1">// This also works</span>

<span class="c1">// const invalidItems = [ { name: &#39;No ID here&#39; } ]; // This would cause a TypeScript error!</span>
<span class="c1">// Error: Property &#39;id&#39; is missing.</span>
<span class="c1">//</span>
</code></pre></div>

<p>By writing <code>&lt;T extends { id: string | number }&gt;</code>, we are telling TypeScript: "<code>T</code> can be any type, as long as it has an <code>id</code> property that is a string or a number." This allows us to safely access <code>item.id</code> inside our component, making it more robust.</p>
<h3 id="generics-in-hooks">Generics in Hooks</h3>
<p>Generics are also commonly used with hooks like <code>useState</code> and <code>useRef</code> when the type cannot be inferred from the initial value.</p>
<div class="codehilite"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">useState</span><span class="p">,</span><span class="w"> </span><span class="nx">useRef</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;react&quot;</span><span class="p">;</span>

<span class="nx">type</span><span class="w"> </span><span class="nx">User</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">,</span><span class="w"> </span><span class="nx">email</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="w"> </span><span class="p">};</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">UserProfile</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// We explicitly tell useState that this state can be User or null.</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">user</span><span class="p">,</span><span class="w"> </span><span class="nx">setUser</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">useState</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">User</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="kc">null</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="kc">null</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// We tell useRef what kind of DOM element it will be attached to.</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">emailInputRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useRef</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">HTMLInputElement</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span>

<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">fetchUser</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// In a real app, this would be an API call</span>
<span class="w">    </span><span class="nx">setUser</span><span class="p">({</span><span class="w"> </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Jane Doe&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">email</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;jane@example.com&quot;</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="p">};</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nx">user</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">button</span><span class="w"> </span><span class="na">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">fetchUser</span><span class="p">}&gt;</span><span class="nx">Load</span><span class="w"> </span><span class="nx">User</span><span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;{</span><span class="nx">user</span><span class="p">.</span><span class="nx">name</span><span class="p">}&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">input</span><span class="w"> </span><span class="na">ref</span><span class="o">=</span><span class="p">{</span><span class="nx">emailInputRef</span><span class="p">}</span><span class="w"> </span><span class="na">type</span><span class="o">=</span><span class="s">&quot;email&quot;</span><span class="w"> </span><span class="na">defaultValue</span><span class="o">=</span><span class="p">{</span><span class="nx">user</span><span class="p">.</span><span class="nx">email</span><span class="p">}</span><span class="w"> </span><span class="p">/&gt;</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>Without <code>&lt;User | null&gt;</code>, <code>useState(null)</code> would infer the type as <code>null</code>, and we would never be able to set it to a <code>User</code> object. The generic argument provides the necessary information to TypeScript.</p>
<h3 id="production-perspective_6">Production Perspective</h3>
<ul>
<li><strong>Identify Reusable Logic</strong>: When you find yourself writing similar components or functions for different data types, that's a prime candidate for a generic.</li>
<li><strong>Render Props Pattern</strong>: The <code>renderItem</code> prop in our <code>List</code> component is an example of the "Render Props" pattern. Generics make this pattern fully type-safe and powerful.</li>
<li><strong>Custom Hooks</strong>: Generics are essential for writing reusable custom hooks. A <code>useFetch&lt;T&gt;(url: string)</code> hook, for example, could use a generic <code>T</code> to represent the type of the expected API data.</li>
</ul>
<h2 id="utility-types-overview">Utility Types Overview</h2>
<h2 id="learning-objective_7">Learning Objective</h2>
<p>Leverage TypeScript's built-in utility types like <code>Partial</code>, <code>Pick</code>, <code>Omit</code>, and <code>Record</code> to manipulate and create new types without redundant definitions.</p>
<h2 id="why-this-matters_7">Why This Matters</h2>
<p>In large React applications, you often need to create variations of your base types. For example, the props for a user creation form might be different from the props for a user display card. Utility types let you derive these variations in a clean, maintainable, and type-safe way.</p>
<h2 id="discovery-phase_7">Discovery Phase</h2>
<p>Let's start with a base <code>User</code> type and see how we can use utility types to adapt it for different scenarios.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// Our base type</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">User</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="nx">number</span><span class="p">,</span>
<span class="w">  </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">,</span>
<span class="w">  </span><span class="nx">email</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">,</span>
<span class="w">  </span><span class="nx">isAdmin</span><span class="o">:</span><span class="w"> </span><span class="kr">boolean</span><span class="p">,</span>
<span class="w">  </span><span class="nx">createdAt</span><span class="o">:</span><span class="w"> </span><span class="nb">Date</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div>

<h3 id="partialt"><code>Partial&lt;T&gt;</code></h3>
<p><code>Partial&lt;T&gt;</code> makes all properties of <code>T</code> optional. This is perfect for an update form, where a user might only change one field at a time.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// Makes all properties of User optional</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">UserUpdatePayload</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">Partial</span><span class="o">&lt;</span><span class="nx">User</span><span class="o">&gt;</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm">Equivalent to:</span>
<span class="cm">type UserUpdatePayload = {</span>
<span class="cm">  id?: number;</span>
<span class="cm">  name?: string;</span>
<span class="cm">  email?: string;</span>
<span class="cm">  isAdmin?: boolean;</span>
<span class="cm">  createdAt?: Date;</span>
<span class="cm">}</span>
<span class="cm">*/</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">updateUser</span><span class="p">(</span><span class="nx">userId</span><span class="o">:</span><span class="w"> </span><span class="nx">number</span><span class="p">,</span><span class="w"> </span><span class="nx">payload</span><span class="o">:</span><span class="w"> </span><span class="nx">UserUpdatePayload</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// ... logic to send update to the server</span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`Updating user </span><span class="si">${</span><span class="nx">userId</span><span class="si">}</span><span class="sb"> with:`</span><span class="p">,</span><span class="w"> </span><span class="nx">payload</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// All of these are valid calls:</span>
<span class="nx">updateUser</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Alice Smith&quot;</span><span class="w"> </span><span class="p">});</span>
<span class="nx">updateUser</span><span class="p">(</span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">isAdmin</span><span class="o">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="nx">email</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;bob@new.com&quot;</span><span class="w"> </span><span class="p">});</span>
</code></pre></div>

<h3 id="pickt-k"><code>Pick&lt;T, K&gt;</code></h3>
<p><code>Pick&lt;T, K&gt;</code> creates a new type by picking a set of properties <code>K</code> from <code>T</code>. This is useful for creating smaller components that only need a subset of data.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// Our base type</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">User</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="nx">number</span><span class="p">,</span>
<span class="w">  </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">,</span>
<span class="w">  </span><span class="nx">email</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">,</span>
<span class="w">  </span><span class="nx">isAdmin</span><span class="o">:</span><span class="w"> </span><span class="kr">boolean</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// Creates a new type with only &#39;name&#39; and &#39;email&#39; from User</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">UserContactInfo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">Pick</span><span class="o">&lt;</span><span class="nx">User</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;name&quot;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s2">&quot;email&quot;</span><span class="o">&gt;</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm">Equivalent to:</span>
<span class="cm">type UserContactInfo = {</span>
<span class="cm">  name: string;</span>
<span class="cm">  email: string;</span>
<span class="cm">}</span>
<span class="cm">*/</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">UserEmailer</span><span class="p">({</span><span class="w"> </span><span class="nx">user</span><span class="w"> </span><span class="p">}</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">user</span><span class="o">:</span><span class="w"> </span><span class="nx">UserContactInfo</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="o">&lt;</span><span class="nx">a</span><span class="w"> </span><span class="nx">href</span><span class="o">=</span><span class="p">{</span><span class="sb">`mailto:</span><span class="si">${</span><span class="nx">user</span><span class="p">.</span><span class="nx">email</span><span class="si">}</span><span class="sb">`</span><span class="p">}</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">user</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="o">&lt;</span><span class="err">/a&gt;;</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="omitt-k"><code>Omit&lt;T, K&gt;</code></h3>
<p><code>Omit&lt;T, K&gt;</code> is the opposite of <code>Pick</code>. It creates a new type by removing a set of properties <code>K</code> from <code>T</code>. This is great for creating a new user, where properties like <code>id</code> and <code>createdAt</code> are generated by the server.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// Our base type</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">User</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="nx">number</span><span class="p">,</span>
<span class="w">  </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">,</span>
<span class="w">  </span><span class="nx">email</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">,</span>
<span class="w">  </span><span class="nx">isAdmin</span><span class="o">:</span><span class="w"> </span><span class="kr">boolean</span><span class="p">,</span>
<span class="w">  </span><span class="nx">createdAt</span><span class="o">:</span><span class="w"> </span><span class="nb">Date</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// Creates a new type by removing &#39;id&#39; and &#39;createdAt&#39; from User</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">NewUserPayload</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">Omit</span><span class="o">&lt;</span><span class="nx">User</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;id&quot;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s2">&quot;createdAt&quot;</span><span class="o">&gt;</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm">Equivalent to:</span>
<span class="cm">type NewUserPayload = {</span>
<span class="cm">  name: string;</span>
<span class="cm">  email: string;</span>
<span class="cm">  isAdmin: boolean;</span>
<span class="cm">}</span>
<span class="cm">*/</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">createUser</span><span class="p">(</span><span class="nx">data</span><span class="o">:</span><span class="w"> </span><span class="nx">NewUserPayload</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// ... logic to send new user to the server</span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;Creating user:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">createUser</span><span class="p">({</span><span class="w"> </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Charlie&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">email</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;charlie@example.com&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">isAdmin</span><span class="o">:</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="p">});</span>
</code></pre></div>

<h3 id="recordk-t"><code>Record&lt;K, T&gt;</code></h3>
<p><code>Record&lt;K, T&gt;</code> creates an object type where the keys are of type <code>K</code> and the values are of type <code>T</code>. This is useful for dictionaries or lookup tables.</p>
<div class="codehilite"><pre><span></span><code><span class="nx">type</span><span class="w"> </span><span class="nx">Page</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;home&quot;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s2">&quot;about&quot;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s2">&quot;contact&quot;</span><span class="p">;</span>

<span class="nx">type</span><span class="w"> </span><span class="nx">PageInfo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">title</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">,</span>
<span class="w">  </span><span class="nx">path</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// Creates a type where keys must be &#39;home&#39;, &#39;about&#39;, or &#39;contact&#39;</span>
<span class="c1">// and values must match the PageInfo shape.</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">navigationMap</span><span class="o">:</span><span class="w"> </span><span class="nx">Record</span><span class="o">&lt;</span><span class="nx">Page</span><span class="p">,</span><span class="w"> </span><span class="nx">PageInfo</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">home</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">title</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Home&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">path</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;/&quot;</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="nx">about</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">title</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;About Us&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">path</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;/about&quot;</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="nx">contact</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">title</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Contact&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">path</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;/contact&quot;</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="c1">// dashboard: { title: &#39;Dashboard&#39;, path: &#39;/dash&#39; } // This would be an error!</span>
<span class="p">};</span>
</code></pre></div>

<h2 id="deep-dive_7">Deep Dive</h2>
<h3 id="combining-utility-types">Combining Utility Types</h3>
<p>The real power of utility types comes from composing them. Imagine you want to create props for a form that can edit a user's contact info. You need the <code>id</code> to identify the user, and the <code>name</code> and <code>email</code> fields should be optional.</p>
<div class="codehilite"><pre><span></span><code><span class="nx">type</span><span class="w"> </span><span class="nx">User</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="nx">number</span><span class="p">,</span>
<span class="w">  </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">,</span>
<span class="w">  </span><span class="nx">email</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">,</span>
<span class="w">  </span><span class="nx">isAdmin</span><span class="o">:</span><span class="w"> </span><span class="kr">boolean</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// Step 1: Pick the fields we want to edit.</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">ContactFields</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">Pick</span><span class="o">&lt;</span><span class="nx">User</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;name&quot;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s2">&quot;email&quot;</span><span class="o">&gt;</span><span class="p">;</span>
<span class="c1">// Result: { name: string; email: string; }</span>

<span class="c1">// Step 2: Make those fields optional.</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">OptionalContactFields</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">Partial</span><span class="o">&lt;</span><span class="nx">ContactFields</span><span class="o">&gt;</span><span class="p">;</span>
<span class="c1">// Result: { name?: string; email?: string; }</span>

<span class="c1">// Step 3: Add back the required `id` field.</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">UserEditFormProps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="nx">User</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nx">OptionalContactFields</span><span class="p">;</span>
<span class="c1">// Result: { id: number; name?: string; email?: string; }</span>

<span class="c1">// This component can now be used to edit a user&#39;s contact info</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">UserEditForm</span><span class="p">(</span><span class="nx">props</span><span class="o">:</span><span class="w"> </span><span class="nx">UserEditFormProps</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// ... form logic</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="o">&lt;</span><span class="nx">form</span><span class="o">&gt;</span><span class="p">{</span><span class="cm">/* ... */</span><span class="p">}</span><span class="o">&lt;</span><span class="err">/form&gt;;</span>
<span class="p">}</span>
</code></pre></div>

<p>This approach is highly maintainable. If you add a <code>phone</code> number to the base <code>User</code> type and want it to be editable, you only need to add it to the <code>Pick</code> in <code>ContactFields</code>. The rest of the types will update automatically. This is far better than maintaining multiple, disconnected type definitions.</p>
<h3 id="common-confusion-why-not-just-create-new-types-manually">Common Confusion: "Why not just create new types manually?"</h3>
<p><strong>You might think</strong>: "This seems complicated. I could just write out the <code>UserEditFormProps</code> type by hand."</p>
<p><strong>Actually</strong>: While you can, you lose the connection to the "single source of truth"‚Äîthe base <code>User</code> type. If you manually define related types, and then the base <code>User</code> type changes (e.g., <code>name</code> is renamed to <code>fullName</code>), your manual types will be out of date and won't produce a TypeScript error, leading to bugs.</p>
<p><strong>Why the confusion happens</strong>: The immediate benefit isn't always obvious in small examples. The payoff comes in large applications where types are changed and refactored frequently.</p>
<p><strong>How to remember</strong>: Think "Don't Repeat Yourself" (DRY), but for types. Utility types are the way to practice DRY with your type definitions.</p>
<h3 id="production-perspective_7">Production Perspective</h3>
<ul>
<li><strong>Single Source of Truth</strong>: Define your core data models (like <code>User</code>, <code>Product</code>, <code>Order</code>) once. Use utility types to derive all other variations needed by your UI. This is especially important when your types are generated from a backend API schema (e.g., GraphQL or OpenAPI).</li>
<li><strong>Component Prop Variations</strong>: <code>Pick</code> and <code>Omit</code> are your best friends for creating wrapper components. A wrapper component might <code>Omit</code> a few props from the component it's wrapping to provide its own implementation, or <code>Pick</code> a few to pass them through.</li>
<li><strong>Readability</strong>: While you can nest utility types (<code>Partial&lt;Pick&lt;User, 'name'&gt;&gt;</code>), creating intermediate type aliases like we did with <code>ContactFields</code> can make the code much easier to read and debug.</li>
</ul>
<h2 id="enhanced-typescript-support-in-react-19">Enhanced TypeScript Support in React 19</h2>
<h2 id="learning-objective_8">Learning Objective</h2>
<p>Recognize the key improvements to TypeScript support in React 19, including the explicit <code>children</code> prop and better type inference for new hooks and features.</p>
<h2 id="why-this-matters_8">Why This Matters</h2>
<p>React 19 and its type definitions (<code>@types/react</code>) have been refined to be more precise and intuitive. Understanding these changes helps you write more correct, modern React code and avoid legacy patterns.</p>
<h2 id="discovery-phase_8">Discovery Phase</h2>
<h3 id="explicit-children-prop">Explicit <code>children</code> Prop</h3>
<p>One of the most significant changes in recent versions of <code>@types/react</code> is how the <code>children</code> prop is handled. Previously, when you typed a component with <code>React.FC</code> (or <code>React.FunctionComponent</code>), the <code>children</code> prop was implicitly included. This could lead to confusion if your component wasn't designed to accept children.</p>
<p><strong>The Old Way (Legacy):</strong></p>
<div class="codehilite"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;react&quot;</span><span class="p">;</span>

<span class="c1">// In older versions, React.FC automatically added `children` to the props.</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">GreetingProps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">,</span>
<span class="p">};</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">Greeting</span><span class="o">:</span><span class="w"> </span><span class="nx">React</span><span class="p">.</span><span class="nx">FC</span><span class="p">&lt;</span><span class="nt">GreetingProps</span><span class="p">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">({</span><span class="w"> </span><span class="nx">name</span><span class="p">,</span><span class="w"> </span><span class="nx">children</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// `children` is available here, even though we didn&#39;t define it.</span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">children</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span><span class="nx">Hello</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="nx">name</span><span class="p">}&lt;/</span><span class="nt">h1</span><span class="p">&gt;;</span>
<span class="p">};</span>

<span class="c1">// This would render, but might not be what the component author intended.</span>
<span class="c1">// &lt;Greeting name=&quot;World&quot;&gt;&lt;span&gt;Unexpected child&lt;/span&gt;&lt;/Greeting&gt;</span>
</code></pre></div>

<p>This implicit behavior was often undesirable. The modern approach is to be explicit. <code>React.FC</code> no longer includes <code>children</code> by default. If your component accepts children, you must define them in your props type.</p>
<p><strong>The Modern React 19 Way:</strong></p>
<div class="codehilite"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;react&quot;</span><span class="p">;</span>

<span class="c1">// If your component does NOT accept children:</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">HeadingProps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">title</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">export</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">Heading</span><span class="p">({</span><span class="w"> </span><span class="nx">title</span><span class="w"> </span><span class="p">}</span><span class="o">:</span><span class="w"> </span><span class="nx">HeadingProps</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;{</span><span class="nx">title</span><span class="p">}&lt;/</span><span class="nt">h1</span><span class="p">&gt;;</span>
<span class="w">  </span><span class="c1">// &lt;Heading title=&quot;Hi&quot;&gt;&lt;span&gt;Child&lt;/span&gt;&lt;/Heading&gt; // This is now a TypeScript error!</span>
<span class="p">}</span>

<span class="c1">// If your component DOES accept children:</span>
<span class="nx">type</span><span class="w"> </span><span class="nx">CardProps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">title</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="p">,</span>
<span class="w">  </span><span class="nx">children</span><span class="o">:</span><span class="w"> </span><span class="nx">React</span><span class="p">.</span><span class="nx">ReactNode</span><span class="p">,</span><span class="w"> </span><span class="c1">// Be explicit!</span>
<span class="p">};</span>

<span class="k">export</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">Card</span><span class="p">({</span><span class="w"> </span><span class="nx">title</span><span class="p">,</span><span class="w"> </span><span class="nx">children</span><span class="w"> </span><span class="p">}</span><span class="o">:</span><span class="w"> </span><span class="nx">CardProps</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">div</span><span class="w"> </span><span class="na">style</span><span class="o">=</span><span class="p">{{</span><span class="w"> </span><span class="nx">border</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;1px solid #ccc&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">padding</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;16px&quot;</span><span class="w"> </span><span class="p">}}&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">h2</span><span class="p">&gt;{</span><span class="nx">title</span><span class="p">}&lt;/</span><span class="nt">h2</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;{</span><span class="nx">children</span><span class="p">}&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Usage</span>
<span class="k">export</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">App</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">Card</span><span class="w"> </span><span class="na">title</span><span class="o">=</span><span class="s">&quot;My Card&quot;</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span><span class="nx">This</span><span class="w"> </span><span class="nx">is</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">content</span><span class="w"> </span><span class="nx">inside</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">card</span><span class="p">.&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">Card</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>This change is a major improvement for type safety. Your component's props are now a perfect reflection of its intended API. Use <code>React.ReactNode</code> as the type for <code>children</code> to accept anything React can render (strings, numbers, JSX elements, arrays of elements, etc.).</p>
<h2 id="deep-dive_8">Deep Dive</h2>
<h3 id="better-inference-for-new-hooks">Better Inference for New Hooks</h3>
<p>React 19 introduces new hooks like <code>useActionState</code> and <code>useOptimistic</code>. These hooks have been designed with TypeScript's inference capabilities in mind, providing a fantastic developer experience out of the box.</p>
<p>Let's look at <code>useActionState</code> (which we'll cover in detail in Chapter 8).</p>
<div class="codehilite"><pre><span></span><code><span class="s1">&#39;use client&#39;</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">useActionState</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;react&#39;</span><span class="p">;</span>

<span class="c1">// The server action function. TypeScript can infer types across the client/server boundary!</span>
<span class="k">async</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">updateUser</span><span class="p">(</span><span class="nx">prevState</span><span class="o">:</span><span class="w"> </span><span class="nx">string</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kc">null</span><span class="p">,</span><span class="w"> </span><span class="nx">formData</span><span class="o">:</span><span class="w"> </span><span class="nx">FormData</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">formData</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">)</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="nx">string</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">name</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">3</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="s2">&quot;Name must be at least 3 characters long.&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// This is inferred as the state type</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// ... update user logic</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span><span class="w"> </span><span class="c1">// This is also inferred as the state type</span>
<span class="p">}</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">UserForm</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// TypeScript infers the types perfectly here:</span>
<span class="w">  </span><span class="c1">// `error` is inferred as `string | null`</span>
<span class="w">  </span><span class="c1">// `submitAction` is inferred as the form action function</span>
<span class="w">  </span><span class="c1">// `isPending` is inferred as `boolean`</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">error</span><span class="p">,</span><span class="w"> </span><span class="nx">submitAction</span><span class="p">,</span><span class="w"> </span><span class="nx">isPending</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useActionState</span><span class="p">(</span><span class="nx">updateUser</span><span class="p">,</span><span class="w"> </span><span class="kc">null</span><span class="p">);</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">form</span><span class="w"> </span><span class="na">action</span><span class="o">=</span><span class="p">{</span><span class="nx">submitAction</span><span class="p">}&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">input</span><span class="w"> </span><span class="na">type</span><span class="o">=</span><span class="s">&quot;text&quot;</span><span class="w"> </span><span class="na">name</span><span class="o">=</span><span class="s">&quot;name&quot;</span><span class="w"> </span><span class="p">/&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">button</span><span class="w"> </span><span class="na">type</span><span class="o">=</span><span class="s">&quot;submit&quot;</span><span class="w"> </span><span class="na">disabled</span><span class="o">=</span><span class="p">{</span><span class="nx">isPending</span><span class="p">}&gt;</span>
<span class="w">        </span><span class="p">{</span><span class="nx">isPending</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s1">&#39;Saving...&#39;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Save&#39;</span><span class="p">}</span>
<span class="w">      </span><span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">{</span><span class="nx">error</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">p</span><span class="w"> </span><span class="na">style</span><span class="o">=</span><span class="p">{{</span><span class="w"> </span><span class="nx">color</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;red&#39;</span><span class="w"> </span><span class="p">}}&gt;{</span><span class="nx">error</span><span class="p">}&lt;/</span><span class="nt">p</span><span class="p">&gt;}</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">form</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>The type inference here is seamless. TypeScript analyzes the <code>updateUser</code> function's return values (<code>string</code> for an error, <code>null</code> for success) and correctly types the <code>error</code> state variable as <code>string | null</code>. This powerful, built-in type safety is a hallmark of the new React 19 APIs.</p>
<h3 id="ref-as-a-prop-no-more-forwardref"><code>ref</code> as a Prop (No more <code>forwardRef</code>)</h3>
<p>Another huge simplification is that you no longer need <code>React.forwardRef</code> to pass a <code>ref</code> to a component. The <code>ref</code> prop is now typed like any other prop.</p>
<p><strong>Legacy Way:</strong></p>
<div class="codehilite"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">MyInput</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">React</span><span class="p">.</span><span class="nx">forwardRef</span><span class="p">((</span><span class="nx">props</span><span class="p">,</span><span class="w"> </span><span class="nx">ref</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="o">&lt;</span><span class="nx">input</span><span class="w"> </span><span class="nx">ref</span><span class="o">=</span><span class="p">{</span><span class="nx">ref</span><span class="p">}</span><span class="w"> </span><span class="p">{...</span><span class="nx">props</span><span class="p">}</span><span class="w"> </span><span class="o">/&gt;</span><span class="p">;</span>
<span class="p">});</span>
</code></pre></div>

<p><strong>Modern React 19 Way:</strong></p>
<div class="codehilite"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="kr">type</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">Ref</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;react&quot;</span><span class="p">;</span>

<span class="kr">type</span><span class="w"> </span><span class="nx">MyInputProps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">ref</span><span class="o">:</span><span class="w"> </span><span class="kt">Ref</span><span class="o">&lt;</span><span class="nx">HTMLInputElement</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// ... other props</span>
<span class="p">};</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">MyInput</span><span class="p">({</span><span class="w"> </span><span class="nx">ref</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="nx">props</span><span class="w"> </span><span class="p">}</span><span class="o">:</span><span class="w"> </span><span class="nx">MyInputProps</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="o">&lt;</span><span class="nx">input</span><span class="w"> </span><span class="nx">ref</span><span class="o">=</span><span class="p">{</span><span class="nx">ref</span><span class="p">}</span><span class="w"> </span><span class="p">{...</span><span class="nx">props</span><span class="p">}</span><span class="w"> </span><span class="o">/&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>This makes component definitions cleaner and more consistent. We will dive deep into this pattern in the next chapter.</p>
<h3 id="production-perspective_8">Production Perspective</h3>
<ul>
<li><strong>Embrace Explicitness</strong>: The trend in React and TypeScript is towards more explicit, less "magic" APIs. Explicitly typing <code>children</code> is a prime example. This makes code easier to understand and less prone to bugs.</li>
<li><strong>Update Your Type Definitions</strong>: If you are working on an older codebase, make sure your <code>@types/react</code> and <code>@types/react-dom</code> packages are up to date to get the latest improvements and type safety features.</li>
<li><strong>Trust the Inference on New APIs</strong>: For new React 19 features, start by letting TypeScript infer as much as possible. The APIs are designed for this. Only add explicit generic arguments if inference doesn't produce the result you need. This leads to cleaner, more modern code.</li>
</ul>
<h2 id="module-synthesis">Module Synthesis üìã</h2>
<h2 id="module-synthesis_1">Module Synthesis</h2>
<p>In this chapter, we laid the essential groundwork for using TypeScript with React 19. We've moved from understanding <em>why</em> TypeScript is crucial for modern React development to the practical application of its core features.</p>
<p>We started by seeing the immediate safety benefits of TypeScript, turning a potential runtime crash into a compile-time error. We then refreshed our knowledge of basic types, establishing the vocabulary needed to describe our data and component APIs.</p>
<p>We saw how modern tools like Vite make setting up a TypeScript-React project a one-command process, and demystified the <code>tsconfig.json</code> file, highlighting the importance of <code>"strict": true</code>. We learned the critical balance between explicit <strong>annotations</strong> at function boundaries and letting TypeScript <strong>inference</strong> work its magic inside implementations.</p>
<p>Finally, we explored the tools for building flexible and maintainable type systems:</p>
<ul>
<li><strong><code>type</code> vs. <code>interface</code></strong>: We established a pragmatic convention of using <code>type</code> for consistency.</li>
<li><strong>Union (<code>|</code>) and Intersection (<code>&amp;</code>) types</strong>: These are our tools for composing props and modeling different component states.</li>
<li><strong>Generics (<code>&lt;T&gt;</code>)</strong>: The key to creating truly reusable, type-safe components like our generic <code>List</code>.</li>
<li><strong>Utility Types</strong>: We learned how to derive new types from a single source of truth using <code>Pick</code>, <code>Omit</code>, and <code>Partial</code>, keeping our type definitions DRY.</li>
</ul>
<p>We concluded by looking at the enhanced support in React 19, particularly the move to explicit <code>children</code> props, which makes our component APIs clearer and more robust.</p>
<h2 id="looking-ahead">Looking Ahead</h2>
<p>With this foundational knowledge, you are now equipped to write strongly-typed React components. In the next chapter, <strong>Chapter 20: Typing React 19 Components</strong>, we will go deeper. We'll build on these fundamentals to tackle more advanced component typing scenarios, including typing props with children, event handlers, and the new, simplified <code>ref</code> prop pattern. We will put these primitive types and utilities to work to describe the full range of components you'll build in a professional application.</p>
        </div>
        <div class="footer">
            Generated on 2025-10-25 16:27:48 | Made with ‚ù§Ô∏è by GitHub Pages Generator
        </div>
    </div>
    <script>
        // Syntax highlighting for code blocks
        document.addEventListener('DOMContentLoaded', (event) => {
            // Highlight code blocks
            document.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightElement(block);
            });
            
            // Add copy buttons to code blocks
            document.querySelectorAll('pre').forEach((pre) => {
                const button = document.createElement('button');
                button.className = 'copy-btn';
                button.textContent = 'Copy';
                
                button.addEventListener('click', () => {
                    const code = pre.querySelector('code').textContent;
                    navigator.clipboard.writeText(code).then(() => {
                        button.textContent = 'Copied!';
                        button.classList.add('copied');
                        setTimeout(() => {
                            button.textContent = 'Copy';
                            button.classList.remove('copied');
                        }, 2000);
                    }).catch(err => {
                        console.error('Failed to copy:', err);
                        button.textContent = 'Error';
                        setTimeout(() => {
                            button.textContent = 'Copy';
                        }, 2000);
                    });
                });
                
                pre.appendChild(button);
            });
        });
    </script>
</body>
</html>