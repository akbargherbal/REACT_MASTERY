<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>16_Testing_React_Applications</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <style>
        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --secondary: #8b5cf6;
            --bg-main: #0f172a;
            --bg-card: #1e293b;
            --bg-code: #0f172a;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --border: #334155;
            --accent: #06b6d4;
            --success: #10b981;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            line-height: 1.7; 
            color: var(--text-primary); 
            background: var(--bg-main);
        }
        
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            padding: 20px; 
        }
        
        .home-btn { 
            position: fixed; 
            top: 20px; 
            right: 20px; 
            background: var(--accent);
            color: white; 
            width: 50px;
            height: 50px;
            border-radius: 50%;
            text-decoration: none; 
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(6, 182, 212, 0.4);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .home-btn:hover { 
            background: #0891b2;
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(6, 182, 212, 0.5);
        }
        
        .breadcrumb { 
            background: var(--bg-card);
            padding: 12px 0; 
            margin-bottom: 24px; 
            font-size: 14px;
            border-radius: 8px;
            border: 1px solid var(--border);
        }
        
        .breadcrumb a { 
            color: var(--accent);
            text-decoration: none;
            transition: color 0.2s;
        }
        
        .breadcrumb a:hover { 
            color: var(--primary);
            text-decoration: underline;
        }
        
        .content { 
            background: var(--bg-card);
            padding: 3rem; 
            border-radius: 16px; 
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border);
        }
        
        .file-list { 
            display: grid; 
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); 
            gap: 1.5rem; 
            margin: 2rem 0; 
        }
        
        .file-item { 
            padding: 1.5rem; 
            border: 1px solid var(--border);
            border-radius: 12px; 
            background: var(--bg-main);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .file-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .file-item:hover { 
            transform: translateY(-4px); 
            box-shadow: 0 8px 30px rgba(99, 102, 241, 0.3);
            border-color: var(--primary);
        }
        
        .file-item:hover::before {
            opacity: 1;
        }
        
        .file-item a { 
            color: var(--text-primary);
            text-decoration: none; 
            font-weight: 600; 
            display: block;
            font-size: 1.1rem;
        }
        
        .file-item a:hover { 
            color: var(--primary);
        }
        
        .file-type { 
            font-size: 13px; 
            color: var(--text-secondary);
            margin-top: 8px; 
            font-weight: 500;
        }
        
        /* Code Blocks */
        pre { 
            background: var(--bg-code);
            padding: 1.5rem; 
            border-radius: 12px; 
            overflow-x: auto;
            border: 1px solid var(--border);
            margin: 1.5rem 0;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            position: relative;
        }
        
        pre code { 
            background: none;
            padding: 0;
            font-family: 'Fira Code', 'Consolas', monospace;
            font-size: 0.9em;
            line-height: 1.6;
        }
        
        /* Copy Button */
        .copy-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: var(--primary);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
            opacity: 0.7;
            z-index: 10;
        }
        
        .copy-btn:hover {
            opacity: 1;
            background: var(--primary-dark);
            transform: translateY(-1px);
        }
        
        .copy-btn.copied {
            background: var(--success);
        }
        
        pre:hover .copy-btn {
            opacity: 1;
        }
        
        /* Inline Code */
        code { 
            background: var(--bg-code);
            color: #8b5cf6;
            padding: 3px 8px; 
            border-radius: 6px; 
            font-size: 1.1em;
            font-family: 'Fira Code', 'Consolas', monospace;
            border: 1px solid var(--border);
        }
        
        /* Headings */
        h1, h2, h3, h4, h5, h6 { 
            color: var(--text-primary);
            margin: 2rem 0 1rem 0;
            font-weight: 700;
            letter-spacing: -0.5px;
        }
        
        h1 { 
            font-size: 2.5rem;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            border-bottom: 3px solid var(--primary);
            padding-bottom: 12px;
            margin-bottom: 1.5rem;
        }
        
        h2 { 
            font-size: 2rem;
            color: var(--primary);
            border-bottom: 2px solid var(--border);
            padding-bottom: 8px;
        }
        
        h3 { 
            font-size: 1.5rem;
            color: var(--accent);
        }
        
        /* Links */
        a { 
            color: var(--accent);
            transition: color 0.2s;
        }
        
        a:hover { 
            color: var(--primary);
        }
        
        /* Paragraphs */
        p {
            margin: 1rem 0;
            color: var(--text-secondary);
        }
        
        /* Lists */
        ul, ol {
            margin: 1rem 0;
            padding-left: 2rem;
            color: var(--text-secondary);
        }
        
        li {
            margin: 0.5rem 0;
        }
        
        /* Tables */
        table { 
            border-collapse: collapse;
            width: 100%;
            margin: 1.5rem 0;
            background: var(--bg-main);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        
        th, td { 
            border: 1px solid var(--border);
            padding: 12px 16px;
            text-align: left;
        }
        
        th { 
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            font-weight: 600;
        }
        
        tr:hover {
            background: var(--bg-card);
        }
        
        /* Blockquotes */
        blockquote {
            border-left: 4px solid var(--primary);
            padding: 1rem 1.5rem;
            margin: 1.5rem 0;
            background: var(--bg-main);
            border-radius: 0 8px 8px 0;
            color: var(--text-secondary);
            font-style: italic;
        }
        
        /* Horizontal Rule */
        hr {
            border: none;
            border-top: 2px solid var(--border);
            margin: 2rem 0;
        }
        
        .footer { 
            text-align: center; 
            padding: 2rem; 
            color: var(--text-secondary);
            border-top: 1px solid var(--border);
            margin-top: 3rem; 
            font-size: 14px;
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--bg-main);
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 6px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary);
        }
        
        @media (max-width: 768px) {
            .container { padding: 10px; }
            .file-list { grid-template-columns: 1fr; }
            .content { padding: 1.5rem; }
            h1 { font-size: 2rem; }
            h2 { font-size: 1.5rem; }
        }
    </style>
</head>
<body>
    <a href="../index.html" class="home-btn">üè†</a>
    <div class="container">
        <div class="breadcrumb">
            <div style="padding: 0 20px;">
                <a href="../index.html">üè† Home</a> <span style="color: #64748b;">/</span> <a href="index.html">03_Advanced_React</a>
            </div>
        </div>
        <div class="content">
            <h1 id="chapter-16-testing-react-applications">Chapter 16: Testing React Applications</h1>
<h2 id="testing-philosophy-and-strategies">Testing Philosophy and Strategies</h2>
<h2 id="learning-objective">Learning Objective</h2>
<p>Understand the modern "Testing Trophy" philosophy as a guide for creating a balanced and effective testing strategy for a React application.</p>
<h2 id="why-this-matters">Why This Matters</h2>
<p>Writing tests isn't just about finding bugs; it's about building with confidence. A good testing strategy allows you to refactor code, add new features, and upgrade dependencies without fear of breaking existing functionality. The Testing Trophy provides a clear, modern roadmap for where to invest your testing efforts to get the best return on investment.</p>
<h2 id="discovery-phase">Discovery Phase</h2>
<p>For years, the "Testing Pyramid" was the dominant philosophy, emphasizing a large base of unit tests. However, in the world of component-based frameworks like React, this model can be misleading. A modern alternative, the <strong>Testing Trophy</strong>, proposed by Kent C. Dodds (the creator of React Testing Library), better reflects the needs of a modern web application.</p>
<p>Here's a breakdown of the Testing Trophy, from bottom to top:</p>
<div class="codehilite"><pre><span></span><code>      /================\
     |      E2E         |
    /====================\
   |    Integration     |
  /======================\
 |        Unit          |
/========================\
|        Static          |
\========================/
</code></pre></div>

<ul>
<li><strong>Static Analysis</strong>: The foundation. Tools like TypeScript and ESLint catch typos, type errors, and basic code quality issues as you type, before you even run a test.</li>
<li><strong>Unit Tests</strong>: The next layer. These test a single, isolated piece of logic, like a helper function or a custom hook. They are fast and precise.</li>
<li><strong>Integration Tests</strong>: The sweet spot and the largest part of the trophy. These tests verify that multiple components work together correctly from the user's perspective. This is where React Testing Library shines.</li>
<li><strong>End-to-End (E2E) Tests</strong>: The top. These tests automate a real browser to simulate a complete user journey through your live application, including the backend. They provide the most confidence but are the slowest and most expensive to maintain.</li>
</ul>
<p>The shape of the trophy‚Äîwide in the middle‚Äîsuggests where you should spend the most time: <strong>integration testing</strong>.</p>
<h2 id="deep-dive">Deep Dive</h2>
<h3 id="why-not-the-pyramid">Why Not the Pyramid?</h3>
<p>The classic pyramid advocates for a huge number of unit tests. In React, this can lead to "implementation detail" testing. For example, a unit test might check: "Does this component's state change from <code>false</code> to <code>true</code> when clicked?". This is brittle. If you refactor the component to use a different state management approach, the test breaks even if the user-facing behavior is identical.</p>
<h3 id="the-testing-trophys-guiding-principle">The Testing Trophy's Guiding Principle</h3>
<p>The Testing Trophy encourages you to write tests that resemble how your users interact with your application. A user doesn't care about your component's state; they care that when they click a button, a modal appears. This is an integration of multiple units (the button, the state logic, the modal), and testing this flow provides much more value and confidence.</p>
<ul>
<li><strong>Static Analysis</strong> gives you fast feedback.</li>
<li><strong>Unit Tests</strong> are for your core business logic (e.g., a function that calculates a shopping cart total).</li>
<li><strong>Integration Tests</strong> ensure your application works as a cohesive whole (e.g., adding an item to the cart updates the total correctly).</li>
<li><strong>E2E Tests</strong> are the final check that everything, including deployment and backend services, is working.</li>
</ul>
<h2 id="production-perspective">Production Perspective</h2>
<p>A balanced testing strategy based on the trophy gives you the highest "Return on Investment" (ROI).</p>
<ul>
<li>You spend the most time on <strong>integration tests</strong>, which give you high confidence that your app works for users, without being as slow or brittle as E2E tests.</li>
<li>You use <strong>unit tests</strong> surgically for complex, isolated logic.</li>
<li>You rely on <strong>static analysis</strong> to catch a whole class of errors for free.</li>
<li>You use a few, critical <strong>E2E tests</strong> as a final safety net for your most important user flows (like login and checkout).</li>
</ul>
<p>This module will primarily focus on the "Integration" and "Unit" layers, using Jest as our test runner and React Testing Library as our primary tool, perfectly aligning with the Testing Trophy philosophy.</p>
<h2 id="jest-fundamentals">Jest Fundamentals</h2>
<h2 id="learning-objective_1">Learning Objective</h2>
<p>Understand the role of Jest as a test runner, assertion library, and mocking framework, and learn its basic syntax for writing a test.</p>
<h2 id="why-this-matters_1">Why This Matters</h2>
<p>To test your React components, you need a program that can find your test files, execute them, and report the results. Jest is the most popular test runner in the JavaScript ecosystem. It provides everything you need out of the box to start writing tests. Even if you use a modern alternative like Vitest, the syntax is nearly identical, making these fundamentals universally applicable.</p>
<h2 id="discovery-phase_1">Discovery Phase</h2>
<p>Let's write a simple test for a non-React helper function to understand Jest's core syntax. Imagine we have a utility function in our project.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// src/utils/math.js</span>
<span class="k">export</span><span class="w"> </span><span class="kd">const</span><span class="w"> </span><span class="nx">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">b</span><span class="p">;</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1">// src/utils/math.test.js</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">sum</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;./math&quot;</span><span class="p">;</span>

<span class="c1">// 1. `describe` groups related tests together into a &quot;test suite&quot;.</span>
<span class="nx">describe</span><span class="p">(</span><span class="s2">&quot;sum&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// 2. `it` or `test` defines an individual test case.</span>
<span class="w">  </span><span class="c1">// The string should describe what the function is expected to do.</span>
<span class="w">  </span><span class="nx">it</span><span class="p">(</span><span class="s2">&quot;should return the sum of two positive numbers&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 3. `expect` is the assertion. You wrap the value you want to check.</span>
<span class="w">    </span><span class="c1">// 4. `.toBe` is a &quot;matcher&quot;. It checks for strict equality (===).</span>
<span class="w">    </span><span class="nx">expect</span><span class="p">(</span><span class="nx">sum</span><span class="p">(</span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="mf">3</span><span class="p">)).</span><span class="nx">toBe</span><span class="p">(</span><span class="mf">5</span><span class="p">);</span>
<span class="w">  </span><span class="p">});</span>

<span class="w">  </span><span class="nx">it</span><span class="p">(</span><span class="s2">&quot;should return the sum when one number is negative&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">expect</span><span class="p">(</span><span class="nx">sum</span><span class="p">(</span><span class="o">-</span><span class="mf">5</span><span class="p">,</span><span class="w"> </span><span class="mf">10</span><span class="p">)).</span><span class="nx">toBe</span><span class="p">(</span><span class="mf">5</span><span class="p">);</span>
<span class="w">  </span><span class="p">});</span>
<span class="p">});</span>
</code></pre></div>

<p>When you run your test command (e.g., <code>npm test</code>), Jest will find this file (because it ends in <code>.test.js</code>), execute the code, and print a report to your console:</p>
<div class="codehilite"><pre><span></span><code><span class="nv">PASS</span><span class="w">  </span><span class="nv">src</span><span class="o">/</span><span class="nv">utils</span><span class="o">/</span><span class="nv">math</span>.<span class="nv">test</span>.<span class="nv">js</span>
<span class="w">  </span><span class="nv">sum</span>
<span class="w">    </span>‚úì<span class="w"> </span><span class="nv">should</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">sum</span><span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="nv">two</span><span class="w"> </span><span class="nv">positive</span><span class="w"> </span><span class="nv">numbers</span><span class="w"> </span><span class="ss">(</span><span class="mi">2</span><span class="nv">ms</span><span class="ss">)</span>
<span class="w">    </span>‚úì<span class="w"> </span><span class="nv">should</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">sum</span><span class="w"> </span><span class="nv">when</span><span class="w"> </span><span class="nv">one</span><span class="w"> </span><span class="nv">number</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">negative</span><span class="w"> </span><span class="ss">(</span><span class="mi">1</span><span class="nv">ms</span><span class="ss">)</span>

<span class="nv">Test</span><span class="w"> </span><span class="nv">Suites</span>:<span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nv">passed</span>,<span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nv">total</span>
<span class="nv">Tests</span>:<span class="w">       </span><span class="mi">2</span><span class="w"> </span><span class="nv">passed</span>,<span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="nv">total</span>
</code></pre></div>

<h2 id="deep-dive_1">Deep Dive</h2>
<p>Let's break down the key parts of a Jest test:</p>
<ul>
<li><strong><code>describe(name, fn)</code></strong>: Creates a block that groups together several related tests. This is useful for organizing your tests into logical suites.</li>
<li><strong><code>it(name, fn)</code></strong> or <strong><code>test(name, fn)</code></strong>: These are interchangeable. This is the actual test case. The name should be a clear, human-readable description of the expected behavior.</li>
<li><strong><code>expect(value)</code></strong>: This is the heart of an assertion. You pass it the value that your code produced. It returns an "expectation" object.</li>
<li><strong>Matchers</strong>: You call a matcher function on the expectation object to assert something about the value. Jest has dozens of matchers:</li>
<li><code>.toBe(value)</code>: Uses <code>Object.is</code> to test for exact equality. Great for primitives like numbers, strings, and booleans.</li>
<li><code>.toEqual(value)</code>: Recursively checks every field of an object or array. Use this for testing objects and arrays.</li>
<li><code>.toBeTruthy()</code> / <code>.toBeFalsy()</code>: Checks if a value is truthy or falsy.</li>
<li><code>.toContain(item)</code>: Checks if an array or string contains an item.</li>
<li><code>.toHaveBeenCalled()</code>: Checks if a mock function was called (we'll see this later).</li>
</ul>
<h3 id="common-confusion-tobe-vs-toequal">Common Confusion: <code>.toBe</code> vs. <code>.toEqual</code></h3>
<p><strong>You might think</strong>: I can use <code>.toBe</code> to check if two objects are the same.</p>
<p><strong>Actually</strong>: <code>.toBe</code> checks for referential equality (are they the exact same object in memory?), not structural equality (do they have the same properties?).</p>
<p><strong>Why the confusion happens</strong>: It works for numbers and strings, so it's easy to assume it works for everything.</p>
<p><strong>Example</strong>:</p>
<div class="codehilite"><pre><span></span><code><span class="nx">it</span><span class="p">(</span><span class="s2">&quot;should correctly compare objects&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">user1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Alice&quot;</span><span class="w"> </span><span class="p">};</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">user2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Alice&quot;</span><span class="w"> </span><span class="p">};</span>

<span class="w">  </span><span class="c1">// This will FAIL! user1 and user2 are different objects in memory.</span>
<span class="w">  </span><span class="c1">// expect(user1).toBe(user2);</span>

<span class="w">  </span><span class="c1">// This will PASS! .toEqual checks the contents of the objects.</span>
<span class="w">  </span><span class="nx">expect</span><span class="p">(</span><span class="nx">user1</span><span class="p">).</span><span class="nx">toEqual</span><span class="p">(</span><span class="nx">user2</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div>

<p><strong>How to remember</strong>: Use <code>.toBe</code> for primitives. Use <code>.toEqual</code> for objects and arrays.</p>
<h2 id="production-perspective_1">Production Perspective</h2>
<ul>
<li><strong>Test Runner</strong>: Jest discovers and runs your tests.</li>
<li><strong>Assertion Library</strong>: Jest provides <code>expect</code> and the matchers.</li>
<li><strong>Mocking Framework</strong>: Jest has powerful built-in functions for creating mock functions and modules (<code>jest.fn()</code>, <code>jest.spyOn()</code>, <code>jest.mock()</code>).</li>
<li><strong>DOM Environment</strong>: When testing React components, Jest uses a library called <strong>JSDOM</strong> to simulate a browser environment in Node.js, so you can "render" components and interact with a fake DOM without needing a real browser.</li>
</ul>
<h2 id="react-testing-library">React Testing Library</h2>
<h2 id="learning-objective_2">Learning Objective</h2>
<p>Use React Testing Library (RTL) to render components and write tests that find elements and assert their content, following the library's guiding principles.</p>
<h2 id="why-this-matters_2">Why This Matters</h2>
<p>React Testing Library has become the industry standard for testing React components. Its philosophy is to test your components in the same way a user would interact with them. This leads to tests that are more resilient to refactoring and give you more confidence that your application actually works for your users.</p>
<h2 id="discovery-phase_2">Discovery Phase</h2>
<p>Let's test a simple <code>Counter</code> component. It displays a count and a button to increment it.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// src/components/Counter.jsx</span>
<span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">useState</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;react&quot;</span><span class="p">;</span>

<span class="k">export</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">Counter</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">count</span><span class="p">,</span><span class="w"> </span><span class="nx">setCount</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">(</span><span class="mf">0</span><span class="p">);</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span><span class="nx">Count</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="nx">count</span><span class="p">}&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">button</span><span class="w"> </span><span class="na">onClick</span><span class="o">=</span><span class="p">{()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">setCount</span><span class="p">(</span><span class="nx">count</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1</span><span class="p">)}&gt;</span><span class="nx">Increment</span><span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1">// src/components/Counter.test.jsx</span>
<span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;react&quot;</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">render</span><span class="p">,</span><span class="w"> </span><span class="nx">screen</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;@testing-library/react&quot;</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="nx">userEvent</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;@testing-library/user-event&quot;</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">Counter</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;./Counter&quot;</span><span class="p">;</span>

<span class="nx">describe</span><span class="p">(</span><span class="s2">&quot;Counter&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">it</span><span class="p">(</span><span class="s2">&quot;should render with an initial count of 0&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 1. Render the component into the virtual DOM</span>
<span class="w">    </span><span class="nx">render</span><span class="p">(&lt;</span><span class="nt">Counter</span><span class="w"> </span><span class="p">/&gt;);</span>

<span class="w">    </span><span class="c1">// 2. Use `screen` to find elements on the &quot;page&quot;</span>
<span class="w">    </span><span class="c1">// `getByText` finds an element by its text content.</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">countElement</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">screen</span><span class="p">.</span><span class="nx">getByText</span><span class="p">(</span><span class="s2">&quot;Count: 0&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 3. Assert that the element is in the document</span>
<span class="w">    </span><span class="nx">expect</span><span class="p">(</span><span class="nx">countElement</span><span class="p">).</span><span class="nx">toBeInTheDocument</span><span class="p">();</span>
<span class="w">  </span><span class="p">});</span>

<span class="w">  </span><span class="nx">it</span><span class="p">(</span><span class="s2">&quot;should increment the count when the button is clicked&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Arrange</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">user</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">userEvent</span><span class="p">.</span><span class="nx">setup</span><span class="p">();</span>
<span class="w">    </span><span class="nx">render</span><span class="p">(&lt;</span><span class="nt">Counter</span><span class="w"> </span><span class="p">/&gt;);</span>

<span class="w">    </span><span class="c1">// Act</span>
<span class="w">    </span><span class="c1">// `getByRole` is the preferred way to find interactive elements.</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">incrementButton</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">screen</span><span class="p">.</span><span class="nx">getByRole</span><span class="p">(</span><span class="s2">&quot;button&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="sr">/increment/i</span><span class="w"> </span><span class="p">});</span>
<span class="w">    </span><span class="k">await</span><span class="w"> </span><span class="nx">user</span><span class="p">.</span><span class="nx">click</span><span class="p">(</span><span class="nx">incrementButton</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Assert</span>
<span class="w">    </span><span class="c1">// The count should now be 1.</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">countElement</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">screen</span><span class="p">.</span><span class="nx">getByText</span><span class="p">(</span><span class="s2">&quot;Count: 1&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="nx">expect</span><span class="p">(</span><span class="nx">countElement</span><span class="p">).</span><span class="nx">toBeInTheDocument</span><span class="p">();</span>
<span class="w">  </span><span class="p">});</span>
<span class="p">});</span>
</code></pre></div>

<h2 id="deep-dive_2">Deep Dive</h2>
<p>Let's break down the key parts of RTL:</p>
<ol>
<li>
<p><strong><code>render</code></strong>: This function takes your JSX and renders it into a JSDOM container. You typically only call this once at the beginning of your test.</p>
</li>
<li>
<p><strong><code>screen</code></strong>: This is an object that has all the query methods pre-bound to the <code>document.body</code> of the JSDOM. It's the primary way you'll find elements.</p>
</li>
<li>
<p><strong>Queries</strong>: These are the functions you use to find elements. RTL encourages you to use queries that reflect how users find elements. The priority is:</p>
<ol>
<li><strong><code>getByRole</code></strong>: The best query. Finds elements by their accessibility role (e.g., <code>button</code>, <code>navigation</code>, <code>heading</code>). This aligns with how screen reader users navigate.</li>
<li><strong><code>getByLabelText</code></strong>: Finds form elements by their associated <code>&lt;label&gt;</code>.</li>
<li><strong><code>getByPlaceholderText</code></strong>: Finds form elements by their placeholder.</li>
<li><strong><code>getByText</code></strong>: Finds elements by their text content.</li>
<li><strong><code>getByTestId</code></strong>: The escape hatch. Use <code>data-testid="some-id"</code> when you can't find an element by any other means.</li>
</ol>
</li>
<li>
<p><strong><code>userEvent</code></strong>: This library simulates real user interactions more accurately than RTL's built-in <code>fireEvent</code>. It dispatches all the events a browser would (e.g., <code>hover</code>, <code>focus</code>, <code>click</code>). Always prefer <code>userEvent</code> for interaction tests. Note that its methods are async, so you should <code>await</code> them.</p>
</li>
</ol>
<h3 id="rtls-guiding-principle-avoid-testing-implementation-details">RTL's Guiding Principle: Avoid Testing Implementation Details</h3>
<p><strong>You might think</strong>: I should test that the <code>count</code> state inside the component is <code>1</code>.</p>
<p><strong>Actually</strong>: You should never test a component's internal state. This is an <strong>implementation detail</strong>.</p>
<p><strong>Why the confusion happens</strong>: It feels natural to want to check the internal workings of your component.</p>
<p><strong>How to remember</strong>: The user cannot see your component's state. They only see the rendered output. If you refactor your <code>Counter</code> to use the <code>useReducer</code> hook instead of <code>useState</code>, the user experience is identical. A test that checks the state would break, but a test that checks the text on the screen (<code>Count: 1</code>) would still pass. This is what makes RTL tests so robust and maintainable. <strong>Test the behavior, not the implementation.</strong></p>
<h2 id="production-perspective_2">Production Perspective</h2>
<ul>
<li><strong>Jest + RTL + userEvent</strong>: This trio forms the modern standard for component testing in React.</li>
<li><strong><code>@testing-library/jest-dom</code></strong>: This companion library (usually set up for you by default) adds custom matchers to Jest like <code>.toBeInTheDocument()</code>, <code>.toBeVisible()</code>, and <code>.toHaveValue()</code>, which make your assertions more declarative and readable.</li>
<li><strong>Accessibility (<code>a11y</code>)</strong>: By prioritizing queries like <code>getByRole</code> and <code>getByLabelText</code>, RTL gently pushes you to write more accessible HTML. If your component is hard to test with these queries, it's often a sign that it's also hard for users with assistive technologies to use.</li>
</ul>
<h2 id="testing-components-with-actions">Testing Components with Actions</h2>
<h2 id="learning-objective_3">Learning Objective</h2>
<p>Write integration tests for components that use React Router's <code>&lt;Form&gt;</code> and route <code>action</code> functionality to handle data mutations.</p>
<h2 id="why-this-matters_3">Why This Matters</h2>
<p>React 19's Actions paradigm (covered in Chapter 8) moves form submission logic out of the component and into the router configuration. Testing this requires a special setup where you provide a test router to your component, allowing you to verify that the form correctly calls its associated action with the right data.</p>
<h2 id="discovery-phase_3">Discovery Phase</h2>
<p>Let's test a simple contact form that uses a route action.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// src/components/ContactForm.jsx</span>
<span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;react&quot;</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">Form</span><span class="p">,</span><span class="w"> </span><span class="nx">useNavigation</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;react-router-dom&quot;</span><span class="p">;</span>

<span class="k">export</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">ContactForm</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">navigation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useNavigation</span><span class="p">();</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">isSubmitting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">navigation</span><span class="p">.</span><span class="nx">state</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s2">&quot;submitting&quot;</span><span class="p">;</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">Form</span><span class="w"> </span><span class="na">method</span><span class="o">=</span><span class="s">&quot;post&quot;</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">label</span><span class="w"> </span><span class="na">htmlFor</span><span class="o">=</span><span class="s">&quot;email&quot;</span><span class="p">&gt;</span><span class="nx">Email</span><span class="p">&lt;/</span><span class="nt">label</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">input</span><span class="w"> </span><span class="na">id</span><span class="o">=</span><span class="s">&quot;email&quot;</span><span class="w"> </span><span class="na">name</span><span class="o">=</span><span class="s">&quot;email&quot;</span><span class="w"> </span><span class="na">type</span><span class="o">=</span><span class="s">&quot;email&quot;</span><span class="w"> </span><span class="p">/&gt;</span>

<span class="w">      </span><span class="p">&lt;</span><span class="nt">button</span><span class="w"> </span><span class="na">type</span><span class="o">=</span><span class="s">&quot;submit&quot;</span><span class="w"> </span><span class="na">disabled</span><span class="o">=</span><span class="p">{</span><span class="nx">isSubmitting</span><span class="p">}&gt;</span>
<span class="w">        </span><span class="p">{</span><span class="nx">isSubmitting</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s2">&quot;Submitting...&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Submit&quot;</span><span class="p">}</span>
<span class="w">      </span><span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">Form</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1">// src/components/ContactForm.test.jsx</span>
<span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;react&quot;</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">render</span><span class="p">,</span><span class="w"> </span><span class="nx">screen</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;@testing-library/react&quot;</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="nx">userEvent</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;@testing-library/user-event&quot;</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">createMemoryRouter</span><span class="p">,</span><span class="w"> </span><span class="nx">RouterProvider</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;react-router-dom&quot;</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">ContactForm</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;./ContactForm&quot;</span><span class="p">;</span>

<span class="nx">describe</span><span class="p">(</span><span class="s2">&quot;ContactForm&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">it</span><span class="p">(</span><span class="s2">&quot;should call the action with the form data on submission&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">user</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">userEvent</span><span class="p">.</span><span class="nx">setup</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// 1. Create a mock action function using jest.fn()</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">mockAction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">jest</span><span class="p">.</span><span class="nx">fn</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// 2. Define a test route configuration</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">testRoutes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span>
<span class="w">      </span><span class="p">{</span>
<span class="w">        </span><span class="nx">path</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;/contact&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nx">element</span><span class="o">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">ContactForm</span><span class="w"> </span><span class="p">/&gt;,</span>
<span class="w">        </span><span class="nx">action</span><span class="o">:</span><span class="w"> </span><span class="nx">mockAction</span><span class="p">,</span><span class="w"> </span><span class="c1">// Assign the mock action to the route</span>
<span class="w">      </span><span class="p">},</span>
<span class="w">    </span><span class="p">];</span>

<span class="w">    </span><span class="c1">// 3. Create a memory router for the test</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">router</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">createMemoryRouter</span><span class="p">(</span><span class="nx">testRoutes</span><span class="p">,</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">initialEntries</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;/contact&quot;</span><span class="p">],</span>
<span class="w">    </span><span class="p">});</span>

<span class="w">    </span><span class="c1">// 4. Render the component wrapped in the RouterProvider</span>
<span class="w">    </span><span class="nx">render</span><span class="p">(&lt;</span><span class="nt">RouterProvider</span><span class="w"> </span><span class="na">router</span><span class="o">=</span><span class="p">{</span><span class="nx">router</span><span class="p">}</span><span class="w"> </span><span class="p">/&gt;);</span>

<span class="w">    </span><span class="c1">// 5. Interact with the form</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">emailInput</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">screen</span><span class="p">.</span><span class="nx">getByLabelText</span><span class="p">(</span><span class="sr">/email/i</span><span class="p">);</span>
<span class="w">    </span><span class="k">await</span><span class="w"> </span><span class="nx">user</span><span class="p">.</span><span class="nx">type</span><span class="p">(</span><span class="nx">emailInput</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;test@example.com&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">submitButton</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">screen</span><span class="p">.</span><span class="nx">getByRole</span><span class="p">(</span><span class="s2">&quot;button&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="sr">/submit/i</span><span class="w"> </span><span class="p">});</span>
<span class="w">    </span><span class="k">await</span><span class="w"> </span><span class="nx">user</span><span class="p">.</span><span class="nx">click</span><span class="p">(</span><span class="nx">submitButton</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 6. Assert that the mock action was called</span>
<span class="w">    </span><span class="nx">expect</span><span class="p">(</span><span class="nx">mockAction</span><span class="p">).</span><span class="nx">toHaveBeenCalledTimes</span><span class="p">(</span><span class="mf">1</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Optional: Assert what it was called with (more advanced)</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">request</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">mockAction</span><span class="p">.</span><span class="nx">mock</span><span class="p">.</span><span class="nx">calls</span><span class="p">.</span><span class="nx">request</span><span class="p">;</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">formData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">request</span><span class="p">.</span><span class="nx">formData</span><span class="p">();</span>
<span class="w">    </span><span class="nx">expect</span><span class="p">(</span><span class="nx">formData</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">&quot;email&quot;</span><span class="p">)).</span><span class="nx">toBe</span><span class="p">(</span><span class="s2">&quot;test@example.com&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">});</span>
<span class="p">});</span>
</code></pre></div>

<h2 id="deep-dive_3">Deep Dive</h2>
<p>Let's trace the test's execution, as the setup is more complex than a simple component render.</p>
<ol>
<li>
<p><strong><code>jest.fn()</code></strong>: We create a "spy" or mock function. This function doesn't do anything, but it keeps a record of every time it was called, and what arguments it was called with. This is the key to our assertion.</p>
</li>
<li>
<p><strong><code>createMemoryRouter</code></strong>: A standard browser has a real router that uses the URL bar. For our tests in a JSDOM environment, we need a simulated router. <code>createMemoryRouter</code> creates an in-memory router that doesn't rely on a browser history. We provide it our test route configuration.</p>
</li>
<li>
<p><strong><code>&lt;RouterProvider&gt;</code></strong>: Just like in our main application, this component provides the routing context that components like <code>&lt;Form&gt;</code> need to function.</p>
</li>
<li>
<p><strong>Interaction</strong>: <code>userEvent</code> simulates typing into the input and clicking the submit button.</p>
</li>
<li>
<p><strong>The Magic</strong>: When the button is clicked, React Router's <code>&lt;Form&gt;</code> component prevents a real form submission. Instead, it finds the action for the current route (<code>/contact</code>) in our test router, which is our <code>mockAction</code>. It then calls <code>mockAction</code> with a <code>Request</code> object containing the form data.</p>
</li>
<li>
<p><strong>Assertion</strong>: Our test's final step is simple: we ask our mock function, "Were you called?". <code>expect(mockAction).toHaveBeenCalledTimes(1)</code> verifies that the entire chain of events worked correctly. We can even go further and inspect the <code>Request</code> object to ensure the data was correct.</p>
</li>
</ol>
<h2 id="production-perspective_3">Production Perspective</h2>
<ul>
<li><strong>Separation of Concerns</strong>: This testing pattern perfectly mirrors the architectural benefit of Actions. The component test is responsible for verifying that the UI is wired up correctly and that submitting the form triggers the action.</li>
<li><strong>Unit Testing Actions</strong>: The action logic itself (e.g., calling an API, validating data) can be tested separately as a pure function, without needing to render any React components. This leads to faster, more focused tests.</li>
<li><strong>Confidence</strong>: This integration test gives you high confidence that your form works from the user's perspective. It confirms that the inputs have the correct <code>name</code> attributes and that the submission process is correctly handled by React Router.</li>
</ul>
<h2 id="testing-server-components">Testing Server Components</h2>
<h2 id="learning-objective_4">Learning Objective</h2>
<p>Write a unit test for a React Server Component (RSC) to verify its rendered output based on props and mocked data.</p>
<h2 id="why-this-matters_4">Why This Matters</h2>
<p>Server Components run in a different environment (Node.js or an edge runtime) and have different capabilities than client components. They cannot be tested in the same way because they are not interactive and don't run in a browser context. The strategy is to test them as asynchronous functions that return renderable JSX.</p>
<h2 id="discovery-phase_4">Discovery Phase</h2>
<p>Let's test a simple RSC that fetches user data and displays their name.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// src/components/UserProfile.jsx (A Server Component)</span>
<span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;react&quot;</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">fetchUser</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;../api/user&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// A data fetching function</span>

<span class="k">export</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">UserProfile</span><span class="p">({</span><span class="w"> </span><span class="nx">userId</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">user</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">fetchUser</span><span class="p">(</span><span class="nx">userId</span><span class="p">);</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nx">user</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span><span class="nx">User</span><span class="w"> </span><span class="nx">not</span><span class="w"> </span><span class="nx">found</span><span class="p">.&lt;/</span><span class="nt">div</span><span class="p">&gt;;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;{</span><span class="nx">user</span><span class="p">.</span><span class="nx">name</span><span class="p">}&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span><span class="nx">Email</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="nx">user</span><span class="p">.</span><span class="nx">email</span><span class="p">}&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1">// src/components/UserProfile.test.jsx</span>
<span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;react&quot;</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">render</span><span class="p">,</span><span class="w"> </span><span class="nx">screen</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;@testing-library/react&quot;</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">UserProfile</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;./UserProfile&quot;</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">fetchUser</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;../api/user&quot;</span><span class="p">;</span>

<span class="c1">// 1. Mock the entire data fetching module</span>
<span class="nx">jest</span><span class="p">.</span><span class="nx">mock</span><span class="p">(</span><span class="s2">&quot;../api/user&quot;</span><span class="p">);</span>

<span class="nx">describe</span><span class="p">(</span><span class="s2">&quot;UserProfile&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">it</span><span class="p">(</span><span class="s2">&quot;should render the user name and email after fetching data&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 2. Define the mock data for this specific test</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">mockUser</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;John Doe&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">email</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;john.doe@example.com&quot;</span><span class="w"> </span><span class="p">};</span>

<span class="w">    </span><span class="c1">// Configure the mock function to return our data</span>
<span class="w">    </span><span class="nx">fetchUser</span><span class="p">.</span><span class="nx">mockResolvedValue</span><span class="p">(</span><span class="nx">mockUser</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 3. Await the Server Component function to get the JSX promise</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">jsx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">UserProfile</span><span class="p">({</span><span class="w"> </span><span class="nx">userId</span><span class="o">:</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="p">});</span>

<span class="w">    </span><span class="c1">// 4. Render the resulting JSX using RTL</span>
<span class="w">    </span><span class="nx">render</span><span class="p">(</span><span class="nx">jsx</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 5. Assert the content is in the document</span>
<span class="w">    </span><span class="nx">expect</span><span class="p">(</span>
<span class="w">      </span><span class="nx">screen</span><span class="p">.</span><span class="nx">getByRole</span><span class="p">(</span><span class="s2">&quot;heading&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="sr">/john doe/i</span><span class="w"> </span><span class="p">}),</span>
<span class="w">    </span><span class="p">).</span><span class="nx">toBeInTheDocument</span><span class="p">();</span>
<span class="w">    </span><span class="nx">expect</span><span class="p">(</span><span class="nx">screen</span><span class="p">.</span><span class="nx">getByText</span><span class="p">(</span><span class="sr">/john.doe@example.com/i</span><span class="p">)).</span><span class="nx">toBeInTheDocument</span><span class="p">();</span>
<span class="w">  </span><span class="p">});</span>

<span class="w">  </span><span class="nx">it</span><span class="p">(</span><span class="s1">&#39;should render a &quot;not found&quot; message if no user is returned&#39;</span><span class="p">,</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Configure the mock to return null for this test case</span>
<span class="w">    </span><span class="nx">fetchUser</span><span class="p">.</span><span class="nx">mockResolvedValue</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>

<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">jsx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">UserProfile</span><span class="p">({</span><span class="w"> </span><span class="nx">userId</span><span class="o">:</span><span class="w"> </span><span class="mf">99</span><span class="w"> </span><span class="p">});</span>
<span class="w">    </span><span class="nx">render</span><span class="p">(</span><span class="nx">jsx</span><span class="p">);</span>

<span class="w">    </span><span class="nx">expect</span><span class="p">(</span><span class="nx">screen</span><span class="p">.</span><span class="nx">getByText</span><span class="p">(</span><span class="sr">/user not found/i</span><span class="p">)).</span><span class="nx">toBeInTheDocument</span><span class="p">();</span>
<span class="w">  </span><span class="p">});</span>
<span class="p">});</span>
</code></pre></div>

<h2 id="deep-dive_4">Deep Dive</h2>
<p>This testing model is fundamentally different from testing a client component.</p>
<ol>
<li>
<p><strong>Mocking Dependencies</strong>: Server Components often have server-side dependencies, like database clients or API fetchers. In our test, we must mock <code>fetchUser</code>. <code>jest.mock('../api/user')</code> replaces the actual module with a mock version, and <code>fetchUser.mockResolvedValue(mockUser)</code> tells it to return a promise that resolves to our fake user data.</p>
</li>
<li>
<p><strong><code>async</code>/<code>await</code> the Component</strong>: A Server Component that fetches data is an <code>async</code> function. In our test, we can just call it like any other async function: <code>await UserProfile({ userId: 1 })</code>. This executes the component's logic in the Node.js environment provided by Jest.</p>
</li>
<li>
<p><strong>The Result is JSX</strong>: The promise returned by the RSC resolves to the JSX it's supposed to render. It's not HTML yet, just the React element tree.</p>
</li>
<li>
<p><strong>Render and Assert</strong>: Once we have the JSX, we can pass it to RTL's <code>render</code> function. This renders the JSX to JSDOM, and from there we can use <code>screen</code> queries to assert that the correct content was rendered, just like with any other component.</p>
</li>
</ol>
<h3 id="common-confusion-where-is-userevent-why-dont-i-test-clicks">Common Confusion: "Where is <code>userEvent</code>? Why don't I test clicks?"</h3>
<p><strong>You might think</strong>: I need to test user interactions with this component.</p>
<p><strong>Actually</strong>: Server Components have <strong>no interactivity</strong>. They cannot have <code>onClick</code> handlers or <code>useState</code>. Their sole job is to fetch data and produce a UI.</p>
<p><strong>Why the confusion happens</strong>: It's a React component, so our instinct is to test it like one.</p>
<p><strong>How to remember</strong>: Test a Server Component like you would test a template engine. You provide it with inputs (props and mocked data), and you assert that it produces the correct output (the rendered JSX). Any interactivity would be handled by Client Components that you might import into your RSC, and those would be tested separately using <code>userEvent</code>.</p>
<h2 id="production-perspective_4">Production Perspective</h2>
<ul>
<li><strong>Speed</strong>: This testing method is extremely fast. It doesn't need to simulate a full component lifecycle with re-renders. It's just an async function call.</li>
<li><strong>Isolation</strong>: It allows you to test the data-rendering logic of your RSCs in complete isolation from the client-side of your application.</li>
<li><strong>Focus</strong>: This forces you to test what the RSC is actually responsible for: correctly transforming data into a UI.</li>
</ul>
<h2 id="testing-hooks">Testing Hooks</h2>
<h2 id="learning-objective_5">Learning Objective</h2>
<p>Isolate and test the logic of a custom hook using the <code>renderHook</code> utility from React Testing Library.</p>
<h2 id="why-this-matters_5">Why This Matters</h2>
<p>Custom hooks are the primary way to extract and reuse stateful logic in modern React. This logic is often complex and critical to your application's functionality. Testing a hook in isolation, without needing to render a full component, results in simpler, faster, and more focused tests of your core business logic.</p>
<h2 id="discovery-phase_5">Discovery Phase</h2>
<p>Let's create and test a simple <code>useToggle</code> custom hook.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// src/hooks/useToggle.js</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">useState</span><span class="p">,</span><span class="w"> </span><span class="nx">useCallback</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;react&quot;</span><span class="p">;</span>

<span class="k">export</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">useToggle</span><span class="p">(</span><span class="nx">initialValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">value</span><span class="p">,</span><span class="w"> </span><span class="nx">setValue</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">(</span><span class="nx">initialValue</span><span class="p">);</span>

<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">toggle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useCallback</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">setValue</span><span class="p">((</span><span class="nx">v</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="o">!</span><span class="nx">v</span><span class="p">);</span>
<span class="w">  </span><span class="p">},</span><span class="w"> </span><span class="p">[]);</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">[</span><span class="nx">value</span><span class="p">,</span><span class="w"> </span><span class="nx">toggle</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1">// src/hooks/useToggle.test.js</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">renderHook</span><span class="p">,</span><span class="w"> </span><span class="nx">act</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;@testing-library/react&quot;</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">useToggle</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;./useToggle&quot;</span><span class="p">;</span>

<span class="nx">describe</span><span class="p">(</span><span class="s2">&quot;useToggle&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">it</span><span class="p">(</span><span class="s2">&quot;should initialize with the default value of false&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 1. Render the hook using renderHook</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">result</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">renderHook</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">useToggle</span><span class="p">());</span>

<span class="w">    </span><span class="c1">// 2. Access the hook&#39;s return value via `result.current`</span>
<span class="w">    </span><span class="nx">expect</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">current</span><span class="p">).</span><span class="nx">toBe</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
<span class="w">  </span><span class="p">});</span>

<span class="w">  </span><span class="nx">it</span><span class="p">(</span><span class="s2">&quot;should initialize with a provided initial value&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">result</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">renderHook</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">useToggle</span><span class="p">(</span><span class="kc">true</span><span class="p">));</span>
<span class="w">    </span><span class="nx">expect</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">current</span><span class="p">).</span><span class="nx">toBe</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
<span class="w">  </span><span class="p">});</span>

<span class="w">  </span><span class="nx">it</span><span class="p">(</span><span class="s2">&quot;should toggle the value when the toggle function is called&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">result</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">renderHook</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">useToggle</span><span class="p">());</span>

<span class="w">    </span><span class="c1">// 3. Wrap any action that causes a state update in `act()`</span>
<span class="w">    </span><span class="nx">act</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// result.current is our `toggle` function</span>
<span class="w">      </span><span class="nx">result</span><span class="p">.</span><span class="nx">current</span><span class="p">();</span>
<span class="w">    </span><span class="p">});</span>

<span class="w">    </span><span class="c1">// 4. Assert that the value has changed</span>
<span class="w">    </span><span class="nx">expect</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">current</span><span class="p">).</span><span class="nx">toBe</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Toggle it back</span>
<span class="w">    </span><span class="nx">act</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">result</span><span class="p">.</span><span class="nx">current</span><span class="p">();</span>
<span class="w">    </span><span class="p">});</span>
<span class="w">    </span><span class="nx">expect</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">current</span><span class="p">).</span><span class="nx">toBe</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
<span class="w">  </span><span class="p">});</span>
<span class="p">});</span>
</code></pre></div>

<h2 id="deep-dive_5">Deep Dive</h2>
<h3 id="renderhook"><code>renderHook</code></h3>
<p>You can't call a hook from a regular JavaScript function; it must be called from within a React component. The <code>renderHook</code> utility does exactly this for you. It creates a tiny, invisible test harness component, calls your hook inside of it, and gives you access to its return value.</p>
<p>The object returned by <code>renderHook</code> contains a few properties, but the most important one is <code>result</code>.</p>
<ul>
<li><strong><code>result.current</code></strong>: This property always holds the most recent return value of your hook. When the hook's state updates and it "re-renders" within the test harness, <code>result.current</code> will be updated to reflect the new return value.</li>
</ul>
<h3 id="act"><code>act()</code></h3>
<p>React updates state asynchronously in batches. In a test environment, we need a way to ensure that all state updates and effects have been processed before we make our assertions. The <code>act</code> utility does this.</p>
<p><strong>Rule of thumb</strong>: Any code that triggers a state update in your hook (e.g., calling a function it returns) must be wrapped in <code>act()</code>.</p>
<p>When you use <code>userEvent</code> to test a full component, it automatically wraps its actions in <code>act</code> for you. But when testing a hook in isolation, you have to do it manually.</p>
<p>The test flow is:</p>
<ol>
<li><code>renderHook</code> to get the initial state.</li>
<li>Assert the initial state.</li>
<li>Wrap a state-updating call in <code>act()</code>.</li>
<li>Assert the new state reflected in <code>result.current</code>.</li>
</ol>
<h2 id="production-perspective_5">Production Perspective</h2>
<ul>
<li><strong>Logic vs. UI</strong>: Testing hooks allows you to completely separate the testing of your business logic from the testing of your UI. This aligns perfectly with the purpose of hooks themselves.</li>
<li><strong>Speed and Simplicity</strong>: A hook test is a unit test. It's much faster and simpler than a full component integration test. For a complex piece of logic, it's far easier to test all the edge cases in a hook test than by trying to simulate them through component interactions.</li>
<li><strong>Refactoring Confidence</strong>: If you have thorough tests for your custom hooks, you can confidently refactor the components that use them, knowing that the underlying logic is solid.</li>
</ul>
<h2 id="testing-async-behavior">Testing Async Behavior</h2>
<h2 id="learning-objective_6">Learning Objective</h2>
<p>Write tests for components that fetch data, correctly handling and asserting loading, success, and error states using asynchronous queries.</p>
<h2 id="why-this-matters_6">Why This Matters</h2>
<p>A huge portion of a modern web application involves fetching data from an API. Your components need to handle the entire lifecycle of these requests: showing a loading indicator, displaying the data when it arrives, and showing an error message if it fails. Your tests must be able to verify all three of these states to be complete.</p>
<h2 id="discovery-phase_6">Discovery Phase</h2>
<p>Let's test a component that fetches and displays a user's name from an API.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// src/components/UserData.jsx</span>
<span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">useState</span><span class="p">,</span><span class="w"> </span><span class="nx">useEffect</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;react&quot;</span><span class="p">;</span>

<span class="k">export</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">UserData</span><span class="p">({</span><span class="w"> </span><span class="nx">userId</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">user</span><span class="p">,</span><span class="w"> </span><span class="nx">setUser</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">loading</span><span class="p">,</span><span class="w"> </span><span class="nx">setLoading</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">error</span><span class="p">,</span><span class="w"> </span><span class="nx">setError</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>

<span class="w">  </span><span class="nx">useEffect</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">setLoading</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
<span class="w">    </span><span class="nx">fetch</span><span class="p">(</span><span class="sb">`https://api.example.com/users/</span><span class="si">${</span><span class="nx">userId</span><span class="si">}</span><span class="sb">`</span><span class="p">)</span>
<span class="w">      </span><span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">res</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nx">res</span><span class="p">.</span><span class="nx">ok</span><span class="p">)</span><span class="w"> </span><span class="k">throw</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="ne">Error</span><span class="p">(</span><span class="s2">&quot;Failed to fetch&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">();</span>
<span class="w">      </span><span class="p">})</span>
<span class="w">      </span><span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">data</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">setUser</span><span class="p">(</span><span class="nx">data</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">err</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">setError</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nx">message</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="k">finally</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">setLoading</span><span class="p">(</span><span class="kc">false</span><span class="p">));</span>
<span class="w">  </span><span class="p">},</span><span class="w"> </span><span class="p">[</span><span class="nx">userId</span><span class="p">]);</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">loading</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span><span class="nx">Loading</span><span class="p">...&lt;/</span><span class="nt">div</span><span class="p">&gt;;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">error</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span><span class="ne">Error</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="nx">error</span><span class="p">}&lt;/</span><span class="nt">div</span><span class="p">&gt;;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nx">user</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span><span class="nx">Welcome</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="nx">user</span><span class="p">.</span><span class="nx">name</span><span class="p">}&lt;/</span><span class="nt">h1</span><span class="p">&gt;;</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1">// src/components/UserData.test.jsx</span>
<span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;react&quot;</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">render</span><span class="p">,</span><span class="w"> </span><span class="nx">screen</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;@testing-library/react&quot;</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">UserData</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;./UserData&quot;</span><span class="p">;</span>

<span class="c1">// Mock the global fetch function</span>
<span class="nb">global</span><span class="p">.</span><span class="nx">fetch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">jest</span><span class="p">.</span><span class="nx">fn</span><span class="p">();</span>

<span class="nx">describe</span><span class="p">(</span><span class="s2">&quot;UserData&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">beforeEach</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Clear mock history before each test</span>
<span class="w">    </span><span class="nx">fetch</span><span class="p">.</span><span class="nx">mockClear</span><span class="p">();</span>
<span class="w">  </span><span class="p">});</span>

<span class="w">  </span><span class="nx">it</span><span class="p">(</span><span class="s2">&quot;should show a loading message initially and then display the user name&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">mockUser</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Alice&quot;</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="nx">fetch</span><span class="p">.</span><span class="nx">mockResolvedValueOnce</span><span class="p">({</span>
<span class="w">      </span><span class="nx">ok</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">      </span><span class="nx">json</span><span class="o">:</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">mockUser</span><span class="p">,</span>
<span class="w">    </span><span class="p">});</span>

<span class="w">    </span><span class="nx">render</span><span class="p">(&lt;</span><span class="nt">UserData</span><span class="w"> </span><span class="na">userId</span><span class="o">=</span><span class="p">{</span><span class="mf">1</span><span class="p">}</span><span class="w"> </span><span class="p">/&gt;);</span>

<span class="w">    </span><span class="c1">// 1. Assert the initial loading state</span>
<span class="w">    </span><span class="nx">expect</span><span class="p">(</span><span class="nx">screen</span><span class="p">.</span><span class="nx">getByText</span><span class="p">(</span><span class="s2">&quot;Loading...&quot;</span><span class="p">)).</span><span class="nx">toBeInTheDocument</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// 2. Use `findBy` to wait for the success state to appear</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">heading</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">screen</span><span class="p">.</span><span class="nx">findByRole</span><span class="p">(</span><span class="s2">&quot;heading&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="sr">/welcome, alice/i</span><span class="p">,</span>
<span class="w">    </span><span class="p">});</span>
<span class="w">    </span><span class="nx">expect</span><span class="p">(</span><span class="nx">heading</span><span class="p">).</span><span class="nx">toBeInTheDocument</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// 3. Assert that the loading message is gone</span>
<span class="w">    </span><span class="nx">expect</span><span class="p">(</span><span class="nx">screen</span><span class="p">.</span><span class="nx">queryByText</span><span class="p">(</span><span class="s2">&quot;Loading...&quot;</span><span class="p">)).</span><span class="nx">not</span><span class="p">.</span><span class="nx">toBeInTheDocument</span><span class="p">();</span>
<span class="w">  </span><span class="p">});</span>

<span class="w">  </span><span class="nx">it</span><span class="p">(</span><span class="s2">&quot;should display an error message if the fetch fails&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Mock a failed network request</span>
<span class="w">    </span><span class="nx">fetch</span><span class="p">.</span><span class="nx">mockRejectedValueOnce</span><span class="p">(</span><span class="ow">new</span><span class="w"> </span><span class="ne">Error</span><span class="p">(</span><span class="s2">&quot;Network error&quot;</span><span class="p">));</span>

<span class="w">    </span><span class="nx">render</span><span class="p">(&lt;</span><span class="nt">UserData</span><span class="w"> </span><span class="na">userId</span><span class="o">=</span><span class="p">{</span><span class="mf">2</span><span class="p">}</span><span class="w"> </span><span class="p">/&gt;);</span>

<span class="w">    </span><span class="c1">// Wait for and assert the error message</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">errorMessage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">screen</span><span class="p">.</span><span class="nx">findByText</span><span class="p">(</span><span class="sr">/error/i</span><span class="p">);</span>
<span class="w">    </span><span class="nx">expect</span><span class="p">(</span><span class="nx">errorMessage</span><span class="p">).</span><span class="nx">toBeInTheDocument</span><span class="p">();</span>
<span class="w">  </span><span class="p">});</span>
<span class="p">});</span>
</code></pre></div>

<h2 id="deep-dive_6">Deep Dive</h2>
<h3 id="mocking-fetch">Mocking <code>fetch</code></h3>
<p>The first step in any async test is to take control of the asynchronous process. We don't want our tests to make real network requests. They would be slow, unreliable, and dependent on an external service. By mocking <code>global.fetch</code>, we can instantly resolve or reject the fetch promise with whatever data we want, allowing us to test different scenarios predictably.</p>
<h3 id="getby-vs-findby-vs-queryby"><code>getBy</code> vs. <code>findBy</code> vs. <code>queryBy</code></h3>
<p>RTL provides three families of queries for different situations.</p>
<ul>
<li><strong><code>getBy...</code></strong>: Finds an element or throws an error immediately if it's not found. Use this for asserting elements you expect to be on the screen right after a render. (e.g., the initial "Loading..." message).</li>
<li><strong><code>queryBy...</code></strong>: Finds an element or returns <code>null</code> if it's not found. It does not throw an error. Use this for asserting that an element is <strong>not</strong> on the screen. (e.g., <code>expect(screen.queryByText('Loading...')).not.toBeInTheDocument()</code>).</li>
<li><strong><code>findBy...</code></strong>: Returns a promise that resolves when the element is found. If the element is not found after a default timeout (usually 1000ms), the promise rejects and the test fails. This is the <strong>primary tool for testing asynchronous UI updates</strong>.</li>
</ul>
<p>When we <code>await screen.findByRole('heading', ...)</code> RTL will repeatedly check the DOM until the heading appears or the timeout is reached. This is how we wait for our <code>fetch</code> promise to resolve and our component to re-render with the new data.</p>
<h3 id="waitfor"><code>waitFor</code></h3>
<p>Sometimes you need to wait for something to happen that isn't just an element appearing. The <code>waitFor</code> utility can be used for this. It takes an async callback and waits until the assertions inside it pass.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// Example of using waitFor</span>
<span class="k">await</span><span class="w"> </span><span class="nx">waitFor</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">expect</span><span class="p">(</span><span class="nx">myMockFunction</span><span class="p">).</span><span class="nx">toHaveBeenCalledTimes</span><span class="p">(</span><span class="mf">1</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div>

<h2 id="production-perspective_6">Production Perspective</h2>
<ul>
<li><strong>Mock Service Worker (MSW)</strong>: While mocking <code>fetch</code> globally is fine for simple tests, it can become cumbersome in a large application. <strong>Mock Service Worker (MSW)</strong> is a library that allows you to define a mock API server that intercepts network requests at the network level. This is a more robust and scalable approach, as you can define your mock API once and reuse it across all your tests, and even during development.</li>
<li><strong>Testing All States</strong>: A robust test suite for an async component will always have at least three tests: one for the loading state, one for the success state, and one for the error state. This ensures you've handled all possible outcomes of the asynchronous operation.</li>
</ul>
<h2 id="integration-testing">Integration Testing</h2>
<h2 id="learning-objective_7">Learning Objective</h2>
<p>Write an integration test that simulates a complete user flow across multiple components and routes, verifying that they work together as expected.</p>
<h2 id="why-this-matters_7">Why This Matters</h2>
<p>Unit tests are great for verifying individual pieces, but they don't guarantee that the pieces fit together correctly. Integration tests provide this guarantee. By testing a complete user journey, you gain a high degree of confidence that your application is working from the user's perspective. This is the largest and most valuable part of the "Testing Trophy".</p>
<h2 id="discovery-phase_7">Discovery Phase</h2>
<p>Let's test a simple multi-page application. A user starts on a home page with a link to a "Users" page. Clicking the link should navigate them to a list of users.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// src/App.jsx (A simplified app with routing)</span>
<span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;react&quot;</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">Link</span><span class="p">,</span>
<span class="w">  </span><span class="nx">Outlet</span><span class="p">,</span>
<span class="w">  </span><span class="nx">createMemoryRouter</span><span class="p">,</span>
<span class="w">  </span><span class="nx">RouterProvider</span><span class="p">,</span>
<span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;react-router-dom&quot;</span><span class="p">;</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">HomePage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">(</span>
<span class="w">  </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span><span class="nx">Home</span><span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">Link</span><span class="w"> </span><span class="na">to</span><span class="o">=</span><span class="s">&quot;/users&quot;</span><span class="p">&gt;</span><span class="nx">View</span><span class="w"> </span><span class="nx">Users</span><span class="p">&lt;/</span><span class="nt">Link</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="p">);</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">UsersPage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">(</span>
<span class="w">  </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span><span class="nx">Users</span><span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">ul</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">li</span><span class="p">&gt;</span><span class="nx">Alice</span><span class="p">&lt;/</span><span class="nt">li</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">li</span><span class="p">&gt;</span><span class="nx">Bob</span><span class="p">&lt;/</span><span class="nt">li</span><span class="p">&gt;</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">ul</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="p">);</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">routerConfig</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="nx">path</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;/&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">element</span><span class="o">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">HomePage</span><span class="w"> </span><span class="p">/&gt;</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="nx">path</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;/users&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">element</span><span class="o">:</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">UsersPage</span><span class="w"> </span><span class="p">/&gt;</span><span class="w"> </span><span class="p">},</span>
<span class="p">];</span>

<span class="c1">// We export the router creation to use in our test</span>
<span class="k">export</span><span class="w"> </span><span class="kd">const</span><span class="w"> </span><span class="nx">createAppRouter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">initialEntries</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;/&quot;</span><span class="p">])</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">createMemoryRouter</span><span class="p">(</span><span class="nx">routerConfig</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">initialEntries</span><span class="w"> </span><span class="p">});</span>
<span class="p">};</span>

<span class="c1">// The main App component</span>
<span class="k">export</span><span class="w"> </span><span class="kd">const</span><span class="w"> </span><span class="nx">App</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">router</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">createAppRouter</span><span class="p">();</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">RouterProvider</span><span class="w"> </span><span class="na">router</span><span class="o">=</span><span class="p">{</span><span class="nx">router</span><span class="p">}</span><span class="w"> </span><span class="p">/&gt;;</span>
<span class="p">};</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1">// src/App.test.jsx</span>
<span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;react&quot;</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">render</span><span class="p">,</span><span class="w"> </span><span class="nx">screen</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;@testing-library/react&quot;</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="nx">userEvent</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;@testing-library/user-event&quot;</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">RouterProvider</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;react-router-dom&quot;</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">createAppRouter</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;./App&quot;</span><span class="p">;</span>

<span class="nx">describe</span><span class="p">(</span><span class="s2">&quot;App Navigation Flow&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">it</span><span class="p">(</span><span class="s2">&quot;should navigate from the home page to the users page&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">user</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">userEvent</span><span class="p">.</span><span class="nx">setup</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// 1. Create a router instance for the test</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">router</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">createAppRouter</span><span class="p">([</span><span class="s2">&quot;/&quot;</span><span class="p">]);</span><span class="w"> </span><span class="c1">// Start at the home page</span>

<span class="w">    </span><span class="c1">// 2. Render the application with the test router</span>
<span class="w">    </span><span class="nx">render</span><span class="p">(&lt;</span><span class="nt">RouterProvider</span><span class="w"> </span><span class="na">router</span><span class="o">=</span><span class="p">{</span><span class="nx">router</span><span class="p">}</span><span class="w"> </span><span class="p">/&gt;);</span>

<span class="w">    </span><span class="c1">// 3. Verify we are on the home page</span>
<span class="w">    </span><span class="nx">expect</span><span class="p">(</span><span class="nx">screen</span><span class="p">.</span><span class="nx">getByRole</span><span class="p">(</span><span class="s2">&quot;heading&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="sr">/home/i</span><span class="w"> </span><span class="p">})).</span><span class="nx">toBeInTheDocument</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// 4. Simulate the user clicking the link</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">usersLink</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">screen</span><span class="p">.</span><span class="nx">getByRole</span><span class="p">(</span><span class="s2">&quot;link&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="sr">/view users/i</span><span class="w"> </span><span class="p">});</span>
<span class="w">    </span><span class="k">await</span><span class="w"> </span><span class="nx">user</span><span class="p">.</span><span class="nx">click</span><span class="p">(</span><span class="nx">usersLink</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 5. Wait for the new page to appear and assert its content</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">usersHeading</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">screen</span><span class="p">.</span><span class="nx">findByRole</span><span class="p">(</span><span class="s2">&quot;heading&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="sr">/users/i</span><span class="w"> </span><span class="p">});</span>
<span class="w">    </span><span class="nx">expect</span><span class="p">(</span><span class="nx">usersHeading</span><span class="p">).</span><span class="nx">toBeInTheDocument</span><span class="p">();</span>
<span class="w">    </span><span class="nx">expect</span><span class="p">(</span><span class="nx">screen</span><span class="p">.</span><span class="nx">getByText</span><span class="p">(</span><span class="s2">&quot;Alice&quot;</span><span class="p">)).</span><span class="nx">toBeInTheDocument</span><span class="p">();</span>
<span class="w">  </span><span class="p">});</span>
<span class="p">});</span>
</code></pre></div>

<h2 id="deep-dive_7">Deep Dive</h2>
<p>This test combines many of the techniques we've already learned into a single, powerful flow.</p>
<ul>
<li><strong>Test Setup</strong>: Just like in our Actions test, we use <code>createMemoryRouter</code> to provide a routing context. This is essential for any test that involves navigation. We render the entire application wrapped in the <code>&lt;RouterProvider&gt;</code>.</li>
<li><strong>Arrange, Act, Assert</strong>: The test follows the classic AAA pattern.</li>
<li><strong>Arrange</strong>: We set up the router and render the application. We assert our starting condition (we're on the home page).</li>
<li><strong>Act</strong>: The user performs an action: <code>await user.click(usersLink)</code>.</li>
<li><strong>Assert</strong>: We assert the outcome. The URL changes, and the <code>UsersPage</code> component should be rendered. We use <code>findByRole</code> to wait for the asynchronous navigation and re-render to complete.</li>
</ul>
<h3 id="the-power-of-black-box-testing">The Power of Black-Box Testing</h3>
<p>Notice what this test <em>doesn't</em> know:</p>
<ul>
<li>It doesn't know about the <code>HomePage</code> or <code>UsersPage</code> components.</li>
<li>It doesn't know that clicking the link changes the URL.</li>
<li>It doesn't know how the router works internally.</li>
</ul>
<p>The test behaves exactly like a user: it finds a link with certain text, clicks it, and expects to see new content on the screen. This is a form of <strong>black-box testing</strong>. Because the test is not coupled to the implementation details, you could completely refactor your routing setup or component structure, and as long as the user flow remains the same, the test will continue to pass.</p>
<h2 id="production-perspective_7">Production Perspective</h2>
<ul>
<li><strong>Critical User Flows</strong>: In a real application, you would write integration tests for your most important user journeys.</li>
<li>Can a user successfully log in and see their dashboard?</li>
<li>Can a user add a product to the cart and complete the checkout process?</li>
<li>Can a user create, edit, and delete a post?</li>
<li><strong>Confidence vs. Cost</strong>: These tests provide the highest level of confidence outside of full E2E tests. They are slower to run than unit tests because they render more components, but the value they provide in verifying that your application works as a cohesive whole is immense. A good test suite has a healthy number of these core integration tests.</li>
</ul>
<h2 id="end-to-end-testing-with-playwright">End-to-End Testing with Playwright</h2>
<h2 id="learning-objective_8">Learning Objective</h2>
<p>Understand the purpose of End-to-End (E2E) testing and how it differs from integration testing with React Testing Library.</p>
<h2 id="why-this-matters_8">Why This Matters</h2>
<p>The Testing Trophy is topped with E2E tests for a reason. While RTL integration tests give you confidence that your React code works together, they run in a simulated environment. E2E tests are the ultimate verification: they run your <em>entire</em>, fully-built application in a <em>real</em> browser, interacting with your <em>real</em> backend. They are your final line of defense against bugs that only appear in a production-like environment.</p>
<h2 id="discovery-phase_8">Discovery Phase</h2>
<p>Let's look at what a simple login test might look like using <strong>Playwright</strong>, a popular E2E testing framework. This code would live in a separate test suite, outside of your main Jest/RTL setup.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// tests/login.spec.js (This is a Playwright test file)</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">test</span><span class="p">,</span><span class="w"> </span><span class="nx">expect</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;@playwright/test&quot;</span><span class="p">;</span>

<span class="nx">test</span><span class="p">.</span><span class="nx">describe</span><span class="p">(</span><span class="s2">&quot;Login Flow&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">test</span><span class="p">(</span><span class="s2">&quot;should allow a user to log in and see the dashboard&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">({</span>
<span class="w">    </span><span class="nx">page</span><span class="p">,</span>
<span class="w">  </span><span class="p">})</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 1. Navigate to the running application&#39;s login page</span>
<span class="w">    </span><span class="k">await</span><span class="w"> </span><span class="nx">page</span><span class="p">.</span><span class="kr">goto</span><span class="p">(</span><span class="s2">&quot;http://localhost:3000/login&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 2. Find elements and interact with them using browser-level selectors</span>
<span class="w">    </span><span class="k">await</span><span class="w"> </span><span class="nx">page</span><span class="p">.</span><span class="nx">getByLabel</span><span class="p">(</span><span class="s2">&quot;Email&quot;</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="s2">&quot;test@example.com&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">await</span><span class="w"> </span><span class="nx">page</span><span class="p">.</span><span class="nx">getByLabel</span><span class="p">(</span><span class="s2">&quot;Password&quot;</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="s2">&quot;password123&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">await</span><span class="w"> </span><span class="nx">page</span><span class="p">.</span><span class="nx">getByRole</span><span class="p">(</span><span class="s2">&quot;button&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Log In&quot;</span><span class="w"> </span><span class="p">}).</span><span class="nx">click</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// 3. Wait for navigation and assert the new page&#39;s content</span>
<span class="w">    </span><span class="c1">// This will wait for the URL to change to &#39;/dashboard&#39;</span>
<span class="w">    </span><span class="k">await</span><span class="w"> </span><span class="nx">page</span><span class="p">.</span><span class="nx">waitForURL</span><span class="p">(</span><span class="s2">&quot;http://localhost:3000/dashboard&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Assert that an element on the dashboard is visible</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">welcomeMessage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">page</span><span class="p">.</span><span class="nx">getByRole</span><span class="p">(</span><span class="s2">&quot;heading&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="sr">/welcome/i</span><span class="w"> </span><span class="p">});</span>
<span class="w">    </span><span class="k">await</span><span class="w"> </span><span class="nx">expect</span><span class="p">(</span><span class="nx">welcomeMessage</span><span class="p">).</span><span class="nx">toBeVisible</span><span class="p">();</span>
<span class="w">  </span><span class="p">});</span>
<span class="p">});</span>
</code></pre></div>

<h2 id="deep-dive_8">Deep Dive</h2>
<h3 id="rtl-vs-playwright-key-differences">RTL vs. Playwright: Key Differences</h3>
<table>
<thead>
<tr>
<th style="text-align: left;">Feature</th>
<th style="text-align: left;">React Testing Library (Integration)</th>
<th style="text-align: left;">Playwright (End-to-End)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>Environment</strong></td>
<td style="text-align: left;">Node.js + JSDOM (a simulated browser)</td>
<td style="text-align: left;">A real browser (Chrome, Firefox, Safari)</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Scope</strong></td>
<td style="text-align: left;">Tests your React components in isolation from the backend.</td>
<td style="text-align: left;">Tests your entire application stack (frontend + backend + database).</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Execution</strong></td>
<td style="text-align: left;">Runs your source code directly.</td>
<td style="text-align: left;">Interacts with your fully built, running application via HTTP.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Speed</strong></td>
<td style="text-align: left;">Fast (milliseconds to seconds per test).</td>
<td style="text-align: left;">Slow (seconds to minutes per test).</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Assertions</strong></td>
<td style="text-align: left;">Asserts that components render correctly and state is managed.</td>
<td style="text-align: left;">Asserts that real user journeys work across the entire system.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Debugging</strong></td>
<td style="text-align: left;">Debug in your code editor and console.</td>
<td style="text-align: left;">Provides powerful debugging tools like video recordings and trace viewers.</td>
</tr>
</tbody>
</table>
<h3 id="why-do-you-need-both">Why Do You Need Both?</h3>
<ul>
<li><strong>RTL Integration Tests</strong> are for verifying that your React application's UI logic is correct. They are fast and you can write many of them. They answer the question: "Did I build the thing right?"</li>
<li><strong>E2E Tests</strong> are for verifying that the entire system is integrated correctly. They catch problems that RTL can't, such as:</li>
<li>Backend API errors or contract mismatches.</li>
<li>Environment configuration issues.</li>
<li>CSS bugs that only appear in a real browser rendering engine.</li>
<li>Authentication and database problems.</li>
</ul>
<p>E2E tests answer the question: "Did I build the right thing, and does it actually work in the real world?"</p>
<h2 id="production-perspective_8">Production Perspective</h2>
<ul>
<li><strong>The Tip of the Trophy</strong>: E2E tests are powerful but also the most expensive to write, run, and maintain. They can be "flaky" (failing intermittently due to network issues or timing). For this reason, you should have only a few of them.</li>
<li><strong>Critical Paths Only</strong>: Reserve E2E tests for your application's most critical, "money-making" paths.</li>
<li>User registration and login.</li>
<li>The core checkout or purchase flow.</li>
<li>The main feature that defines your product.</li>
<li><strong>Smoke Tests</strong>: E2E tests are often used as "smoke tests" after a deployment. You run a quick suite of E2E tests against your newly deployed production environment to get a signal that nothing is fundamentally broken.</li>
<li><strong>Frameworks</strong>: <strong>Playwright</strong> and <strong>Cypress</strong> are the two leading frameworks in this space. Both are excellent choices for modern E2E testing.</li>
</ul>
<h2 id="test-driven-development-with-react">Test-Driven Development with React</h2>
<h2 id="learning-objective_9">Learning Objective</h2>
<p>Apply the Test-Driven Development (TDD) workflow of "Red, Green, Refactor" to build a React component.</p>
<h2 id="why-this-matters_9">Why This Matters</h2>
<p>Test-Driven Development is a methodology that flips the usual development process on its head. Instead of writing your component and then writing tests for it, you write a failing test first, then write the component code to make it pass. This process can lead to better-designed, more testable components and ensures that every line of code you write is covered by a test.</p>
<h2 id="discovery-phase_9">Discovery Phase</h2>
<p>Let's build a simple <code>Accordion</code> component using the TDD workflow. It should display a title, and when the title is clicked, it should reveal some content.</p>
<h3 id="step-1-red-write-a-failing-test">Step 1: Red - Write a Failing Test</h3>
<p>Our first requirement is that the content should not be visible by default.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// src/components/Accordion.test.jsx</span>
<span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;react&quot;</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">render</span><span class="p">,</span><span class="w"> </span><span class="nx">screen</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;@testing-library/react&quot;</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="nx">userEvent</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;@testing-library/user-event&quot;</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">Accordion</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;./Accordion&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// This file doesn&#39;t exist yet!</span>

<span class="nx">describe</span><span class="p">(</span><span class="s2">&quot;Accordion&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">it</span><span class="p">(</span><span class="s2">&quot;should not show the content by default&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">render</span><span class="p">(&lt;</span><span class="nt">Accordion</span><span class="w"> </span><span class="na">title</span><span class="o">=</span><span class="s">&quot;Test Title&quot;</span><span class="w"> </span><span class="na">content</span><span class="o">=</span><span class="s">&quot;Some content&quot;</span><span class="w"> </span><span class="p">/&gt;);</span>

<span class="w">    </span><span class="c1">// `queryByText` returns null if not found, so this is perfect for asserting absence.</span>
<span class="w">    </span><span class="nx">expect</span><span class="p">(</span><span class="nx">screen</span><span class="p">.</span><span class="nx">queryByText</span><span class="p">(</span><span class="s2">&quot;Some content&quot;</span><span class="p">)).</span><span class="nx">not</span><span class="p">.</span><span class="nx">toBeInTheDocument</span><span class="p">();</span>
<span class="w">  </span><span class="p">});</span>
<span class="p">});</span>
</code></pre></div>

<p><strong>Run the test.</strong> It will fail spectacularly because <code>Accordion.jsx</code> doesn't even exist. This is the "Red" step.</p>
<h3 id="step-2-green-make-the-test-pass">Step 2: Green - Make the Test Pass</h3>
<p>Now, we write the <em>absolute minimum</em> amount of code to make this test pass.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// src/components/Accordion.jsx</span>
<span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;react&quot;</span><span class="p">;</span>

<span class="k">export</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">Accordion</span><span class="p">({</span><span class="w"> </span><span class="nx">title</span><span class="p">,</span><span class="w"> </span><span class="nx">content</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// We don&#39;t even need state yet. Just don&#39;t render the content.</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">button</span><span class="p">&gt;{</span><span class="nx">title</span><span class="p">}&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>Run the test again.</strong> It now passes! The content isn't rendered, so <code>queryByText</code> returns <code>null</code>. This is the "Green" step.</p>
<h3 id="step-3-red-write-the-next-failing-test">Step 3: Red - Write the Next Failing Test</h3>
<p>Our next requirement is that clicking the title reveals the content.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// Add this test to Accordion.test.jsx</span>
<span class="nx">it</span><span class="p">(</span><span class="s2">&quot;should show the content after clicking the title&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">user</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">userEvent</span><span class="p">.</span><span class="nx">setup</span><span class="p">();</span>
<span class="w">  </span><span class="nx">render</span><span class="p">(&lt;</span><span class="nt">Accordion</span><span class="w"> </span><span class="na">title</span><span class="o">=</span><span class="s">&quot;Test Title&quot;</span><span class="w"> </span><span class="na">content</span><span class="o">=</span><span class="s">&quot;Some content&quot;</span><span class="w"> </span><span class="p">/&gt;);</span>

<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">titleButton</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">screen</span><span class="p">.</span><span class="nx">getByRole</span><span class="p">(</span><span class="s2">&quot;button&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="sr">/test title/i</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="k">await</span><span class="w"> </span><span class="nx">user</span><span class="p">.</span><span class="nx">click</span><span class="p">(</span><span class="nx">titleButton</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// This will fail because our component has no logic to show the content.</span>
<span class="w">  </span><span class="nx">expect</span><span class="p">(</span><span class="nx">screen</span><span class="p">.</span><span class="nx">getByText</span><span class="p">(</span><span class="s2">&quot;Some content&quot;</span><span class="p">)).</span><span class="nx">toBeInTheDocument</span><span class="p">();</span>
<span class="p">});</span>
</code></pre></div>

<p><strong>Run the tests.</strong> The first test still passes, but our new test fails. We are back to "Red".</p>
<h3 id="step-4-green-make-it-pass-again">Step 4: Green - Make It Pass Again</h3>
<p>Now we add the logic to our component to handle the click.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// src/components/Accordion.jsx</span>
<span class="k">import</span><span class="w"> </span><span class="nx">React</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">useState</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;react&quot;</span><span class="p">;</span>

<span class="k">export</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">Accordion</span><span class="p">({</span><span class="w"> </span><span class="nx">title</span><span class="p">,</span><span class="w"> </span><span class="nx">content</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">isOpen</span><span class="p">,</span><span class="w"> </span><span class="nx">setIsOpen</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">button</span><span class="w"> </span><span class="na">onClick</span><span class="o">=</span><span class="p">{()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">setIsOpen</span><span class="p">(</span><span class="o">!</span><span class="nx">isOpen</span><span class="p">)}&gt;{</span><span class="nx">title</span><span class="p">}&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">{</span><span class="nx">isOpen</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;{</span><span class="nx">content</span><span class="p">}&lt;/</span><span class="nt">div</span><span class="p">&gt;}</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>Run the tests.</strong> Both tests now pass! We are "Green" again.</p>
<h3 id="step-5-refactor">Step 5: Refactor</h3>
<p>Our component is simple, so there isn't much to refactor. But at this stage, you could clean up variable names, extract sub-components, or improve styling, all while continuously running your tests to ensure you haven't broken anything. This cycle‚ÄîRed, Green, Refactor‚Äîrepeats for every new feature you add to the component.</p>
<h2 id="deep-dive_9">Deep Dive</h2>
<p>The TDD cycle is a powerful feedback loop:</p>
<ul>
<li><strong>Red</strong>: Writing the test first forces you to think from the user's perspective. What should this component do? What is its public API (its props)? It clearly defines the "what" before you think about the "how".</li>
<li><strong>Green</strong>: Writing the simplest code to pass the test prevents over-engineering. You only write code in response to a failing test, so you only write code that is strictly necessary.</li>
<li><strong>Refactor</strong>: With a safety net of passing tests, you are free to improve the implementation details of your component without fear.</li>
</ul>
<h2 id="production-perspective_9">Production Perspective</h2>
<ul>
<li><strong>A Discipline, Not a Dogma</strong>: Not every developer practices pure TDD for every component. However, the mindset it encourages is invaluable. Even if you write your tests just after you write your code (a practice called "Test-After Development"), the process of thinking about how to test a component often reveals flaws in its design.</li>
<li><strong>Component Design</strong>: TDD often leads to better-designed components. If a component is hard to test, it's often a sign that it's doing too much. The TDD process encourages you to break down complex components into smaller, more focused, and more testable units.</li>
<li><strong>Confidence and Coverage</strong>: By definition, TDD leads to 100% test coverage for the features you've built. This provides a robust safety net for future development and refactoring.</li>
</ul>
<h2 id="module-synthesis">Module Synthesis üìã</h2>
<h2 id="module-synthesis-building-with-confidence">Module Synthesis: Building with Confidence</h2>
<p>In this chapter, we've built a comprehensive understanding of how to test a modern React application. We moved beyond the simple idea of "checking for bugs" and embraced testing as a core part of the development process that enables confidence, maintainability, and better software design.</p>
<p>We started with a solid foundation in <strong>testing philosophy</strong>, adopting the <strong>Testing Trophy</strong> as our guide to balancing different types of tests for the best return on investment. We established our toolchain with <strong>Jest</strong> as the test runner and learned its fundamental assertion syntax.</p>
<p>The core of the chapter focused on <strong>React Testing Library</strong>, internalizing its user-centric philosophy. We learned to test everything from simple components to complex asynchronous behavior, user interactions, and the new <strong>Actions</strong> pattern in React 19.</p>
<p>We then demystified testing for modern React architectures, creating clear strategies for testing both <strong>Server Components</strong> (as async functions) and <strong>custom hooks</strong> (in isolation with <code>renderHook</code>).</p>
<p>Finally, we zoomed out to see the bigger picture, understanding the role of full <strong>End-to-End tests</strong> with tools like Playwright as the ultimate system-wide verification, and we explored the <strong>Test-Driven Development</strong> workflow as a discipline for building robust components from the ground up.</p>
<h2 id="looking-ahead">Looking Ahead</h2>
<p>A well-tested application is a prerequisite for long-term success and scalability. The skills you've learned here will be invaluable as we move into the final parts of the course.</p>
<ul>
<li>In <strong>Chapter 17: Server-Side Rendering and Frameworks</strong>, the testing patterns for Server and Client components will become even more relevant as we build full-stack applications with frameworks like Next.js.</li>
<li>In <strong>Chapter 28: Security Best Practices</strong>, we'll see how testing can be a first line of defense against common vulnerabilities.</li>
</ul>
<p>You are no longer just a developer who can build features; you are a developer who can build reliable, maintainable, and production-ready applications, backed by the confidence that only a solid test suite can provide.</p>
        </div>
        <div class="footer">
            Generated on 2025-10-25 16:27:48 | Made with ‚ù§Ô∏è by GitHub Pages Generator
        </div>
    </div>
    <script>
        // Syntax highlighting for code blocks
        document.addEventListener('DOMContentLoaded', (event) => {
            // Highlight code blocks
            document.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightElement(block);
            });
            
            // Add copy buttons to code blocks
            document.querySelectorAll('pre').forEach((pre) => {
                const button = document.createElement('button');
                button.className = 'copy-btn';
                button.textContent = 'Copy';
                
                button.addEventListener('click', () => {
                    const code = pre.querySelector('code').textContent;
                    navigator.clipboard.writeText(code).then(() => {
                        button.textContent = 'Copied!';
                        button.classList.add('copied');
                        setTimeout(() => {
                            button.textContent = 'Copy';
                            button.classList.remove('copied');
                        }, 2000);
                    }).catch(err => {
                        console.error('Failed to copy:', err);
                        button.textContent = 'Error';
                        setTimeout(() => {
                            button.textContent = 'Copy';
                        }, 2000);
                    });
                });
                
                pre.appendChild(button);
            });
        });
    </script>
</body>
</html>